/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type NotesOneSecurity = {
  apiKey: string;
};

export type NotesOneRequest = {
  /**
   * ID of the record you are acting upon.
   */
  id: string;
  /**
   * ID of the consumer which you want to get or push data from
   */
  consumerId: string;
  /**
   * The ID of your Unify application
   */
  appId: string;
  /**
   * Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API.
   */
  serviceId?: string | undefined;
  /**
   * Include raw response. Mostly used for debugging purposes
   */
  raw?: boolean | undefined;
  /**
   * The 'fields' parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. <br /><br />Example: `fields=name,email,addresses.city`<br /><br />In the example above, the response will only include the fields "name", "email" and "addresses.city". If any other fields are available, they will be excluded.
   */
  fields?: string | null | undefined;
};

/**
 * Contains parameter or domain specific information related to the error and why it occurred.
 */
export type NotesOneDetail = string | { [k: string]: any };

/**
 * Unexpected error
 */
export type NotesOneNotesResponseBody = {
  /**
   * HTTP status code
   */
  statusCode?: number | undefined;
  /**
   * Contains an explanation of the status_code as defined in HTTP/1.1 standard (RFC 7231)
   */
  error?: string | undefined;
  /**
   * The type of error returned
   */
  typeName?: string | undefined;
  /**
   * A human-readable message providing more details about the error.
   */
  message?: string | undefined;
  /**
   * Contains parameter or domain specific information related to the error and why it occurred.
   */
  detail?: string | { [k: string]: any } | undefined;
  /**
   * Link to documentation of error type
   */
  ref?: string | undefined;
};

/**
 * When custom mappings are configured on the resource, the result is included here.
 */
export type NotesOneCustomMappings = {};

export type NotesOneExtendPaths = {
  /**
   * JSONPath string specifying where to apply the value.
   */
  path: string;
  /**
   * The value to set at the specified path, can be any type.
   */
  value?: any | undefined;
};

export type NotesOnePassThrough = {
  /**
   * Identifier for the service to which this pass_through should be applied.
   */
  serviceId: string;
  /**
   * Optional identifier for a workflow operation to which this pass_through should be applied. This is useful for Unify calls that are making more than one downstream request.
   */
  operationId?: string | undefined;
  /**
   * Simple object allowing any properties for direct extension.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * Array of objects for structured data modifications via paths.
   */
  extendPaths?: Array<NotesOneExtendPaths> | undefined;
};

export type NotesOneData = {
  /**
   * The unique identifier of the note
   */
  id?: string | undefined;
  /**
   * The title of the note
   */
  title?: string | null | undefined;
  /**
   * The content of the note.
   */
  content?: string | null | undefined;
  /**
   * The user that owns the note.
   */
  ownerId?: string | null | undefined;
  /**
   * The contact that is related to the note.
   */
  contactId?: string | null | undefined;
  /**
   * The company that is related to the note.
   */
  companyId?: string | null | undefined;
  /**
   * The opportunity that is related to the note.
   */
  opportunityId?: string | null | undefined;
  /**
   * The lead that is related to the note.
   */
  leadId?: string | null | undefined;
  /**
   * Whether the Note is active or not.
   */
  active?: boolean | null | undefined;
  /**
   * When custom mappings are configured on the resource, the result is included here.
   */
  customMappings?: NotesOneCustomMappings | null | undefined;
  /**
   * The user that last updated the note.
   */
  updatedBy?: string | null | undefined;
  /**
   * The user that created the note.
   */
  createdBy?: string | null | undefined;
  /**
   * The timestamp when the note was last updated
   */
  updatedAt?: string | null | undefined;
  /**
   * The timestamp when the note was created
   */
  createdAt?: string | null | undefined;
  /**
   * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
   */
  passThrough?: Array<NotesOnePassThrough> | undefined;
};

/**
 * Note
 */
export type NotesOneResponseBody = {
  /**
   * HTTP Response Status Code
   */
  statusCode: number;
  /**
   * HTTP Response Status
   */
  status: string;
  /**
   * Apideck ID of service provider
   */
  service: string;
  /**
   * Unified API resource name
   */
  resource: string;
  /**
   * Operation performed
   */
  operation: string;
  data: NotesOneData;
};

export type NotesOneResponse = NotesOneResponseBody | NotesOneNotesResponseBody;

/** @internal */
export const NotesOneSecurity$inboundSchema: z.ZodType<
  NotesOneSecurity,
  z.ZodTypeDef,
  unknown
> = z.object({
  apiKey: z.string(),
});

/** @internal */
export type NotesOneSecurity$Outbound = {
  apiKey: string;
};

/** @internal */
export const NotesOneSecurity$outboundSchema: z.ZodType<
  NotesOneSecurity$Outbound,
  z.ZodTypeDef,
  NotesOneSecurity
> = z.object({
  apiKey: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesOneSecurity$ {
  /** @deprecated use `NotesOneSecurity$inboundSchema` instead. */
  export const inboundSchema = NotesOneSecurity$inboundSchema;
  /** @deprecated use `NotesOneSecurity$outboundSchema` instead. */
  export const outboundSchema = NotesOneSecurity$outboundSchema;
  /** @deprecated use `NotesOneSecurity$Outbound` instead. */
  export type Outbound = NotesOneSecurity$Outbound;
}

export function notesOneSecurityToJSON(
  notesOneSecurity: NotesOneSecurity,
): string {
  return JSON.stringify(
    NotesOneSecurity$outboundSchema.parse(notesOneSecurity),
  );
}

export function notesOneSecurityFromJSON(
  jsonString: string,
): SafeParseResult<NotesOneSecurity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesOneSecurity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesOneSecurity' from JSON`,
  );
}

/** @internal */
export const NotesOneRequest$inboundSchema: z.ZodType<
  NotesOneRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  consumerId: z.string(),
  appId: z.string(),
  serviceId: z.string().optional(),
  raw: z.boolean().default(false),
  fields: z.nullable(z.string()).optional(),
});

/** @internal */
export type NotesOneRequest$Outbound = {
  id: string;
  consumerId: string;
  appId: string;
  serviceId?: string | undefined;
  raw: boolean;
  fields?: string | null | undefined;
};

/** @internal */
export const NotesOneRequest$outboundSchema: z.ZodType<
  NotesOneRequest$Outbound,
  z.ZodTypeDef,
  NotesOneRequest
> = z.object({
  id: z.string(),
  consumerId: z.string(),
  appId: z.string(),
  serviceId: z.string().optional(),
  raw: z.boolean().default(false),
  fields: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesOneRequest$ {
  /** @deprecated use `NotesOneRequest$inboundSchema` instead. */
  export const inboundSchema = NotesOneRequest$inboundSchema;
  /** @deprecated use `NotesOneRequest$outboundSchema` instead. */
  export const outboundSchema = NotesOneRequest$outboundSchema;
  /** @deprecated use `NotesOneRequest$Outbound` instead. */
  export type Outbound = NotesOneRequest$Outbound;
}

export function notesOneRequestToJSON(
  notesOneRequest: NotesOneRequest,
): string {
  return JSON.stringify(NotesOneRequest$outboundSchema.parse(notesOneRequest));
}

export function notesOneRequestFromJSON(
  jsonString: string,
): SafeParseResult<NotesOneRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesOneRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesOneRequest' from JSON`,
  );
}

/** @internal */
export const NotesOneDetail$inboundSchema: z.ZodType<
  NotesOneDetail,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.record(z.any())]);

/** @internal */
export type NotesOneDetail$Outbound = string | { [k: string]: any };

/** @internal */
export const NotesOneDetail$outboundSchema: z.ZodType<
  NotesOneDetail$Outbound,
  z.ZodTypeDef,
  NotesOneDetail
> = z.union([z.string(), z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesOneDetail$ {
  /** @deprecated use `NotesOneDetail$inboundSchema` instead. */
  export const inboundSchema = NotesOneDetail$inboundSchema;
  /** @deprecated use `NotesOneDetail$outboundSchema` instead. */
  export const outboundSchema = NotesOneDetail$outboundSchema;
  /** @deprecated use `NotesOneDetail$Outbound` instead. */
  export type Outbound = NotesOneDetail$Outbound;
}

export function notesOneDetailToJSON(notesOneDetail: NotesOneDetail): string {
  return JSON.stringify(NotesOneDetail$outboundSchema.parse(notesOneDetail));
}

export function notesOneDetailFromJSON(
  jsonString: string,
): SafeParseResult<NotesOneDetail, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesOneDetail$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesOneDetail' from JSON`,
  );
}

/** @internal */
export const NotesOneNotesResponseBody$inboundSchema: z.ZodType<
  NotesOneNotesResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().optional(),
  error: z.string().optional(),
  type_name: z.string().optional(),
  message: z.string().optional(),
  detail: z.union([z.string(), z.record(z.any())]).optional(),
  ref: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
    "type_name": "typeName",
  });
});

/** @internal */
export type NotesOneNotesResponseBody$Outbound = {
  status_code?: number | undefined;
  error?: string | undefined;
  type_name?: string | undefined;
  message?: string | undefined;
  detail?: string | { [k: string]: any } | undefined;
  ref?: string | undefined;
};

/** @internal */
export const NotesOneNotesResponseBody$outboundSchema: z.ZodType<
  NotesOneNotesResponseBody$Outbound,
  z.ZodTypeDef,
  NotesOneNotesResponseBody
> = z.object({
  statusCode: z.number().optional(),
  error: z.string().optional(),
  typeName: z.string().optional(),
  message: z.string().optional(),
  detail: z.union([z.string(), z.record(z.any())]).optional(),
  ref: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
    typeName: "type_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesOneNotesResponseBody$ {
  /** @deprecated use `NotesOneNotesResponseBody$inboundSchema` instead. */
  export const inboundSchema = NotesOneNotesResponseBody$inboundSchema;
  /** @deprecated use `NotesOneNotesResponseBody$outboundSchema` instead. */
  export const outboundSchema = NotesOneNotesResponseBody$outboundSchema;
  /** @deprecated use `NotesOneNotesResponseBody$Outbound` instead. */
  export type Outbound = NotesOneNotesResponseBody$Outbound;
}

export function notesOneNotesResponseBodyToJSON(
  notesOneNotesResponseBody: NotesOneNotesResponseBody,
): string {
  return JSON.stringify(
    NotesOneNotesResponseBody$outboundSchema.parse(notesOneNotesResponseBody),
  );
}

export function notesOneNotesResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<NotesOneNotesResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesOneNotesResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesOneNotesResponseBody' from JSON`,
  );
}

/** @internal */
export const NotesOneCustomMappings$inboundSchema: z.ZodType<
  NotesOneCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type NotesOneCustomMappings$Outbound = {};

/** @internal */
export const NotesOneCustomMappings$outboundSchema: z.ZodType<
  NotesOneCustomMappings$Outbound,
  z.ZodTypeDef,
  NotesOneCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesOneCustomMappings$ {
  /** @deprecated use `NotesOneCustomMappings$inboundSchema` instead. */
  export const inboundSchema = NotesOneCustomMappings$inboundSchema;
  /** @deprecated use `NotesOneCustomMappings$outboundSchema` instead. */
  export const outboundSchema = NotesOneCustomMappings$outboundSchema;
  /** @deprecated use `NotesOneCustomMappings$Outbound` instead. */
  export type Outbound = NotesOneCustomMappings$Outbound;
}

export function notesOneCustomMappingsToJSON(
  notesOneCustomMappings: NotesOneCustomMappings,
): string {
  return JSON.stringify(
    NotesOneCustomMappings$outboundSchema.parse(notesOneCustomMappings),
  );
}

export function notesOneCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<NotesOneCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesOneCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesOneCustomMappings' from JSON`,
  );
}

/** @internal */
export const NotesOneExtendPaths$inboundSchema: z.ZodType<
  NotesOneExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type NotesOneExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const NotesOneExtendPaths$outboundSchema: z.ZodType<
  NotesOneExtendPaths$Outbound,
  z.ZodTypeDef,
  NotesOneExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesOneExtendPaths$ {
  /** @deprecated use `NotesOneExtendPaths$inboundSchema` instead. */
  export const inboundSchema = NotesOneExtendPaths$inboundSchema;
  /** @deprecated use `NotesOneExtendPaths$outboundSchema` instead. */
  export const outboundSchema = NotesOneExtendPaths$outboundSchema;
  /** @deprecated use `NotesOneExtendPaths$Outbound` instead. */
  export type Outbound = NotesOneExtendPaths$Outbound;
}

export function notesOneExtendPathsToJSON(
  notesOneExtendPaths: NotesOneExtendPaths,
): string {
  return JSON.stringify(
    NotesOneExtendPaths$outboundSchema.parse(notesOneExtendPaths),
  );
}

export function notesOneExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<NotesOneExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesOneExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesOneExtendPaths' from JSON`,
  );
}

/** @internal */
export const NotesOnePassThrough$inboundSchema: z.ZodType<
  NotesOnePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(z.lazy(() => NotesOneExtendPaths$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type NotesOnePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<NotesOneExtendPaths$Outbound> | undefined;
};

/** @internal */
export const NotesOnePassThrough$outboundSchema: z.ZodType<
  NotesOnePassThrough$Outbound,
  z.ZodTypeDef,
  NotesOnePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(z.lazy(() => NotesOneExtendPaths$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesOnePassThrough$ {
  /** @deprecated use `NotesOnePassThrough$inboundSchema` instead. */
  export const inboundSchema = NotesOnePassThrough$inboundSchema;
  /** @deprecated use `NotesOnePassThrough$outboundSchema` instead. */
  export const outboundSchema = NotesOnePassThrough$outboundSchema;
  /** @deprecated use `NotesOnePassThrough$Outbound` instead. */
  export type Outbound = NotesOnePassThrough$Outbound;
}

export function notesOnePassThroughToJSON(
  notesOnePassThrough: NotesOnePassThrough,
): string {
  return JSON.stringify(
    NotesOnePassThrough$outboundSchema.parse(notesOnePassThrough),
  );
}

export function notesOnePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<NotesOnePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesOnePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesOnePassThrough' from JSON`,
  );
}

/** @internal */
export const NotesOneData$inboundSchema: z.ZodType<
  NotesOneData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  owner_id: z.nullable(z.string()).optional(),
  contact_id: z.nullable(z.string()).optional(),
  company_id: z.nullable(z.string()).optional(),
  opportunity_id: z.nullable(z.string()).optional(),
  lead_id: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  custom_mappings: z.nullable(
    z.lazy(() => NotesOneCustomMappings$inboundSchema),
  ).optional(),
  updated_by: z.nullable(z.string()).optional(),
  created_by: z.nullable(z.string()).optional(),
  updated_at: z.nullable(z.string()).optional(),
  created_at: z.nullable(z.string()).optional(),
  pass_through: z.array(z.lazy(() => NotesOnePassThrough$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "contact_id": "contactId",
    "company_id": "companyId",
    "opportunity_id": "opportunityId",
    "lead_id": "leadId",
    "custom_mappings": "customMappings",
    "updated_by": "updatedBy",
    "created_by": "createdBy",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type NotesOneData$Outbound = {
  id?: string | undefined;
  title?: string | null | undefined;
  content?: string | null | undefined;
  owner_id?: string | null | undefined;
  contact_id?: string | null | undefined;
  company_id?: string | null | undefined;
  opportunity_id?: string | null | undefined;
  lead_id?: string | null | undefined;
  active?: boolean | null | undefined;
  custom_mappings?: NotesOneCustomMappings$Outbound | null | undefined;
  updated_by?: string | null | undefined;
  created_by?: string | null | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  pass_through?: Array<NotesOnePassThrough$Outbound> | undefined;
};

/** @internal */
export const NotesOneData$outboundSchema: z.ZodType<
  NotesOneData$Outbound,
  z.ZodTypeDef,
  NotesOneData
> = z.object({
  id: z.string().optional(),
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  ownerId: z.nullable(z.string()).optional(),
  contactId: z.nullable(z.string()).optional(),
  companyId: z.nullable(z.string()).optional(),
  opportunityId: z.nullable(z.string()).optional(),
  leadId: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  customMappings: z.nullable(
    z.lazy(() => NotesOneCustomMappings$outboundSchema),
  ).optional(),
  updatedBy: z.nullable(z.string()).optional(),
  createdBy: z.nullable(z.string()).optional(),
  updatedAt: z.nullable(z.string()).optional(),
  createdAt: z.nullable(z.string()).optional(),
  passThrough: z.array(z.lazy(() => NotesOnePassThrough$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    contactId: "contact_id",
    companyId: "company_id",
    opportunityId: "opportunity_id",
    leadId: "lead_id",
    customMappings: "custom_mappings",
    updatedBy: "updated_by",
    createdBy: "created_by",
    updatedAt: "updated_at",
    createdAt: "created_at",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesOneData$ {
  /** @deprecated use `NotesOneData$inboundSchema` instead. */
  export const inboundSchema = NotesOneData$inboundSchema;
  /** @deprecated use `NotesOneData$outboundSchema` instead. */
  export const outboundSchema = NotesOneData$outboundSchema;
  /** @deprecated use `NotesOneData$Outbound` instead. */
  export type Outbound = NotesOneData$Outbound;
}

export function notesOneDataToJSON(notesOneData: NotesOneData): string {
  return JSON.stringify(NotesOneData$outboundSchema.parse(notesOneData));
}

export function notesOneDataFromJSON(
  jsonString: string,
): SafeParseResult<NotesOneData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesOneData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesOneData' from JSON`,
  );
}

/** @internal */
export const NotesOneResponseBody$inboundSchema: z.ZodType<
  NotesOneResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => NotesOneData$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type NotesOneResponseBody$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: NotesOneData$Outbound;
};

/** @internal */
export const NotesOneResponseBody$outboundSchema: z.ZodType<
  NotesOneResponseBody$Outbound,
  z.ZodTypeDef,
  NotesOneResponseBody
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => NotesOneData$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesOneResponseBody$ {
  /** @deprecated use `NotesOneResponseBody$inboundSchema` instead. */
  export const inboundSchema = NotesOneResponseBody$inboundSchema;
  /** @deprecated use `NotesOneResponseBody$outboundSchema` instead. */
  export const outboundSchema = NotesOneResponseBody$outboundSchema;
  /** @deprecated use `NotesOneResponseBody$Outbound` instead. */
  export type Outbound = NotesOneResponseBody$Outbound;
}

export function notesOneResponseBodyToJSON(
  notesOneResponseBody: NotesOneResponseBody,
): string {
  return JSON.stringify(
    NotesOneResponseBody$outboundSchema.parse(notesOneResponseBody),
  );
}

export function notesOneResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<NotesOneResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesOneResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesOneResponseBody' from JSON`,
  );
}

/** @internal */
export const NotesOneResponse$inboundSchema: z.ZodType<
  NotesOneResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => NotesOneResponseBody$inboundSchema),
  z.lazy(() => NotesOneNotesResponseBody$inboundSchema),
]);

/** @internal */
export type NotesOneResponse$Outbound =
  | NotesOneResponseBody$Outbound
  | NotesOneNotesResponseBody$Outbound;

/** @internal */
export const NotesOneResponse$outboundSchema: z.ZodType<
  NotesOneResponse$Outbound,
  z.ZodTypeDef,
  NotesOneResponse
> = z.union([
  z.lazy(() => NotesOneResponseBody$outboundSchema),
  z.lazy(() => NotesOneNotesResponseBody$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesOneResponse$ {
  /** @deprecated use `NotesOneResponse$inboundSchema` instead. */
  export const inboundSchema = NotesOneResponse$inboundSchema;
  /** @deprecated use `NotesOneResponse$outboundSchema` instead. */
  export const outboundSchema = NotesOneResponse$outboundSchema;
  /** @deprecated use `NotesOneResponse$Outbound` instead. */
  export type Outbound = NotesOneResponse$Outbound;
}

export function notesOneResponseToJSON(
  notesOneResponse: NotesOneResponse,
): string {
  return JSON.stringify(
    NotesOneResponse$outboundSchema.parse(notesOneResponse),
  );
}

export function notesOneResponseFromJSON(
  jsonString: string,
): SafeParseResult<NotesOneResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesOneResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesOneResponse' from JSON`,
  );
}

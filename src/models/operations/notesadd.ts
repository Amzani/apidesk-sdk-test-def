/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type NotesAddSecurity = {
  apiKey: string;
};

export type NotesAddExtendPaths = {
  /**
   * JSONPath string specifying where to apply the value.
   */
  path: string;
  /**
   * The value to set at the specified path, can be any type.
   */
  value?: any | undefined;
};

export type NotesAddPassThrough = {
  /**
   * Identifier for the service to which this pass_through should be applied.
   */
  serviceId: string;
  /**
   * Optional identifier for a workflow operation to which this pass_through should be applied. This is useful for Unify calls that are making more than one downstream request.
   */
  operationId?: string | undefined;
  /**
   * Simple object allowing any properties for direct extension.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * Array of objects for structured data modifications via paths.
   */
  extendPaths?: Array<NotesAddExtendPaths> | undefined;
};

export type NotesAddRequestBody = {
  /**
   * The title of the note
   */
  title?: string | null | undefined;
  /**
   * The content of the note.
   */
  content?: string | null | undefined;
  /**
   * The user that owns the note.
   */
  ownerId?: string | null | undefined;
  /**
   * The contact that is related to the note.
   */
  contactId?: string | null | undefined;
  /**
   * The company that is related to the note.
   */
  companyId?: string | null | undefined;
  /**
   * The opportunity that is related to the note.
   */
  opportunityId?: string | null | undefined;
  /**
   * The lead that is related to the note.
   */
  leadId?: string | null | undefined;
  /**
   * Whether the Note is active or not.
   */
  active?: boolean | null | undefined;
  /**
   * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
   */
  passThrough?: Array<NotesAddPassThrough> | undefined;
};

export type NotesAddRequest = {
  /**
   * Include raw response. Mostly used for debugging purposes
   */
  raw?: boolean | undefined;
  /**
   * ID of the consumer which you want to get or push data from
   */
  consumerId: string;
  /**
   * The ID of your Unify application
   */
  appId: string;
  /**
   * Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API.
   */
  serviceId?: string | undefined;
  requestBody: NotesAddRequestBody;
};

/**
 * Contains parameter or domain specific information related to the error and why it occurred.
 */
export type NotesAddDetail = string | { [k: string]: any };

/**
 * Unexpected error
 */
export type NotesAddNotesResponseBody = {
  /**
   * HTTP status code
   */
  statusCode?: number | undefined;
  /**
   * Contains an explanation of the status_code as defined in HTTP/1.1 standard (RFC 7231)
   */
  error?: string | undefined;
  /**
   * The type of error returned
   */
  typeName?: string | undefined;
  /**
   * A human-readable message providing more details about the error.
   */
  message?: string | undefined;
  /**
   * Contains parameter or domain specific information related to the error and why it occurred.
   */
  detail?: string | { [k: string]: any } | undefined;
  /**
   * Link to documentation of error type
   */
  ref?: string | undefined;
};

export type NotesAddUnifiedId = {
  /**
   * The unique identifier of the resource
   */
  id: string;
};

/**
 * Note created
 */
export type NotesAddResponseBody = {
  /**
   * HTTP Response Status Code
   */
  statusCode: number;
  /**
   * HTTP Response Status
   */
  status: string;
  /**
   * Apideck ID of service provider
   */
  service: string;
  /**
   * Unified API resource name
   */
  resource: string;
  /**
   * Operation performed
   */
  operation: string;
  data: NotesAddUnifiedId;
};

export type NotesAddResponse = NotesAddResponseBody | NotesAddNotesResponseBody;

/** @internal */
export const NotesAddSecurity$inboundSchema: z.ZodType<
  NotesAddSecurity,
  z.ZodTypeDef,
  unknown
> = z.object({
  apiKey: z.string(),
});

/** @internal */
export type NotesAddSecurity$Outbound = {
  apiKey: string;
};

/** @internal */
export const NotesAddSecurity$outboundSchema: z.ZodType<
  NotesAddSecurity$Outbound,
  z.ZodTypeDef,
  NotesAddSecurity
> = z.object({
  apiKey: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesAddSecurity$ {
  /** @deprecated use `NotesAddSecurity$inboundSchema` instead. */
  export const inboundSchema = NotesAddSecurity$inboundSchema;
  /** @deprecated use `NotesAddSecurity$outboundSchema` instead. */
  export const outboundSchema = NotesAddSecurity$outboundSchema;
  /** @deprecated use `NotesAddSecurity$Outbound` instead. */
  export type Outbound = NotesAddSecurity$Outbound;
}

export function notesAddSecurityToJSON(
  notesAddSecurity: NotesAddSecurity,
): string {
  return JSON.stringify(
    NotesAddSecurity$outboundSchema.parse(notesAddSecurity),
  );
}

export function notesAddSecurityFromJSON(
  jsonString: string,
): SafeParseResult<NotesAddSecurity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesAddSecurity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesAddSecurity' from JSON`,
  );
}

/** @internal */
export const NotesAddExtendPaths$inboundSchema: z.ZodType<
  NotesAddExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type NotesAddExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const NotesAddExtendPaths$outboundSchema: z.ZodType<
  NotesAddExtendPaths$Outbound,
  z.ZodTypeDef,
  NotesAddExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesAddExtendPaths$ {
  /** @deprecated use `NotesAddExtendPaths$inboundSchema` instead. */
  export const inboundSchema = NotesAddExtendPaths$inboundSchema;
  /** @deprecated use `NotesAddExtendPaths$outboundSchema` instead. */
  export const outboundSchema = NotesAddExtendPaths$outboundSchema;
  /** @deprecated use `NotesAddExtendPaths$Outbound` instead. */
  export type Outbound = NotesAddExtendPaths$Outbound;
}

export function notesAddExtendPathsToJSON(
  notesAddExtendPaths: NotesAddExtendPaths,
): string {
  return JSON.stringify(
    NotesAddExtendPaths$outboundSchema.parse(notesAddExtendPaths),
  );
}

export function notesAddExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<NotesAddExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesAddExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesAddExtendPaths' from JSON`,
  );
}

/** @internal */
export const NotesAddPassThrough$inboundSchema: z.ZodType<
  NotesAddPassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(z.lazy(() => NotesAddExtendPaths$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type NotesAddPassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<NotesAddExtendPaths$Outbound> | undefined;
};

/** @internal */
export const NotesAddPassThrough$outboundSchema: z.ZodType<
  NotesAddPassThrough$Outbound,
  z.ZodTypeDef,
  NotesAddPassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(z.lazy(() => NotesAddExtendPaths$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesAddPassThrough$ {
  /** @deprecated use `NotesAddPassThrough$inboundSchema` instead. */
  export const inboundSchema = NotesAddPassThrough$inboundSchema;
  /** @deprecated use `NotesAddPassThrough$outboundSchema` instead. */
  export const outboundSchema = NotesAddPassThrough$outboundSchema;
  /** @deprecated use `NotesAddPassThrough$Outbound` instead. */
  export type Outbound = NotesAddPassThrough$Outbound;
}

export function notesAddPassThroughToJSON(
  notesAddPassThrough: NotesAddPassThrough,
): string {
  return JSON.stringify(
    NotesAddPassThrough$outboundSchema.parse(notesAddPassThrough),
  );
}

export function notesAddPassThroughFromJSON(
  jsonString: string,
): SafeParseResult<NotesAddPassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesAddPassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesAddPassThrough' from JSON`,
  );
}

/** @internal */
export const NotesAddRequestBody$inboundSchema: z.ZodType<
  NotesAddRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  owner_id: z.nullable(z.string()).optional(),
  contact_id: z.nullable(z.string()).optional(),
  company_id: z.nullable(z.string()).optional(),
  opportunity_id: z.nullable(z.string()).optional(),
  lead_id: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  pass_through: z.array(z.lazy(() => NotesAddPassThrough$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "contact_id": "contactId",
    "company_id": "companyId",
    "opportunity_id": "opportunityId",
    "lead_id": "leadId",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type NotesAddRequestBody$Outbound = {
  title?: string | null | undefined;
  content?: string | null | undefined;
  owner_id?: string | null | undefined;
  contact_id?: string | null | undefined;
  company_id?: string | null | undefined;
  opportunity_id?: string | null | undefined;
  lead_id?: string | null | undefined;
  active?: boolean | null | undefined;
  pass_through?: Array<NotesAddPassThrough$Outbound> | undefined;
};

/** @internal */
export const NotesAddRequestBody$outboundSchema: z.ZodType<
  NotesAddRequestBody$Outbound,
  z.ZodTypeDef,
  NotesAddRequestBody
> = z.object({
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  ownerId: z.nullable(z.string()).optional(),
  contactId: z.nullable(z.string()).optional(),
  companyId: z.nullable(z.string()).optional(),
  opportunityId: z.nullable(z.string()).optional(),
  leadId: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  passThrough: z.array(z.lazy(() => NotesAddPassThrough$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    contactId: "contact_id",
    companyId: "company_id",
    opportunityId: "opportunity_id",
    leadId: "lead_id",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesAddRequestBody$ {
  /** @deprecated use `NotesAddRequestBody$inboundSchema` instead. */
  export const inboundSchema = NotesAddRequestBody$inboundSchema;
  /** @deprecated use `NotesAddRequestBody$outboundSchema` instead. */
  export const outboundSchema = NotesAddRequestBody$outboundSchema;
  /** @deprecated use `NotesAddRequestBody$Outbound` instead. */
  export type Outbound = NotesAddRequestBody$Outbound;
}

export function notesAddRequestBodyToJSON(
  notesAddRequestBody: NotesAddRequestBody,
): string {
  return JSON.stringify(
    NotesAddRequestBody$outboundSchema.parse(notesAddRequestBody),
  );
}

export function notesAddRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<NotesAddRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesAddRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesAddRequestBody' from JSON`,
  );
}

/** @internal */
export const NotesAddRequest$inboundSchema: z.ZodType<
  NotesAddRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  raw: z.boolean().default(false),
  consumerId: z.string(),
  appId: z.string(),
  serviceId: z.string().optional(),
  RequestBody: z.lazy(() => NotesAddRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type NotesAddRequest$Outbound = {
  raw: boolean;
  consumerId: string;
  appId: string;
  serviceId?: string | undefined;
  RequestBody: NotesAddRequestBody$Outbound;
};

/** @internal */
export const NotesAddRequest$outboundSchema: z.ZodType<
  NotesAddRequest$Outbound,
  z.ZodTypeDef,
  NotesAddRequest
> = z.object({
  raw: z.boolean().default(false),
  consumerId: z.string(),
  appId: z.string(),
  serviceId: z.string().optional(),
  requestBody: z.lazy(() => NotesAddRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesAddRequest$ {
  /** @deprecated use `NotesAddRequest$inboundSchema` instead. */
  export const inboundSchema = NotesAddRequest$inboundSchema;
  /** @deprecated use `NotesAddRequest$outboundSchema` instead. */
  export const outboundSchema = NotesAddRequest$outboundSchema;
  /** @deprecated use `NotesAddRequest$Outbound` instead. */
  export type Outbound = NotesAddRequest$Outbound;
}

export function notesAddRequestToJSON(
  notesAddRequest: NotesAddRequest,
): string {
  return JSON.stringify(NotesAddRequest$outboundSchema.parse(notesAddRequest));
}

export function notesAddRequestFromJSON(
  jsonString: string,
): SafeParseResult<NotesAddRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesAddRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesAddRequest' from JSON`,
  );
}

/** @internal */
export const NotesAddDetail$inboundSchema: z.ZodType<
  NotesAddDetail,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.record(z.any())]);

/** @internal */
export type NotesAddDetail$Outbound = string | { [k: string]: any };

/** @internal */
export const NotesAddDetail$outboundSchema: z.ZodType<
  NotesAddDetail$Outbound,
  z.ZodTypeDef,
  NotesAddDetail
> = z.union([z.string(), z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesAddDetail$ {
  /** @deprecated use `NotesAddDetail$inboundSchema` instead. */
  export const inboundSchema = NotesAddDetail$inboundSchema;
  /** @deprecated use `NotesAddDetail$outboundSchema` instead. */
  export const outboundSchema = NotesAddDetail$outboundSchema;
  /** @deprecated use `NotesAddDetail$Outbound` instead. */
  export type Outbound = NotesAddDetail$Outbound;
}

export function notesAddDetailToJSON(notesAddDetail: NotesAddDetail): string {
  return JSON.stringify(NotesAddDetail$outboundSchema.parse(notesAddDetail));
}

export function notesAddDetailFromJSON(
  jsonString: string,
): SafeParseResult<NotesAddDetail, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesAddDetail$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesAddDetail' from JSON`,
  );
}

/** @internal */
export const NotesAddNotesResponseBody$inboundSchema: z.ZodType<
  NotesAddNotesResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().optional(),
  error: z.string().optional(),
  type_name: z.string().optional(),
  message: z.string().optional(),
  detail: z.union([z.string(), z.record(z.any())]).optional(),
  ref: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
    "type_name": "typeName",
  });
});

/** @internal */
export type NotesAddNotesResponseBody$Outbound = {
  status_code?: number | undefined;
  error?: string | undefined;
  type_name?: string | undefined;
  message?: string | undefined;
  detail?: string | { [k: string]: any } | undefined;
  ref?: string | undefined;
};

/** @internal */
export const NotesAddNotesResponseBody$outboundSchema: z.ZodType<
  NotesAddNotesResponseBody$Outbound,
  z.ZodTypeDef,
  NotesAddNotesResponseBody
> = z.object({
  statusCode: z.number().optional(),
  error: z.string().optional(),
  typeName: z.string().optional(),
  message: z.string().optional(),
  detail: z.union([z.string(), z.record(z.any())]).optional(),
  ref: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
    typeName: "type_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesAddNotesResponseBody$ {
  /** @deprecated use `NotesAddNotesResponseBody$inboundSchema` instead. */
  export const inboundSchema = NotesAddNotesResponseBody$inboundSchema;
  /** @deprecated use `NotesAddNotesResponseBody$outboundSchema` instead. */
  export const outboundSchema = NotesAddNotesResponseBody$outboundSchema;
  /** @deprecated use `NotesAddNotesResponseBody$Outbound` instead. */
  export type Outbound = NotesAddNotesResponseBody$Outbound;
}

export function notesAddNotesResponseBodyToJSON(
  notesAddNotesResponseBody: NotesAddNotesResponseBody,
): string {
  return JSON.stringify(
    NotesAddNotesResponseBody$outboundSchema.parse(notesAddNotesResponseBody),
  );
}

export function notesAddNotesResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<NotesAddNotesResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesAddNotesResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesAddNotesResponseBody' from JSON`,
  );
}

/** @internal */
export const NotesAddUnifiedId$inboundSchema: z.ZodType<
  NotesAddUnifiedId,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

/** @internal */
export type NotesAddUnifiedId$Outbound = {
  id: string;
};

/** @internal */
export const NotesAddUnifiedId$outboundSchema: z.ZodType<
  NotesAddUnifiedId$Outbound,
  z.ZodTypeDef,
  NotesAddUnifiedId
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesAddUnifiedId$ {
  /** @deprecated use `NotesAddUnifiedId$inboundSchema` instead. */
  export const inboundSchema = NotesAddUnifiedId$inboundSchema;
  /** @deprecated use `NotesAddUnifiedId$outboundSchema` instead. */
  export const outboundSchema = NotesAddUnifiedId$outboundSchema;
  /** @deprecated use `NotesAddUnifiedId$Outbound` instead. */
  export type Outbound = NotesAddUnifiedId$Outbound;
}

export function notesAddUnifiedIdToJSON(
  notesAddUnifiedId: NotesAddUnifiedId,
): string {
  return JSON.stringify(
    NotesAddUnifiedId$outboundSchema.parse(notesAddUnifiedId),
  );
}

export function notesAddUnifiedIdFromJSON(
  jsonString: string,
): SafeParseResult<NotesAddUnifiedId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesAddUnifiedId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesAddUnifiedId' from JSON`,
  );
}

/** @internal */
export const NotesAddResponseBody$inboundSchema: z.ZodType<
  NotesAddResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => NotesAddUnifiedId$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type NotesAddResponseBody$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: NotesAddUnifiedId$Outbound;
};

/** @internal */
export const NotesAddResponseBody$outboundSchema: z.ZodType<
  NotesAddResponseBody$Outbound,
  z.ZodTypeDef,
  NotesAddResponseBody
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => NotesAddUnifiedId$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesAddResponseBody$ {
  /** @deprecated use `NotesAddResponseBody$inboundSchema` instead. */
  export const inboundSchema = NotesAddResponseBody$inboundSchema;
  /** @deprecated use `NotesAddResponseBody$outboundSchema` instead. */
  export const outboundSchema = NotesAddResponseBody$outboundSchema;
  /** @deprecated use `NotesAddResponseBody$Outbound` instead. */
  export type Outbound = NotesAddResponseBody$Outbound;
}

export function notesAddResponseBodyToJSON(
  notesAddResponseBody: NotesAddResponseBody,
): string {
  return JSON.stringify(
    NotesAddResponseBody$outboundSchema.parse(notesAddResponseBody),
  );
}

export function notesAddResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<NotesAddResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesAddResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesAddResponseBody' from JSON`,
  );
}

/** @internal */
export const NotesAddResponse$inboundSchema: z.ZodType<
  NotesAddResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => NotesAddResponseBody$inboundSchema),
  z.lazy(() => NotesAddNotesResponseBody$inboundSchema),
]);

/** @internal */
export type NotesAddResponse$Outbound =
  | NotesAddResponseBody$Outbound
  | NotesAddNotesResponseBody$Outbound;

/** @internal */
export const NotesAddResponse$outboundSchema: z.ZodType<
  NotesAddResponse$Outbound,
  z.ZodTypeDef,
  NotesAddResponse
> = z.union([
  z.lazy(() => NotesAddResponseBody$outboundSchema),
  z.lazy(() => NotesAddNotesResponseBody$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesAddResponse$ {
  /** @deprecated use `NotesAddResponse$inboundSchema` instead. */
  export const inboundSchema = NotesAddResponse$inboundSchema;
  /** @deprecated use `NotesAddResponse$outboundSchema` instead. */
  export const outboundSchema = NotesAddResponse$outboundSchema;
  /** @deprecated use `NotesAddResponse$Outbound` instead. */
  export type Outbound = NotesAddResponse$Outbound;
}

export function notesAddResponseToJSON(
  notesAddResponse: NotesAddResponse,
): string {
  return JSON.stringify(
    NotesAddResponse$outboundSchema.parse(notesAddResponse),
  );
}

export function notesAddResponseFromJSON(
  jsonString: string,
): SafeParseResult<NotesAddResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesAddResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesAddResponse' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { RFCDate } from "../../types/rfcdate.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CompaniesAddSecurity = {
  apiKey: string;
};

/**
 * Specifies the currency in which the company's financial transactions are conducted, adhering to the ISO 4217 standard. This field is essential for financial consistency and accuracy in reporting, billing, and accounting processes within the CRM. It ensures that all monetary values are correctly interpreted and managed across different regions and markets.
 */
export const Currency = {
  UnknownCurrency: "UNKNOWN_CURRENCY",
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Bov: "BOV",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Che: "CHE",
  Chf: "CHF",
  Chw: "CHW",
  Clf: "CLF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Cou: "COU",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Ltl: "LTL",
  Lvl: "LVL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Mxv: "MXV",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Srd: "SRD",
  Ssp: "SSP",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Trc: "TRC",
  Try: "TRY",
  Ttd: "TTD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Usn: "USN",
  Uss: "USS",
  Uyi: "UYI",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xag: "XAG",
  Xau: "XAU",
  Xba: "XBA",
  Xbb: "XBB",
  Xbc: "XBC",
  Xbd: "XBD",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpd: "XPD",
  Xpf: "XPF",
  Xpt: "XPT",
  Xts: "XTS",
  Xxx: "XXX",
  Yer: "YER",
  Zar: "ZAR",
  Zmk: "ZMK",
  Zmw: "ZMW",
  Btc: "BTC",
  Eth: "ETH",
} as const;
/**
 * Specifies the currency in which the company's financial transactions are conducted, adhering to the ISO 4217 standard. This field is essential for financial consistency and accuracy in reporting, billing, and accounting processes within the CRM. It ensures that all monetary values are correctly interpreted and managed across different regions and markets.
 */
export type Currency = ClosedEnum<typeof Currency>;

/**
 * Specifies the category of the bank account, such as 'checking', 'savings', or 'business'. This information helps in identifying the nature of the account and may influence transaction processing rules and fees. Understanding the account type is crucial for financial planning and integration with other financial services.
 */
export const AccountType = {
  BankAccount: "bank_account",
  CreditCard: "credit_card",
  Other: "other",
} as const;
/**
 * Specifies the category of the bank account, such as 'checking', 'savings', or 'business'. This information helps in identifying the nature of the account and may influence transaction processing rules and fees. Understanding the account type is crucial for financial planning and integration with other financial services.
 */
export type AccountType = ClosedEnum<typeof AccountType>;

/**
 * The currency field specifies the type of currency associated with the company's financial transactions, adhering to the ISO 4217 standard. This information is crucial for the CRM system to handle financial data accurately, especially in multi-currency environments. While not mandatory, specifying the currency can prevent errors in financial reporting and ensure that all monetary values are correctly interpreted and processed. Users should select the appropriate currency code to align with the company's financial operations and reporting requirements.
 */
export const CompaniesAddCurrency = {
  UnknownCurrency: "UNKNOWN_CURRENCY",
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Bov: "BOV",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Che: "CHE",
  Chf: "CHF",
  Chw: "CHW",
  Clf: "CLF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Cou: "COU",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Ltl: "LTL",
  Lvl: "LVL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Mxv: "MXV",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Srd: "SRD",
  Ssp: "SSP",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Trc: "TRC",
  Try: "TRY",
  Ttd: "TTD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Usn: "USN",
  Uss: "USS",
  Uyi: "UYI",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xag: "XAG",
  Xau: "XAU",
  Xba: "XBA",
  Xbb: "XBB",
  Xbc: "XBC",
  Xbd: "XBD",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpd: "XPD",
  Xpf: "XPF",
  Xpt: "XPT",
  Xts: "XTS",
  Xxx: "XXX",
  Yer: "YER",
  Zar: "ZAR",
  Zmk: "ZMK",
  Zmw: "ZMW",
  Btc: "BTC",
  Eth: "ETH",
} as const;
/**
 * The currency field specifies the type of currency associated with the company's financial transactions, adhering to the ISO 4217 standard. This information is crucial for the CRM system to handle financial data accurately, especially in multi-currency environments. While not mandatory, specifying the currency can prevent errors in financial reporting and ensure that all monetary values are correctly interpreted and processed. Users should select the appropriate currency code to align with the company's financial operations and reporting requirements.
 */
export type CompaniesAddCurrency = ClosedEnum<typeof CompaniesAddCurrency>;

export type BankAccounts = {
  /**
   * The official name of the bank where the company's account is held. This optional field is part of the bank account details and is important for identifying the financial institution for transactions and audits. It ensures clarity in financial dealings and is often required for compliance and verification processes.
   */
  bankName?: string | null | undefined;
  /**
   * The unique number assigned to the company's bank account by the financial institution. This optional field is crucial for executing financial transactions, such as payments and deposits, and must be accurate to avoid errors. Each account number is distinct and should be kept confidential to prevent unauthorized access.
   */
  accountNumber?: string | null | undefined;
  /**
   * The name associated with the bank account, typically matching the name of the account holder or the business entity. This is used to verify the account's ownership and ensure that transactions are processed correctly. While not required, providing an accurate account name can help prevent errors in financial operations and is beneficial for record-keeping and auditing purposes.
   */
  accountName?: string | null | undefined;
  /**
   * Specifies the category of the bank account, such as 'checking', 'savings', or 'business'. This information helps in identifying the nature of the account and may influence transaction processing rules and fees. Understanding the account type is crucial for financial planning and integration with other financial services.
   */
  accountType?: AccountType | null | undefined;
  /**
   * The International Bank Account Number (IBAN) is a standardized international numbering system developed to identify bank accounts across national borders. It is essential for facilitating international transactions and ensuring that funds are transferred to the correct account. Providing a valid IBAN is crucial for businesses engaged in global trade and commerce.
   */
  iban?: string | null | undefined;
  /**
   * The Bank Identifier Code (BIC), also known as the SWIFT code, is a unique identifier for a bank used in international transactions. It ensures that payments are routed to the correct financial institution. Including the BIC is important for companies dealing with international clients or suppliers, as it helps in reducing transaction errors and delays.
   */
  bic?: string | null | undefined;
  /**
   * A routing number is a nine-digit code used to identify a financial institution in the United States. It is necessary for domestic transfers and direct deposits, ensuring that funds are directed to the correct bank. This is particularly important for businesses operating in the U.S. to facilitate smooth financial transactions and payroll processing.
   */
  routingNumber?: string | null | undefined;
  /**
   * The BSB number is a six-digit numeric code essential for identifying the specific branch of an Australian or New Zealand bank or financial institution. In the context of adding a company to the CRM, this number is crucial for ensuring that any financial transactions or banking details associated with the company are accurately linked to the correct branch. While not mandatory, providing a BSB number can facilitate smoother financial operations and integrations with banking services. It is important to ensure the BSB number is valid and corresponds to the correct branch to avoid any transactional errors.
   */
  bsbNumber?: string | null | undefined;
  /**
   * The branch identifier serves as a unique code for pinpointing the exact branch of a bank or financial institution where the company's account is held. This identifier is particularly useful in the CRM system for distinguishing between different branches of the same bank, ensuring that financial data is accurately recorded and managed. Although not required, including the branch identifier can enhance the precision of financial records and support seamless integration with banking services. Users should verify the accuracy of this identifier to prevent any discrepancies in financial transactions.
   */
  branchIdentifier?: string | null | undefined;
  /**
   * The bank code is a specific code assigned by a central authority, such as a central bank or a banking association, to identify licensed banks or financial institutions within a country. In the context of the CRM operation, this code is vital for correctly associating the company's financial transactions with the appropriate bank. While optional, providing the bank code can improve the accuracy of financial data management and facilitate integration with various banking services. It is advisable to ensure the bank code is correct to avoid misrouting of financial information.
   */
  bankCode?: string | null | undefined;
  /**
   * The currency field specifies the type of currency associated with the company's financial transactions, adhering to the ISO 4217 standard. This information is crucial for the CRM system to handle financial data accurately, especially in multi-currency environments. While not mandatory, specifying the currency can prevent errors in financial reporting and ensure that all monetary values are correctly interpreted and processed. Users should select the appropriate currency code to align with the company's financial operations and reporting requirements.
   */
  currency?: CompaniesAddCurrency | null | undefined;
};

/**
 * Specifies the category or role of the website, such as 'corporate', 'e-commerce', or 'blog'. This optional field helps in classifying the website's purpose, aiding CRM users in understanding the context and function of each site associated with the company. Providing this information can enhance data organization and retrieval.
 */
export const Type = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * Specifies the category or role of the website, such as 'corporate', 'e-commerce', or 'blog'. This optional field helps in classifying the website's purpose, aiding CRM users in understanding the context and function of each site associated with the company. Providing this information can enhance data organization and retrieval.
 */
export type Type = ClosedEnum<typeof Type>;

export type Websites = {
  /**
   * A unique identifier assigned to each website associated with the company. This ID is used internally to track and manage website records within the CRM system. Although not required, providing this ID can help in updating or referencing specific websites in future operations, ensuring seamless integration and data consistency across different platforms.
   */
  id?: string | null | undefined;
  /**
   * The full URL of the company's website, which serves as a digital presence and point of contact for the business. This field is mandatory as it helps in identifying the company's online footprint and is crucial for CRM users to access company information quickly. Ensure the URL is correctly formatted and accessible to avoid errors during the operation.
   */
  url: string;
  /**
   * Specifies the category or role of the website, such as 'corporate', 'e-commerce', or 'blog'. This optional field helps in classifying the website's purpose, aiding CRM users in understanding the context and function of each site associated with the company. Providing this information can enhance data organization and retrieval.
   */
  type?: Type | null | undefined;
};

/**
 * Specifies the category or classification of the address, such as 'billing', 'shipping', or 'office'. This helps in distinguishing between different address purposes within the CRM system, ensuring that communications and shipments are directed appropriately. While not mandatory, providing this information can enhance the accuracy of address-related operations.
 */
export const CompaniesAddType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Office: "office",
  Shipping: "shipping",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the category or classification of the address, such as 'billing', 'shipping', or 'office'. This helps in distinguishing between different address purposes within the CRM system, ensuring that communications and shipments are directed appropriately. While not mandatory, providing this information can enhance the accuracy of address-related operations.
 */
export type CompaniesAddType = ClosedEnum<typeof CompaniesAddType>;

export type Addresses = {
  /**
   * A unique identifier for each address entry linked to the company. This ID facilitates the management and retrieval of address records within the CRM. Although optional, it is beneficial for maintaining precise address tracking and updates, especially when dealing with multiple locations or changes over time.
   */
  id?: string | null | undefined;
  /**
   * Specifies the category or classification of the address, such as 'billing', 'shipping', or 'office'. This helps in distinguishing between different address purposes within the CRM system, ensuring that communications and shipments are directed appropriately. While not mandatory, providing this information can enhance the accuracy of address-related operations.
   */
  type?: CompaniesAddType | null | undefined;
  /**
   * Represents the full address in a single unstructured string format. This is particularly useful when dealing with APIs that do not support detailed address components. It should include all necessary address details such as street, city, state, and postal code, ensuring that the address is complete and usable for location-based services.
   */
  string?: string | null | undefined;
  /**
   * A descriptive label for the address, such as 'Headquarters' or 'Branch Office'. This name aids in quickly identifying the address's purpose or location within the company's structure, facilitating easier management and retrieval of address information in the CRM.
   */
  name?: string | null | undefined;
  /**
   * The primary line of the address, typically including the street number, street name, and any apartment or suite numbers. This field is crucial for ensuring accurate delivery and location identification, forming the core part of the address used in most postal systems.
   */
  line1?: string | null | undefined;
  /**
   * An additional line for the address, often used for supplementary information such as building names, floor numbers, or additional directions. While optional, this field can provide critical details that enhance the precision and completeness of the address.
   */
  line2?: string | null | undefined;
  /**
   * This field represents the third line of the address, typically used for additional address details such as suite numbers, building names, or other specific location identifiers. While not mandatory, providing this information can enhance the accuracy of the address, ensuring precise location identification within the CRM system. It is particularly useful for businesses located in complex or multi-unit buildings.
   */
  line3?: string | null | undefined;
  /**
   * The fourth line of the address, often used for further address details that do not fit into the standard address lines. This field can include information like mail stops or additional location instructions. Though optional, including this data can improve the delivery accuracy and logistical handling of correspondence or goods related to the company.
   */
  line4?: string | null | undefined;
  /**
   * The street number component of the address, indicating the specific location on a street where the company is situated. This is crucial for pinpointing the exact address in the CRM, aiding in accurate mapping and navigation. While not required, it is recommended to include this for complete address records.
   */
  streetNumber?: string | null | undefined;
  /**
   * The city name where the company is located. This field is essential for regional identification and is used in conjunction with other address fields to ensure the company is correctly placed within the CRM's geographical data. It supports operations like regional sales analysis and location-based services.
   */
  city?: string | null | undefined;
  /**
   * The state or province name where the company operates. This information is vital for legal and administrative purposes, ensuring compliance with regional regulations and facilitating state-specific business operations. It also aids in organizing companies within the CRM by their geographical location.
   */
  state?: string | null | undefined;
  /**
   * The postal code, also known as the ZIP code, is a series of letters, numbers, or both, assigned to a specific geographic area to facilitate the sorting and delivery of mail. In the context of adding a company to the CRM, this field helps in accurately identifying the location of the company's address, which is crucial for regional sales strategies, service delivery, and demographic analysis. While not mandatory, providing a postal code can enhance the precision of location-based services and analytics.
   */
  postalCode?: string | null | undefined;
  /**
   * The country code is a two-letter code defined by the ISO 3166-1 alpha-2 standard, representing the country where the company is located. This field is essential for international operations, enabling the CRM to categorize and manage companies based on their geographical location. It supports global business strategies by ensuring that the company data aligns with international standards. Although optional, including the country code can improve the accuracy of location-specific reporting and compliance with regional regulations.
   */
  country?: string | null | undefined;
  /**
   * The latitude is a geographic coordinate that specifies the north-south position of the company's address on the Earth's surface. It is expressed in decimal degrees and is used in conjunction with longitude to pinpoint the exact location of the company. In the CRM context, latitude is valuable for mapping services, location-based analytics, and optimizing logistics and field operations. While not required, providing latitude can enhance the CRM's ability to offer precise geolocation services.
   */
  latitude?: string | null | undefined;
  /**
   * The longitude is a geographic coordinate that specifies the east-west position of the company's address on the Earth's surface. Like latitude, it is expressed in decimal degrees and is used to accurately locate the company. This information is particularly useful for CRM features that involve mapping, route planning, and spatial analysis. Although optional, including longitude can significantly improve the CRM's geospatial capabilities and support efficient resource allocation and customer engagement strategies.
   */
  longitude?: string | null | undefined;
  /**
   * The county field captures the sublocality or administrative division within a country where the company is situated, such as a county or district. This information is beneficial for regional analysis, local marketing efforts, and compliance with local regulations. In the CRM, the county can help segment and target specific areas for business development and customer service initiatives. While not mandatory, providing the county can enhance the granularity of location-based data and support more tailored business strategies.
   */
  county?: string | null | undefined;
  /**
   * The full name of the primary contact person associated with this address. This information is crucial for personalizing communication and ensuring that correspondence reaches the correct individual. While not mandatory, providing a contact name can enhance the effectiveness of customer interactions and is often used in CRM systems to establish a point of contact within the company.
   */
  contactName?: string | null | undefined;
  /**
   * The formal salutation or title used for the contact person at this address, such as Mr., Ms., Dr., etc. This field helps in maintaining a professional tone in communications and is particularly useful in formal correspondence. Although optional, including a salutation can improve the personalization of emails and letters.
   */
  salutation?: string | null | undefined;
  /**
   * The primary phone number associated with this address, used for direct communication with the company or contact person. This number should be formatted according to international standards to ensure successful connectivity. While not required, having a phone number can facilitate immediate contact and is often used for customer support or sales inquiries.
   */
  phoneNumber?: string | null | undefined;
  /**
   * The fax number associated with this address, used for sending and receiving documents via fax. Although fax usage has declined, it remains relevant in certain industries for secure document transmission. This field is optional and should be formatted correctly to ensure successful transmission.
   */
  fax?: string | null | undefined;
  /**
   * The email address associated with this address, serving as a primary electronic communication channel. This should be a valid email format to ensure messages are delivered correctly. While optional, providing an email address is highly recommended as it facilitates efficient communication and is often used for sending invoices, updates, and other important information.
   */
  email?: string | null | undefined;
  /**
   * The website URL associated with the company's address. This field allows users to link the company's physical location with its online presence, facilitating easy access to the company's digital resources. Although not mandatory, providing a website can enhance the company's profile within the CRM, making it easier for users to access further information about the company. Ensure the URL is valid and follows standard web formatting (e.g., https://www.example.com).
   */
  website?: string | null | undefined;
  /**
   * This field is intended for any additional information or comments related to the company's address. It serves as a flexible space for users to include context-specific details that may not fit into other predefined fields. While optional, these notes can be valuable for internal reference, providing insights or reminders about the location that might be useful for future interactions or updates.
   */
  notes?: string | null | undefined;
  /**
   * A concurrency control mechanism represented as a binary string, used to manage and detect updates to the address object. This field helps prevent data conflicts by ensuring that updates are only applied to the latest version of the data. Each modification to the address increments this value, which must be included in update requests to verify that the data has not changed since it was last retrieved. This is crucial for maintaining data integrity in environments with multiple users or systems accessing the CRM simultaneously.
   */
  rowVersion?: string | null | undefined;
};

export type SocialLinks = {
  /**
   * A unique identifier for each social media link associated with the company. This ID is used to distinguish between different social media profiles within the CRM system, ensuring that each link is uniquely identifiable and can be referenced or updated independently. While optional, assigning an ID to each social link can facilitate easier management and integration of social media data within the CRM.
   */
  id?: string | null | undefined;
  /**
   * The full URL of the company's social media profile, such as https://www.twitter.com/apideck. This link is essential for integrating social media presence into the CRM, allowing users to quickly access and manage the company's social interactions. It must be a valid URL format and is required to ensure comprehensive social media tracking.
   */
  url: string;
  /**
   * Specifies the type of social media platform associated with the URL, such as 'twitter' or 'linkedin'. This helps categorize and organize social links within the CRM, facilitating targeted social media strategies. While not mandatory, providing this information enhances the clarity and utility of social media data.
   */
  type?: string | null | undefined;
};

/**
 * The classification of the phone number, indicating its purpose or usage, such as 'work', 'mobile', or 'fax'. This helps in organizing contact information within the CRM by providing context about how the number is used. Although not required, specifying the type can enhance clarity and improve the efficiency of communication strategies.
 */
export const CompaniesAddCompaniesType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Work: "work",
  Office: "office",
  Mobile: "mobile",
  Assistant: "assistant",
  Fax: "fax",
  DirectDialIn: "direct-dial-in",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * The classification of the phone number, indicating its purpose or usage, such as 'work', 'mobile', or 'fax'. This helps in organizing contact information within the CRM by providing context about how the number is used. Although not required, specifying the type can enhance clarity and improve the efficiency of communication strategies.
 */
export type CompaniesAddCompaniesType = ClosedEnum<
  typeof CompaniesAddCompaniesType
>;

export type PhoneNumbers = {
  /**
   * A unique identifier for each phone number entry within the company's contact list. This ID is crucial for distinguishing between different phone numbers, especially when managing updates or deletions. It should be unique across the company's phone number records.
   */
  id?: string | null | undefined;
  /**
   * The international dialing code associated with the phone number, such as '+1' for the United States. This code is important for ensuring that phone numbers are formatted correctly for international dialing, facilitating global communication. It should be a valid country code as per international standards.
   */
  countryCode?: string | null | undefined;
  /**
   * The area code of the phone number, such as 323, which is used to identify the specific geographic region associated with the phone number. This is particularly useful for distinguishing between numbers in different locations, especially in countries like the United States where area codes are widely used. While not mandatory, providing an area code can help ensure accurate routing of calls and is beneficial for companies operating in multiple regions.
   */
  areaCode?: string | null | undefined;
  /**
   * The main phone number associated with the company, excluding any area code or extension. This is a required field as it serves as a primary contact method for the company within the CRM system. It is essential for communication purposes and should be formatted according to international standards to ensure compatibility across different telecommunication systems.
   */
  number: string;
  /**
   * The extension number for the phone line, which directs calls to a specific department or individual within the company. This is optional but can be crucial for larger organizations where direct lines to departments or personnel are necessary. Including an extension helps streamline communication and ensures calls reach the intended recipient without unnecessary transfers.
   */
  extension?: string | null | undefined;
  /**
   * The classification of the phone number, indicating its purpose or usage, such as 'work', 'mobile', or 'fax'. This helps in organizing contact information within the CRM by providing context about how the number is used. Although not required, specifying the type can enhance clarity and improve the efficiency of communication strategies.
   */
  type?: CompaniesAddCompaniesType | null | undefined;
};

/**
 * Specifies the type of email address, such as 'work', 'personal', or 'support'. This categorization helps in organizing and prioritizing communications based on the context and purpose of the email. While optional, defining the email type can enhance clarity in communication strategies.
 */
export const CompaniesAddCompaniesRequestType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the type of email address, such as 'work', 'personal', or 'support'. This categorization helps in organizing and prioritizing communications based on the context and purpose of the email. While optional, defining the email type can enhance clarity in communication strategies.
 */
export type CompaniesAddCompaniesRequestType = ClosedEnum<
  typeof CompaniesAddCompaniesRequestType
>;

export type Emails = {
  /**
   * A unique identifier assigned to each email address associated with the company. This ID is used internally to distinguish between multiple email entries and is crucial for operations that require precise email management, such as updates or deletions. Although not required, providing this ID can help maintain consistency and integrity within the CRM system.
   */
  id?: string | null | undefined;
  /**
   * The primary email address for the company, essential for communication and contact purposes. This field is mandatory and must be a valid email format to ensure successful delivery of correspondence. It serves as a key point of contact for business inquiries and CRM notifications.
   */
  email: string | null;
  /**
   * Specifies the type of email address, such as 'work', 'personal', or 'support'. This categorization helps in organizing and prioritizing communications based on the context and purpose of the email. While optional, defining the email type can enhance clarity in communication strategies.
   */
  type?: CompaniesAddCompaniesRequestType | null | undefined;
};

/**
 * An object representing the type of row or entry being added to the CRM. This can include various metadata or classification details that help in categorizing the company within the CRM system. Although optional, providing this information can assist in more advanced data management and retrieval operations.
 */
export type CompanyRowType = {
  /**
   * A unique identifier for the row type, used to specify and manage different categories or classifications of company entries within the CRM. This ID aids in the organization and retrieval of company data, especially in systems with complex data structures. While not mandatory, it can be beneficial for detailed data analysis and reporting.
   */
  id?: string | null | undefined;
  /**
   * The name of the company to be added to the CRM. This field, while not mandatory, is highly recommended as it serves as a primary identifier for the company within the CRM system. It should reflect the official business name to ensure consistency and accuracy across records. This helps in easy retrieval and management of company data.
   */
  name?: string | null | undefined;
};

export type Six = {};

export type Four = {};

/**
 * This field allows for the inclusion of custom data specific to the company being added. It is not required but can be used to store additional information that does not fit into the standard fields. This flexibility is useful for businesses that need to track unique attributes or metrics related to their operations. The value should be formatted as a string and can include any relevant data that enhances the company's profile within the CRM.
 */
export type Value =
  | Four
  | string
  | number
  | boolean
  | Array<string>
  | Array<Six>;

export type CustomFields = {
  /**
   * A unique identifier for each custom field associated with the company. This ID is crucial for distinguishing between different custom fields and ensuring that data is accurately mapped and retrieved. It must be unique within the context of the company's custom fields to prevent data conflicts and ensure integrity.
   */
  id: string | null;
  /**
   * The name assigned to the custom field, providing a human-readable label that describes the type of data stored. While not required, it is beneficial for clarity and ease of understanding, especially when multiple custom fields are used. This name should be descriptive enough to convey the purpose of the field to users.
   */
  name?: string | null | undefined;
  /**
   * A detailed explanation of the custom field's purpose and the type of information it is intended to capture. This description aids users in understanding the context and relevance of the field, ensuring that data entered is appropriate and useful. It is particularly helpful in complex systems where numerous custom fields may exist.
   */
  description?: string | null | undefined;
  /**
   * This field allows for the inclusion of custom data specific to the company being added. It is not required but can be used to store additional information that does not fit into the standard fields. This flexibility is useful for businesses that need to track unique attributes or metrics related to their operations. The value should be formatted as a string and can include any relevant data that enhances the company's profile within the CRM.
   */
  value?:
    | Four
    | string
    | number
    | boolean
    | Array<string>
    | Array<Six>
    | null
    | undefined;
};

export type ExtendPaths = {
  /**
   * A mandatory JSONPath string that specifies the exact location within the data structure where the new value should be applied. This path is crucial for ensuring that data modifications are accurately targeted, preventing errors and maintaining data integrity. Users must ensure that the path is correctly defined to reflect the intended data hierarchy and structure, facilitating precise updates and extensions.
   */
  path: string;
  /**
   * The value to be set at the specified JSONPath, which can be of any data type. This property is required and serves as the new data to be inserted or updated at the targeted path. It is important for users to ensure that the value is compatible with the existing data structure and meets any business logic or validation rules applicable to the operation. This flexibility allows for a wide range of data modifications, supporting diverse business needs and scenarios.
   */
  value?: any | undefined;
};

export type PassThrough = {
  /**
   * A mandatory identifier specifying the target service for which the pass_through data is intended. This field ensures that the custom data is correctly routed and applied to the appropriate service integration, such as Pipedrive or Salesforce. It is crucial for operations involving multiple service integrations to avoid data misrouting.
   */
  serviceId: string;
  /**
   * An optional string identifier for a specific workflow operation that this pass-through should be associated with. This is particularly useful in scenarios where Unify calls are involved in executing multiple downstream requests, allowing for precise tracking and management of each operation within the CRM system. By specifying an operation ID, users can ensure that the pass-through data is correctly applied to the intended workflow, enhancing the accuracy and efficiency of multi-step processes.
   */
  operationId?: string | undefined;
  /**
   * An object designed to allow direct extension with any properties, providing flexibility in adding custom data fields to the company record. This feature is valuable for users needing to include additional information that is not covered by standard fields, enabling a more tailored data structure that can accommodate unique business requirements. The extend_object can be used to capture specific attributes or metadata that are critical for certain business operations or integrations.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects that facilitates structured data modifications through specified paths. This property is essential for users who need to perform precise updates or extensions to the company data by targeting specific JSON paths. It allows for dynamic adjustments and enhancements of the data structure, supporting complex data manipulation needs within the CRM. This is particularly useful in integrations where data from multiple sources needs to be harmonized or enriched.
   */
  extendPaths?: Array<ExtendPaths> | undefined;
};

export type CompaniesAddRequestBody = {
  /**
   * The official registered business name for the new company record. This name serves as the primary identifier within the CRM and should match the company's legal documentation. It is crucial for maintaining consistent and accurate company records across the system, facilitating easy search and retrieval of company information.
   */
  name: string | null;
  /**
   * The unique identifier of the user or employee who owns or manages the company account within the CRM. This ID links the company to its responsible party, facilitating accountability and management. While optional, providing an owner ID can help in organizing and assigning responsibilities within the CRM system.
   */
  ownerId?: string | null | undefined;
  /**
   * The URL of an image representing the company, such as a logo or profile picture. This visual identifier can enhance the company's profile within the CRM, making it easily recognizable. While not mandatory, including an image URL can improve user experience by providing a visual context to the company data.
   */
  image?: string | null | undefined;
  /**
   * A detailed narrative about the company, providing insights into its operations, mission, and market presence. This field, while optional, enriches the company profile within the CRM, aiding in better understanding and engagement by sales and support teams. It can include historical background, key achievements, or strategic goals, offering a comprehensive view of the company's identity.
   */
  description?: string | null | undefined;
  /**
   * The official VAT (Value Added Tax) number assigned to the company, crucial for tax reporting and compliance purposes. This identifier is used in financial transactions and invoicing within the CRM, ensuring that all fiscal activities are accurately tracked and reported. It should be formatted according to the company's country-specific VAT regulations.
   */
  vatNumber?: string | null | undefined;
  /**
   * Specifies the currency in which the company's financial transactions are conducted, adhering to the ISO 4217 standard. This field is essential for financial consistency and accuracy in reporting, billing, and accounting processes within the CRM. It ensures that all monetary values are correctly interpreted and managed across different regions and markets.
   */
  currency?: Currency | null | undefined;
  /**
   * Represents the current operational state of the company, such as active, inactive, or pending. This status helps in categorizing and managing company records within the CRM, influencing how interactions and transactions are prioritized and handled. It is vital for workflow automation and reporting, providing clarity on the company's engagement level.
   */
  status?: string | null | undefined;
  /**
   * The company's fax number, serving as an alternative communication channel for sending and receiving documents. Although less commonly used today, it remains relevant for certain industries and regions where fax communication is still prevalent. Including this information ensures comprehensive contact details are available within the CRM.
   */
  fax?: string | null | undefined;
  /**
   * The annual revenue of the company, representing the total income generated by the company in a fiscal year before any expenses are deducted. This information is crucial for assessing the company's financial health and growth potential within the CRM system. It helps in categorizing companies based on their financial size and can influence business strategies and decisions. Typically, this should be a numeric value formatted as a string, and while not mandatory, providing this data can enhance the richness of the company's profile.
   */
  annualRevenue?: string | null | undefined;
  /**
   * Number of employees working at the company, which provides insight into the company's scale and operational capacity. This metric is often used to segment companies into different sizes (e.g., small, medium, large) within the CRM, aiding in targeted marketing and sales strategies. Although not required, including this information can improve the accuracy of company analytics and reporting. The value should be a numeric string.
   */
  numberOfEmployees?: string | null | undefined;
  /**
   * The industry represents the type of business the company is in, such as technology, healthcare, or finance. This classification is essential for understanding the market context in which the company operates and can be used to tailor CRM functionalities like marketing campaigns and sales approaches. It helps in benchmarking against industry standards and trends. While optional, specifying the industry can significantly enhance the CRM's ability to provide industry-specific insights and analytics.
   */
  industry?: string | null | undefined;
  /**
   * The ownership indicates the type of ownership of the company, such as private, public, or government-owned. This attribute helps in understanding the company's governance structure and can influence business interactions and compliance requirements. Knowing the ownership type can be crucial for risk assessment and strategic planning within the CRM. Although not mandatory, it provides valuable context for the company's operational and financial dynamics.
   */
  ownership?: string | null | undefined;
  /**
   * A sales tax number is a unique identifier assigned to a company for tax purposes, used to track tax obligations and compliance. This number is critical for companies engaged in sales activities, ensuring they meet regional tax regulations. In the CRM context, having the sales tax number helps in maintaining accurate financial records and can facilitate smoother transactions and audits. While not required, it is highly recommended for companies involved in taxable sales activities.
   */
  salesTaxNumber?: string | null | undefined;
  /**
   * The payee number serves as a unique identifier for a payee, primarily used for tax-related purposes. In the context of adding a company to the CRM, this number helps ensure that the company is correctly identified for financial transactions and compliance. While not mandatory, providing this number can facilitate smoother integration with financial systems and tax authorities. It should be a valid number as per the issuing authority's standards.
   */
  payeeNumber?: string | null | undefined;
  /**
   * This field requires either an Australian Business Number (ABN) or a Tax File Number (TFN), depending on the entity type. An ABN is essential for businesses operating in Australia, enabling them to register for GST and other business-related activities. A TFN is necessary for individuals or entities engaging in taxable activities. Including this information ensures compliance with Australian tax regulations and aids in the accurate processing of financial data within the CRM. It must be a valid number issued by the Australian Taxation Office.
   */
  abnOrTfn?: string | null | undefined;
  /**
   * The ABN Branch, also known as a GST Branch, is used when a segment of the business needs to report GST separately from the main entity. This is particularly useful for larger companies with distinct operational divisions. In the CRM context, specifying an ABN Branch allows for precise financial tracking and reporting for different parts of the business. This field should be filled with the correct branch number if applicable, ensuring accurate tax reporting and compliance.
   */
  abnBranch?: string | null | undefined;
  /**
   * The Australian Company Number (ACN) is a unique nine-digit identifier for companies registered in Australia. It is crucial for legal and administrative purposes, ensuring that the company is recognized by the Australian Securities and Investments Commission (ASIC). In the CRM, the ACN helps maintain accurate company records and facilitates legal compliance. The number should be formatted as three groups of three digits (e.g., XXX XXX XXX) and must be valid as per ASIC's standards.
   */
  acn?: string | null | undefined;
  /**
   * The first name of the primary contact person associated with the company. This information is used to personalize communications and establish a point of contact within the CRM. While not mandatory, providing a first name can enhance customer relationship management by allowing for more personalized interactions and follow-ups. It should be a valid name, typically consisting of alphabetic characters, and reflect the individual's legal or preferred name.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the individual associated with the company record. This field is optional and typically used when the company is a sole proprietorship or when a specific contact person is being added to the CRM. It helps in personalizing communication and ensuring accurate record-keeping, especially in businesses where personal relationships are key.
   */
  lastName?: string | null | undefined;
  /**
   * A collection of bank account details associated with the company. This optional array can include multiple bank accounts, each represented as an object with specific properties. It is useful for companies that manage multiple accounts for different financial operations, such as payroll, expenses, and revenue collection.
   */
  bankAccounts?: Array<BankAccounts> | undefined;
  /**
   * The websites property is an array that lists the URLs associated with the company, such as its official website, social media pages, or other relevant online presences. In the CRM context, these URLs provide valuable insights into the company's digital footprint and can be used for marketing, customer engagement, and verification purposes. Although not required, including website information can enhance the company's profile within the CRM, offering a more comprehensive view of its online activities and presence. Users should ensure that the URLs are accurate and up-to-date to maximize their utility.
   */
  websites?: Array<Websites> | undefined;
  /**
   * A collection of address objects associated with the company. Each address provides location details that are vital for logistical purposes, client visits, and regional operations. While not mandatory, including addresses can improve the CRM's utility in managing geographical data and planning business activities.
   */
  addresses?: Array<Addresses> | undefined;
  /**
   * An array containing the social media links associated with the company. This collection allows users to connect various social media profiles to the company's CRM record, providing a comprehensive view of the company's online presence. While not required, including social links can enhance the company's profile by offering additional channels for engagement and communication. Each entry in the array should be a structured object containing details of the social media account.
   */
  socialLinks?: Array<SocialLinks> | undefined;
  /**
   * A collection of phone numbers associated with the company. This array can include multiple entries, each representing a distinct contact number for various departments or purposes within the company. While not required, including phone numbers enhances direct communication capabilities.
   */
  phoneNumbers?: Array<PhoneNumbers> | undefined;
  /**
   * A list of email addresses associated with the company, which can include general contact emails, department-specific addresses, or individual employee emails. This array allows for multiple entries, supporting comprehensive communication channels within the CRM. While not mandatory, providing email addresses is highly recommended for facilitating electronic correspondence and ensuring that the company can be reached through various digital means.
   */
  emails?: Array<Emails> | undefined;
  /**
   * An object representing the type of row or entry being added to the CRM. This can include various metadata or classification details that help in categorizing the company within the CRM system. Although optional, providing this information can assist in more advanced data management and retrieval operations.
   */
  rowType?: CompanyRowType | undefined;
  /**
   * An array of custom fields that allow for additional, user-defined data to be associated with the company record. These fields enable flexibility in capturing specific information that may not be covered by standard fields, catering to unique business needs or industry-specific requirements. Each entry in the array should conform to the defined structure for custom fields.
   */
  customFields?: Array<CustomFields> | undefined;
  /**
   * An array of tags associated with the company. Tags are used to categorize and organize companies within the CRM, making it easier to filter and search for specific groups of companies. This field is optional but highly beneficial for businesses that manage a large number of companies and need a system to quickly identify and access specific records based on shared characteristics or business needs.
   */
  tags?: Array<string> | null | undefined;
  /**
   * Indicates whether the company record is read-only. If set to true, the company details cannot be modified after creation, which is useful for preserving historical data or when the company information is managed by an external system. This field is optional and defaults to false, allowing for edits unless explicitly restricted.
   */
  readOnly?: boolean | null | undefined;
  /**
   * A formal salutation for the primary contact person associated with the company, such as 'Mr', 'Mrs', 'Dr', etc. This field helps in personalizing communication and maintaining a professional tone in correspondence. It is particularly useful in customer-facing applications where addressing contacts correctly is crucial. While not mandatory, providing a salutation can enhance the quality of interactions with the company's representatives.
   */
  salutation?: string | null | undefined;
  /**
   * The date of birth of the primary contact person associated with the company, formatted as YYYY-MM-DD. This information can be used for personalizing interactions, such as sending birthday greetings or tailoring marketing campaigns. It is optional but can add value in building stronger relationships with key contacts. Ensure the date is accurate and complies with any applicable data protection regulations.
   */
  birthday?: RFCDate | null | undefined;
  /**
   * An array that allows the inclusion of service-specific custom data or structured modifications when creating or updating company records. This property is optional and is particularly useful for integrating with external services that require additional parameters not covered by standard fields. Each entry in the array should conform to the expected structure of the target service.
   */
  passThrough?: Array<PassThrough> | undefined;
};

export type CompaniesAddRequest = {
  /**
   * The 'raw' query parameter allows the API consumer to request the response in its raw format. This is particularly useful for debugging purposes, as it provides the unprocessed data returned by the server. By default, this parameter is set to 'false', meaning the response will be processed and formatted according to standard API conventions. Setting this parameter to 'true' can help developers troubleshoot issues by examining the exact data structure and content returned by the API.
   */
  raw?: boolean | undefined;
  /**
   * The 'x-apideck-consumer-id' header is a mandatory field that uniquely identifies the consumer making the API request. This ID is crucial for authentication and authorization processes, ensuring that the request is associated with the correct consumer account. It must be a valid string that corresponds to an existing consumer in the system. This parameter is hidden from global settings to maintain security and integrity of consumer data.
   */
  consumerId: string;
  /**
   * The 'x-apideck-app-id' header is required to identify the specific Unify application making the request. This ID is essential for routing the request to the appropriate application context within the API infrastructure. It should be a valid string that matches the application's unique identifier, ensuring that the operations are executed within the correct application environment. This parameter is also hidden from global settings to protect application-specific data.
   */
  appId: string;
  /**
   * The 'x-apideck-service-id' header is an optional parameter used when a consumer has multiple integrations active within the Unified API. It specifies the target service for the API request, such as 'pipedrive' or 'salesforce'. This parameter is necessary only when directing the request to a specific service among several active integrations, ensuring that the data is processed by the intended service. It should be a valid string representing the service ID.
   */
  serviceId?: string | undefined;
  requestBody: CompaniesAddRequestBody;
};

/**
 * Contains parameter or domain specific information related to the error and why it occurred.
 */
export type Detail = string | { [k: string]: any };

/**
 * Unexpected error
 */
export type CompaniesAddCompaniesResponseBody = {
  /**
   * HTTP status code
   */
  statusCode?: number | undefined;
  /**
   * Contains an explanation of the status_code as defined in HTTP/1.1 standard (RFC 7231)
   */
  error?: string | undefined;
  /**
   * The type of error returned
   */
  typeName?: string | undefined;
  /**
   * A human-readable message providing more details about the error.
   */
  message?: string | undefined;
  /**
   * Contains parameter or domain specific information related to the error and why it occurred.
   */
  detail?: string | { [k: string]: any } | undefined;
  /**
   * Link to documentation of error type
   */
  ref?: string | undefined;
};

export type UnifiedId = {
  /**
   * The unique identifier of the resource
   */
  id: string;
};

/**
 * Company created
 */
export type CompaniesAddResponseBody = {
  /**
   * HTTP Response Status Code
   */
  statusCode: number;
  /**
   * HTTP Response Status
   */
  status: string;
  /**
   * Apideck ID of service provider
   */
  service: string;
  /**
   * Unified API resource name
   */
  resource: string;
  /**
   * Operation performed
   */
  operation: string;
  data: UnifiedId;
};

export type CompaniesAddResponse =
  | CompaniesAddResponseBody
  | CompaniesAddCompaniesResponseBody;

/** @internal */
export const CompaniesAddSecurity$inboundSchema: z.ZodType<
  CompaniesAddSecurity,
  z.ZodTypeDef,
  unknown
> = z.object({
  apiKey: z.string(),
});

/** @internal */
export type CompaniesAddSecurity$Outbound = {
  apiKey: string;
};

/** @internal */
export const CompaniesAddSecurity$outboundSchema: z.ZodType<
  CompaniesAddSecurity$Outbound,
  z.ZodTypeDef,
  CompaniesAddSecurity
> = z.object({
  apiKey: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompaniesAddSecurity$ {
  /** @deprecated use `CompaniesAddSecurity$inboundSchema` instead. */
  export const inboundSchema = CompaniesAddSecurity$inboundSchema;
  /** @deprecated use `CompaniesAddSecurity$outboundSchema` instead. */
  export const outboundSchema = CompaniesAddSecurity$outboundSchema;
  /** @deprecated use `CompaniesAddSecurity$Outbound` instead. */
  export type Outbound = CompaniesAddSecurity$Outbound;
}

export function companiesAddSecurityToJSON(
  companiesAddSecurity: CompaniesAddSecurity,
): string {
  return JSON.stringify(
    CompaniesAddSecurity$outboundSchema.parse(companiesAddSecurity),
  );
}

export function companiesAddSecurityFromJSON(
  jsonString: string,
): SafeParseResult<CompaniesAddSecurity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompaniesAddSecurity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompaniesAddSecurity' from JSON`,
  );
}

/** @internal */
export const Currency$inboundSchema: z.ZodNativeEnum<typeof Currency> = z
  .nativeEnum(Currency);

/** @internal */
export const Currency$outboundSchema: z.ZodNativeEnum<typeof Currency> =
  Currency$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Currency$ {
  /** @deprecated use `Currency$inboundSchema` instead. */
  export const inboundSchema = Currency$inboundSchema;
  /** @deprecated use `Currency$outboundSchema` instead. */
  export const outboundSchema = Currency$outboundSchema;
}

/** @internal */
export const AccountType$inboundSchema: z.ZodNativeEnum<typeof AccountType> = z
  .nativeEnum(AccountType);

/** @internal */
export const AccountType$outboundSchema: z.ZodNativeEnum<typeof AccountType> =
  AccountType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AccountType$ {
  /** @deprecated use `AccountType$inboundSchema` instead. */
  export const inboundSchema = AccountType$inboundSchema;
  /** @deprecated use `AccountType$outboundSchema` instead. */
  export const outboundSchema = AccountType$outboundSchema;
}

/** @internal */
export const CompaniesAddCurrency$inboundSchema: z.ZodNativeEnum<
  typeof CompaniesAddCurrency
> = z.nativeEnum(CompaniesAddCurrency);

/** @internal */
export const CompaniesAddCurrency$outboundSchema: z.ZodNativeEnum<
  typeof CompaniesAddCurrency
> = CompaniesAddCurrency$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompaniesAddCurrency$ {
  /** @deprecated use `CompaniesAddCurrency$inboundSchema` instead. */
  export const inboundSchema = CompaniesAddCurrency$inboundSchema;
  /** @deprecated use `CompaniesAddCurrency$outboundSchema` instead. */
  export const outboundSchema = CompaniesAddCurrency$outboundSchema;
}

/** @internal */
export const BankAccounts$inboundSchema: z.ZodType<
  BankAccounts,
  z.ZodTypeDef,
  unknown
> = z.object({
  bank_name: z.nullable(z.string()).optional(),
  account_number: z.nullable(z.string()).optional(),
  account_name: z.nullable(z.string()).optional(),
  account_type: z.nullable(AccountType$inboundSchema).optional(),
  iban: z.nullable(z.string()).optional(),
  bic: z.nullable(z.string()).optional(),
  routing_number: z.nullable(z.string()).optional(),
  bsb_number: z.nullable(z.string()).optional(),
  branch_identifier: z.nullable(z.string()).optional(),
  bank_code: z.nullable(z.string()).optional(),
  currency: z.nullable(CompaniesAddCurrency$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "bank_name": "bankName",
    "account_number": "accountNumber",
    "account_name": "accountName",
    "account_type": "accountType",
    "routing_number": "routingNumber",
    "bsb_number": "bsbNumber",
    "branch_identifier": "branchIdentifier",
    "bank_code": "bankCode",
  });
});

/** @internal */
export type BankAccounts$Outbound = {
  bank_name?: string | null | undefined;
  account_number?: string | null | undefined;
  account_name?: string | null | undefined;
  account_type?: string | null | undefined;
  iban?: string | null | undefined;
  bic?: string | null | undefined;
  routing_number?: string | null | undefined;
  bsb_number?: string | null | undefined;
  branch_identifier?: string | null | undefined;
  bank_code?: string | null | undefined;
  currency?: string | null | undefined;
};

/** @internal */
export const BankAccounts$outboundSchema: z.ZodType<
  BankAccounts$Outbound,
  z.ZodTypeDef,
  BankAccounts
> = z.object({
  bankName: z.nullable(z.string()).optional(),
  accountNumber: z.nullable(z.string()).optional(),
  accountName: z.nullable(z.string()).optional(),
  accountType: z.nullable(AccountType$outboundSchema).optional(),
  iban: z.nullable(z.string()).optional(),
  bic: z.nullable(z.string()).optional(),
  routingNumber: z.nullable(z.string()).optional(),
  bsbNumber: z.nullable(z.string()).optional(),
  branchIdentifier: z.nullable(z.string()).optional(),
  bankCode: z.nullable(z.string()).optional(),
  currency: z.nullable(CompaniesAddCurrency$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    bankName: "bank_name",
    accountNumber: "account_number",
    accountName: "account_name",
    accountType: "account_type",
    routingNumber: "routing_number",
    bsbNumber: "bsb_number",
    branchIdentifier: "branch_identifier",
    bankCode: "bank_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BankAccounts$ {
  /** @deprecated use `BankAccounts$inboundSchema` instead. */
  export const inboundSchema = BankAccounts$inboundSchema;
  /** @deprecated use `BankAccounts$outboundSchema` instead. */
  export const outboundSchema = BankAccounts$outboundSchema;
  /** @deprecated use `BankAccounts$Outbound` instead. */
  export type Outbound = BankAccounts$Outbound;
}

export function bankAccountsToJSON(bankAccounts: BankAccounts): string {
  return JSON.stringify(BankAccounts$outboundSchema.parse(bankAccounts));
}

export function bankAccountsFromJSON(
  jsonString: string,
): SafeParseResult<BankAccounts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BankAccounts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BankAccounts' from JSON`,
  );
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);

/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Type$ {
  /** @deprecated use `Type$inboundSchema` instead. */
  export const inboundSchema = Type$inboundSchema;
  /** @deprecated use `Type$outboundSchema` instead. */
  export const outboundSchema = Type$outboundSchema;
}

/** @internal */
export const Websites$inboundSchema: z.ZodType<
  Websites,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(Type$inboundSchema).optional(),
});

/** @internal */
export type Websites$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const Websites$outboundSchema: z.ZodType<
  Websites$Outbound,
  z.ZodTypeDef,
  Websites
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(Type$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Websites$ {
  /** @deprecated use `Websites$inboundSchema` instead. */
  export const inboundSchema = Websites$inboundSchema;
  /** @deprecated use `Websites$outboundSchema` instead. */
  export const outboundSchema = Websites$outboundSchema;
  /** @deprecated use `Websites$Outbound` instead. */
  export type Outbound = Websites$Outbound;
}

export function websitesToJSON(websites: Websites): string {
  return JSON.stringify(Websites$outboundSchema.parse(websites));
}

export function websitesFromJSON(
  jsonString: string,
): SafeParseResult<Websites, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Websites$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Websites' from JSON`,
  );
}

/** @internal */
export const CompaniesAddType$inboundSchema: z.ZodNativeEnum<
  typeof CompaniesAddType
> = z.nativeEnum(CompaniesAddType);

/** @internal */
export const CompaniesAddType$outboundSchema: z.ZodNativeEnum<
  typeof CompaniesAddType
> = CompaniesAddType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompaniesAddType$ {
  /** @deprecated use `CompaniesAddType$inboundSchema` instead. */
  export const inboundSchema = CompaniesAddType$inboundSchema;
  /** @deprecated use `CompaniesAddType$outboundSchema` instead. */
  export const outboundSchema = CompaniesAddType$outboundSchema;
}

/** @internal */
export const Addresses$inboundSchema: z.ZodType<
  Addresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CompaniesAddType$inboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  street_number: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postal_code: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contact_name: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phone_number: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  row_version: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "street_number": "streetNumber",
    "postal_code": "postalCode",
    "contact_name": "contactName",
    "phone_number": "phoneNumber",
    "row_version": "rowVersion",
  });
});

/** @internal */
export type Addresses$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
  string?: string | null | undefined;
  name?: string | null | undefined;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  line3?: string | null | undefined;
  line4?: string | null | undefined;
  street_number?: string | null | undefined;
  city?: string | null | undefined;
  state?: string | null | undefined;
  postal_code?: string | null | undefined;
  country?: string | null | undefined;
  latitude?: string | null | undefined;
  longitude?: string | null | undefined;
  county?: string | null | undefined;
  contact_name?: string | null | undefined;
  salutation?: string | null | undefined;
  phone_number?: string | null | undefined;
  fax?: string | null | undefined;
  email?: string | null | undefined;
  website?: string | null | undefined;
  notes?: string | null | undefined;
  row_version?: string | null | undefined;
};

/** @internal */
export const Addresses$outboundSchema: z.ZodType<
  Addresses$Outbound,
  z.ZodTypeDef,
  Addresses
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CompaniesAddType$outboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  streetNumber: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contactName: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phoneNumber: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  rowVersion: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    streetNumber: "street_number",
    postalCode: "postal_code",
    contactName: "contact_name",
    phoneNumber: "phone_number",
    rowVersion: "row_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Addresses$ {
  /** @deprecated use `Addresses$inboundSchema` instead. */
  export const inboundSchema = Addresses$inboundSchema;
  /** @deprecated use `Addresses$outboundSchema` instead. */
  export const outboundSchema = Addresses$outboundSchema;
  /** @deprecated use `Addresses$Outbound` instead. */
  export type Outbound = Addresses$Outbound;
}

export function addressesToJSON(addresses: Addresses): string {
  return JSON.stringify(Addresses$outboundSchema.parse(addresses));
}

export function addressesFromJSON(
  jsonString: string,
): SafeParseResult<Addresses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Addresses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Addresses' from JSON`,
  );
}

/** @internal */
export const SocialLinks$inboundSchema: z.ZodType<
  SocialLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/** @internal */
export type SocialLinks$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const SocialLinks$outboundSchema: z.ZodType<
  SocialLinks$Outbound,
  z.ZodTypeDef,
  SocialLinks
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SocialLinks$ {
  /** @deprecated use `SocialLinks$inboundSchema` instead. */
  export const inboundSchema = SocialLinks$inboundSchema;
  /** @deprecated use `SocialLinks$outboundSchema` instead. */
  export const outboundSchema = SocialLinks$outboundSchema;
  /** @deprecated use `SocialLinks$Outbound` instead. */
  export type Outbound = SocialLinks$Outbound;
}

export function socialLinksToJSON(socialLinks: SocialLinks): string {
  return JSON.stringify(SocialLinks$outboundSchema.parse(socialLinks));
}

export function socialLinksFromJSON(
  jsonString: string,
): SafeParseResult<SocialLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SocialLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SocialLinks' from JSON`,
  );
}

/** @internal */
export const CompaniesAddCompaniesType$inboundSchema: z.ZodNativeEnum<
  typeof CompaniesAddCompaniesType
> = z.nativeEnum(CompaniesAddCompaniesType);

/** @internal */
export const CompaniesAddCompaniesType$outboundSchema: z.ZodNativeEnum<
  typeof CompaniesAddCompaniesType
> = CompaniesAddCompaniesType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompaniesAddCompaniesType$ {
  /** @deprecated use `CompaniesAddCompaniesType$inboundSchema` instead. */
  export const inboundSchema = CompaniesAddCompaniesType$inboundSchema;
  /** @deprecated use `CompaniesAddCompaniesType$outboundSchema` instead. */
  export const outboundSchema = CompaniesAddCompaniesType$outboundSchema;
}

/** @internal */
export const PhoneNumbers$inboundSchema: z.ZodType<
  PhoneNumbers,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  country_code: z.nullable(z.string()).optional(),
  area_code: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(CompaniesAddCompaniesType$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "country_code": "countryCode",
    "area_code": "areaCode",
  });
});

/** @internal */
export type PhoneNumbers$Outbound = {
  id?: string | null | undefined;
  country_code?: string | null | undefined;
  area_code?: string | null | undefined;
  number: string;
  extension?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const PhoneNumbers$outboundSchema: z.ZodType<
  PhoneNumbers$Outbound,
  z.ZodTypeDef,
  PhoneNumbers
> = z.object({
  id: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  areaCode: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(CompaniesAddCompaniesType$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    countryCode: "country_code",
    areaCode: "area_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PhoneNumbers$ {
  /** @deprecated use `PhoneNumbers$inboundSchema` instead. */
  export const inboundSchema = PhoneNumbers$inboundSchema;
  /** @deprecated use `PhoneNumbers$outboundSchema` instead. */
  export const outboundSchema = PhoneNumbers$outboundSchema;
  /** @deprecated use `PhoneNumbers$Outbound` instead. */
  export type Outbound = PhoneNumbers$Outbound;
}

export function phoneNumbersToJSON(phoneNumbers: PhoneNumbers): string {
  return JSON.stringify(PhoneNumbers$outboundSchema.parse(phoneNumbers));
}

export function phoneNumbersFromJSON(
  jsonString: string,
): SafeParseResult<PhoneNumbers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PhoneNumbers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PhoneNumbers' from JSON`,
  );
}

/** @internal */
export const CompaniesAddCompaniesRequestType$inboundSchema: z.ZodNativeEnum<
  typeof CompaniesAddCompaniesRequestType
> = z.nativeEnum(CompaniesAddCompaniesRequestType);

/** @internal */
export const CompaniesAddCompaniesRequestType$outboundSchema: z.ZodNativeEnum<
  typeof CompaniesAddCompaniesRequestType
> = CompaniesAddCompaniesRequestType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompaniesAddCompaniesRequestType$ {
  /** @deprecated use `CompaniesAddCompaniesRequestType$inboundSchema` instead. */
  export const inboundSchema = CompaniesAddCompaniesRequestType$inboundSchema;
  /** @deprecated use `CompaniesAddCompaniesRequestType$outboundSchema` instead. */
  export const outboundSchema = CompaniesAddCompaniesRequestType$outboundSchema;
}

/** @internal */
export const Emails$inboundSchema: z.ZodType<Emails, z.ZodTypeDef, unknown> = z
  .object({
    id: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()),
    type: z.nullable(CompaniesAddCompaniesRequestType$inboundSchema).optional(),
  });

/** @internal */
export type Emails$Outbound = {
  id?: string | null | undefined;
  email: string | null;
  type?: string | null | undefined;
};

/** @internal */
export const Emails$outboundSchema: z.ZodType<
  Emails$Outbound,
  z.ZodTypeDef,
  Emails
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(CompaniesAddCompaniesRequestType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Emails$ {
  /** @deprecated use `Emails$inboundSchema` instead. */
  export const inboundSchema = Emails$inboundSchema;
  /** @deprecated use `Emails$outboundSchema` instead. */
  export const outboundSchema = Emails$outboundSchema;
  /** @deprecated use `Emails$Outbound` instead. */
  export type Outbound = Emails$Outbound;
}

export function emailsToJSON(emails: Emails): string {
  return JSON.stringify(Emails$outboundSchema.parse(emails));
}

export function emailsFromJSON(
  jsonString: string,
): SafeParseResult<Emails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Emails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Emails' from JSON`,
  );
}

/** @internal */
export const CompanyRowType$inboundSchema: z.ZodType<
  CompanyRowType,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
});

/** @internal */
export type CompanyRowType$Outbound = {
  id?: string | null | undefined;
  name?: string | null | undefined;
};

/** @internal */
export const CompanyRowType$outboundSchema: z.ZodType<
  CompanyRowType$Outbound,
  z.ZodTypeDef,
  CompanyRowType
> = z.object({
  id: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyRowType$ {
  /** @deprecated use `CompanyRowType$inboundSchema` instead. */
  export const inboundSchema = CompanyRowType$inboundSchema;
  /** @deprecated use `CompanyRowType$outboundSchema` instead. */
  export const outboundSchema = CompanyRowType$outboundSchema;
  /** @deprecated use `CompanyRowType$Outbound` instead. */
  export type Outbound = CompanyRowType$Outbound;
}

export function companyRowTypeToJSON(companyRowType: CompanyRowType): string {
  return JSON.stringify(CompanyRowType$outboundSchema.parse(companyRowType));
}

export function companyRowTypeFromJSON(
  jsonString: string,
): SafeParseResult<CompanyRowType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompanyRowType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyRowType' from JSON`,
  );
}

/** @internal */
export const Six$inboundSchema: z.ZodType<Six, z.ZodTypeDef, unknown> = z
  .object({});

/** @internal */
export type Six$Outbound = {};

/** @internal */
export const Six$outboundSchema: z.ZodType<Six$Outbound, z.ZodTypeDef, Six> = z
  .object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Six$ {
  /** @deprecated use `Six$inboundSchema` instead. */
  export const inboundSchema = Six$inboundSchema;
  /** @deprecated use `Six$outboundSchema` instead. */
  export const outboundSchema = Six$outboundSchema;
  /** @deprecated use `Six$Outbound` instead. */
  export type Outbound = Six$Outbound;
}

export function sixToJSON(six: Six): string {
  return JSON.stringify(Six$outboundSchema.parse(six));
}

export function sixFromJSON(
  jsonString: string,
): SafeParseResult<Six, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Six$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Six' from JSON`,
  );
}

/** @internal */
export const Four$inboundSchema: z.ZodType<Four, z.ZodTypeDef, unknown> = z
  .object({});

/** @internal */
export type Four$Outbound = {};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> =
  z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Four$ {
  /** @deprecated use `Four$inboundSchema` instead. */
  export const inboundSchema = Four$inboundSchema;
  /** @deprecated use `Four$outboundSchema` instead. */
  export const outboundSchema = Four$outboundSchema;
  /** @deprecated use `Four$Outbound` instead. */
  export type Outbound = Four$Outbound;
}

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}

export function fourFromJSON(
  jsonString: string,
): SafeParseResult<Four, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Four$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Four' from JSON`,
  );
}

/** @internal */
export const Value$inboundSchema: z.ZodType<Value, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => Four$inboundSchema),
    z.string(),
    z.number(),
    z.boolean(),
    z.array(z.string()),
    z.array(z.lazy(() => Six$inboundSchema)),
  ]);

/** @internal */
export type Value$Outbound =
  | Four$Outbound
  | string
  | number
  | boolean
  | Array<string>
  | Array<Six$Outbound>;

/** @internal */
export const Value$outboundSchema: z.ZodType<
  Value$Outbound,
  z.ZodTypeDef,
  Value
> = z.union([
  z.lazy(() => Four$outboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
  z.array(z.string()),
  z.array(z.lazy(() => Six$outboundSchema)),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Value$ {
  /** @deprecated use `Value$inboundSchema` instead. */
  export const inboundSchema = Value$inboundSchema;
  /** @deprecated use `Value$outboundSchema` instead. */
  export const outboundSchema = Value$outboundSchema;
  /** @deprecated use `Value$Outbound` instead. */
  export type Outbound = Value$Outbound;
}

export function valueToJSON(value: Value): string {
  return JSON.stringify(Value$outboundSchema.parse(value));
}

export function valueFromJSON(
  jsonString: string,
): SafeParseResult<Value, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Value$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Value' from JSON`,
  );
}

/** @internal */
export const CustomFields$inboundSchema: z.ZodType<
  CustomFields,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => Four$inboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => Six$inboundSchema)),
    ]),
  ).optional(),
});

/** @internal */
export type CustomFields$Outbound = {
  id: string | null;
  name?: string | null | undefined;
  description?: string | null | undefined;
  value?:
    | Four$Outbound
    | string
    | number
    | boolean
    | Array<string>
    | Array<Six$Outbound>
    | null
    | undefined;
};

/** @internal */
export const CustomFields$outboundSchema: z.ZodType<
  CustomFields$Outbound,
  z.ZodTypeDef,
  CustomFields
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => Four$outboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => Six$outboundSchema)),
    ]),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomFields$ {
  /** @deprecated use `CustomFields$inboundSchema` instead. */
  export const inboundSchema = CustomFields$inboundSchema;
  /** @deprecated use `CustomFields$outboundSchema` instead. */
  export const outboundSchema = CustomFields$outboundSchema;
  /** @deprecated use `CustomFields$Outbound` instead. */
  export type Outbound = CustomFields$Outbound;
}

export function customFieldsToJSON(customFields: CustomFields): string {
  return JSON.stringify(CustomFields$outboundSchema.parse(customFields));
}

export function customFieldsFromJSON(
  jsonString: string,
): SafeParseResult<CustomFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomFields' from JSON`,
  );
}

/** @internal */
export const ExtendPaths$inboundSchema: z.ZodType<
  ExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type ExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const ExtendPaths$outboundSchema: z.ZodType<
  ExtendPaths$Outbound,
  z.ZodTypeDef,
  ExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtendPaths$ {
  /** @deprecated use `ExtendPaths$inboundSchema` instead. */
  export const inboundSchema = ExtendPaths$inboundSchema;
  /** @deprecated use `ExtendPaths$outboundSchema` instead. */
  export const outboundSchema = ExtendPaths$outboundSchema;
  /** @deprecated use `ExtendPaths$Outbound` instead. */
  export type Outbound = ExtendPaths$Outbound;
}

export function extendPathsToJSON(extendPaths: ExtendPaths): string {
  return JSON.stringify(ExtendPaths$outboundSchema.parse(extendPaths));
}

export function extendPathsFromJSON(
  jsonString: string,
): SafeParseResult<ExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtendPaths' from JSON`,
  );
}

/** @internal */
export const PassThrough$inboundSchema: z.ZodType<
  PassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(z.lazy(() => ExtendPaths$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type PassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<ExtendPaths$Outbound> | undefined;
};

/** @internal */
export const PassThrough$outboundSchema: z.ZodType<
  PassThrough$Outbound,
  z.ZodTypeDef,
  PassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(z.lazy(() => ExtendPaths$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PassThrough$ {
  /** @deprecated use `PassThrough$inboundSchema` instead. */
  export const inboundSchema = PassThrough$inboundSchema;
  /** @deprecated use `PassThrough$outboundSchema` instead. */
  export const outboundSchema = PassThrough$outboundSchema;
  /** @deprecated use `PassThrough$Outbound` instead. */
  export type Outbound = PassThrough$Outbound;
}

export function passThroughToJSON(passThrough: PassThrough): string {
  return JSON.stringify(PassThrough$outboundSchema.parse(passThrough));
}

export function passThroughFromJSON(
  jsonString: string,
): SafeParseResult<PassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PassThrough' from JSON`,
  );
}

/** @internal */
export const CompaniesAddRequestBody$inboundSchema: z.ZodType<
  CompaniesAddRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.nullable(z.string()),
  owner_id: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  vat_number: z.nullable(z.string()).optional(),
  currency: z.nullable(Currency$inboundSchema).optional(),
  status: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  annual_revenue: z.nullable(z.string()).optional(),
  number_of_employees: z.nullable(z.string()).optional(),
  industry: z.nullable(z.string()).optional(),
  ownership: z.nullable(z.string()).optional(),
  sales_tax_number: z.nullable(z.string()).optional(),
  payee_number: z.nullable(z.string()).optional(),
  abn_or_tfn: z.nullable(z.string()).optional(),
  abn_branch: z.nullable(z.string()).optional(),
  acn: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  bank_accounts: z.array(z.lazy(() => BankAccounts$inboundSchema)).optional(),
  websites: z.array(z.lazy(() => Websites$inboundSchema)).optional(),
  addresses: z.array(z.lazy(() => Addresses$inboundSchema)).optional(),
  social_links: z.array(z.lazy(() => SocialLinks$inboundSchema)).optional(),
  phone_numbers: z.array(z.lazy(() => PhoneNumbers$inboundSchema)).optional(),
  emails: z.array(z.lazy(() => Emails$inboundSchema)).optional(),
  row_type: z.lazy(() => CompanyRowType$inboundSchema).optional(),
  custom_fields: z.array(z.lazy(() => CustomFields$inboundSchema)).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  read_only: z.nullable(z.boolean()).optional(),
  salutation: z.nullable(z.string()).optional(),
  birthday: z.nullable(z.string().transform(v => new RFCDate(v))).optional(),
  pass_through: z.array(z.lazy(() => PassThrough$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "vat_number": "vatNumber",
    "annual_revenue": "annualRevenue",
    "number_of_employees": "numberOfEmployees",
    "sales_tax_number": "salesTaxNumber",
    "payee_number": "payeeNumber",
    "abn_or_tfn": "abnOrTfn",
    "abn_branch": "abnBranch",
    "first_name": "firstName",
    "last_name": "lastName",
    "bank_accounts": "bankAccounts",
    "social_links": "socialLinks",
    "phone_numbers": "phoneNumbers",
    "row_type": "rowType",
    "custom_fields": "customFields",
    "read_only": "readOnly",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type CompaniesAddRequestBody$Outbound = {
  name: string | null;
  owner_id?: string | null | undefined;
  image?: string | null | undefined;
  description?: string | null | undefined;
  vat_number?: string | null | undefined;
  currency?: string | null | undefined;
  status?: string | null | undefined;
  fax?: string | null | undefined;
  annual_revenue?: string | null | undefined;
  number_of_employees?: string | null | undefined;
  industry?: string | null | undefined;
  ownership?: string | null | undefined;
  sales_tax_number?: string | null | undefined;
  payee_number?: string | null | undefined;
  abn_or_tfn?: string | null | undefined;
  abn_branch?: string | null | undefined;
  acn?: string | null | undefined;
  first_name?: string | null | undefined;
  last_name?: string | null | undefined;
  bank_accounts?: Array<BankAccounts$Outbound> | undefined;
  websites?: Array<Websites$Outbound> | undefined;
  addresses?: Array<Addresses$Outbound> | undefined;
  social_links?: Array<SocialLinks$Outbound> | undefined;
  phone_numbers?: Array<PhoneNumbers$Outbound> | undefined;
  emails?: Array<Emails$Outbound> | undefined;
  row_type?: CompanyRowType$Outbound | undefined;
  custom_fields?: Array<CustomFields$Outbound> | undefined;
  tags?: Array<string> | null | undefined;
  read_only?: boolean | null | undefined;
  salutation?: string | null | undefined;
  birthday?: string | null | undefined;
  pass_through?: Array<PassThrough$Outbound> | undefined;
};

/** @internal */
export const CompaniesAddRequestBody$outboundSchema: z.ZodType<
  CompaniesAddRequestBody$Outbound,
  z.ZodTypeDef,
  CompaniesAddRequestBody
> = z.object({
  name: z.nullable(z.string()),
  ownerId: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  vatNumber: z.nullable(z.string()).optional(),
  currency: z.nullable(Currency$outboundSchema).optional(),
  status: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  annualRevenue: z.nullable(z.string()).optional(),
  numberOfEmployees: z.nullable(z.string()).optional(),
  industry: z.nullable(z.string()).optional(),
  ownership: z.nullable(z.string()).optional(),
  salesTaxNumber: z.nullable(z.string()).optional(),
  payeeNumber: z.nullable(z.string()).optional(),
  abnOrTfn: z.nullable(z.string()).optional(),
  abnBranch: z.nullable(z.string()).optional(),
  acn: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  bankAccounts: z.array(z.lazy(() => BankAccounts$outboundSchema)).optional(),
  websites: z.array(z.lazy(() => Websites$outboundSchema)).optional(),
  addresses: z.array(z.lazy(() => Addresses$outboundSchema)).optional(),
  socialLinks: z.array(z.lazy(() => SocialLinks$outboundSchema)).optional(),
  phoneNumbers: z.array(z.lazy(() => PhoneNumbers$outboundSchema)).optional(),
  emails: z.array(z.lazy(() => Emails$outboundSchema)).optional(),
  rowType: z.lazy(() => CompanyRowType$outboundSchema).optional(),
  customFields: z.array(z.lazy(() => CustomFields$outboundSchema)).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  readOnly: z.nullable(z.boolean()).optional(),
  salutation: z.nullable(z.string()).optional(),
  birthday: z.nullable(z.instanceof(RFCDate).transform(v => v.toString()))
    .optional(),
  passThrough: z.array(z.lazy(() => PassThrough$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    vatNumber: "vat_number",
    annualRevenue: "annual_revenue",
    numberOfEmployees: "number_of_employees",
    salesTaxNumber: "sales_tax_number",
    payeeNumber: "payee_number",
    abnOrTfn: "abn_or_tfn",
    abnBranch: "abn_branch",
    firstName: "first_name",
    lastName: "last_name",
    bankAccounts: "bank_accounts",
    socialLinks: "social_links",
    phoneNumbers: "phone_numbers",
    rowType: "row_type",
    customFields: "custom_fields",
    readOnly: "read_only",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompaniesAddRequestBody$ {
  /** @deprecated use `CompaniesAddRequestBody$inboundSchema` instead. */
  export const inboundSchema = CompaniesAddRequestBody$inboundSchema;
  /** @deprecated use `CompaniesAddRequestBody$outboundSchema` instead. */
  export const outboundSchema = CompaniesAddRequestBody$outboundSchema;
  /** @deprecated use `CompaniesAddRequestBody$Outbound` instead. */
  export type Outbound = CompaniesAddRequestBody$Outbound;
}

export function companiesAddRequestBodyToJSON(
  companiesAddRequestBody: CompaniesAddRequestBody,
): string {
  return JSON.stringify(
    CompaniesAddRequestBody$outboundSchema.parse(companiesAddRequestBody),
  );
}

export function companiesAddRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CompaniesAddRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompaniesAddRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompaniesAddRequestBody' from JSON`,
  );
}

/** @internal */
export const CompaniesAddRequest$inboundSchema: z.ZodType<
  CompaniesAddRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  raw: z.boolean().default(false),
  consumerId: z.string(),
  appId: z.string(),
  serviceId: z.string().optional(),
  RequestBody: z.lazy(() => CompaniesAddRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CompaniesAddRequest$Outbound = {
  raw: boolean;
  consumerId: string;
  appId: string;
  serviceId?: string | undefined;
  RequestBody: CompaniesAddRequestBody$Outbound;
};

/** @internal */
export const CompaniesAddRequest$outboundSchema: z.ZodType<
  CompaniesAddRequest$Outbound,
  z.ZodTypeDef,
  CompaniesAddRequest
> = z.object({
  raw: z.boolean().default(false),
  consumerId: z.string(),
  appId: z.string(),
  serviceId: z.string().optional(),
  requestBody: z.lazy(() => CompaniesAddRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompaniesAddRequest$ {
  /** @deprecated use `CompaniesAddRequest$inboundSchema` instead. */
  export const inboundSchema = CompaniesAddRequest$inboundSchema;
  /** @deprecated use `CompaniesAddRequest$outboundSchema` instead. */
  export const outboundSchema = CompaniesAddRequest$outboundSchema;
  /** @deprecated use `CompaniesAddRequest$Outbound` instead. */
  export type Outbound = CompaniesAddRequest$Outbound;
}

export function companiesAddRequestToJSON(
  companiesAddRequest: CompaniesAddRequest,
): string {
  return JSON.stringify(
    CompaniesAddRequest$outboundSchema.parse(companiesAddRequest),
  );
}

export function companiesAddRequestFromJSON(
  jsonString: string,
): SafeParseResult<CompaniesAddRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompaniesAddRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompaniesAddRequest' from JSON`,
  );
}

/** @internal */
export const Detail$inboundSchema: z.ZodType<Detail, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.record(z.any())]);

/** @internal */
export type Detail$Outbound = string | { [k: string]: any };

/** @internal */
export const Detail$outboundSchema: z.ZodType<
  Detail$Outbound,
  z.ZodTypeDef,
  Detail
> = z.union([z.string(), z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Detail$ {
  /** @deprecated use `Detail$inboundSchema` instead. */
  export const inboundSchema = Detail$inboundSchema;
  /** @deprecated use `Detail$outboundSchema` instead. */
  export const outboundSchema = Detail$outboundSchema;
  /** @deprecated use `Detail$Outbound` instead. */
  export type Outbound = Detail$Outbound;
}

export function detailToJSON(detail: Detail): string {
  return JSON.stringify(Detail$outboundSchema.parse(detail));
}

export function detailFromJSON(
  jsonString: string,
): SafeParseResult<Detail, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Detail$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Detail' from JSON`,
  );
}

/** @internal */
export const CompaniesAddCompaniesResponseBody$inboundSchema: z.ZodType<
  CompaniesAddCompaniesResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().optional(),
  error: z.string().optional(),
  type_name: z.string().optional(),
  message: z.string().optional(),
  detail: z.union([z.string(), z.record(z.any())]).optional(),
  ref: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
    "type_name": "typeName",
  });
});

/** @internal */
export type CompaniesAddCompaniesResponseBody$Outbound = {
  status_code?: number | undefined;
  error?: string | undefined;
  type_name?: string | undefined;
  message?: string | undefined;
  detail?: string | { [k: string]: any } | undefined;
  ref?: string | undefined;
};

/** @internal */
export const CompaniesAddCompaniesResponseBody$outboundSchema: z.ZodType<
  CompaniesAddCompaniesResponseBody$Outbound,
  z.ZodTypeDef,
  CompaniesAddCompaniesResponseBody
> = z.object({
  statusCode: z.number().optional(),
  error: z.string().optional(),
  typeName: z.string().optional(),
  message: z.string().optional(),
  detail: z.union([z.string(), z.record(z.any())]).optional(),
  ref: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
    typeName: "type_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompaniesAddCompaniesResponseBody$ {
  /** @deprecated use `CompaniesAddCompaniesResponseBody$inboundSchema` instead. */
  export const inboundSchema = CompaniesAddCompaniesResponseBody$inboundSchema;
  /** @deprecated use `CompaniesAddCompaniesResponseBody$outboundSchema` instead. */
  export const outboundSchema =
    CompaniesAddCompaniesResponseBody$outboundSchema;
  /** @deprecated use `CompaniesAddCompaniesResponseBody$Outbound` instead. */
  export type Outbound = CompaniesAddCompaniesResponseBody$Outbound;
}

export function companiesAddCompaniesResponseBodyToJSON(
  companiesAddCompaniesResponseBody: CompaniesAddCompaniesResponseBody,
): string {
  return JSON.stringify(
    CompaniesAddCompaniesResponseBody$outboundSchema.parse(
      companiesAddCompaniesResponseBody,
    ),
  );
}

export function companiesAddCompaniesResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CompaniesAddCompaniesResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompaniesAddCompaniesResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompaniesAddCompaniesResponseBody' from JSON`,
  );
}

/** @internal */
export const UnifiedId$inboundSchema: z.ZodType<
  UnifiedId,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

/** @internal */
export type UnifiedId$Outbound = {
  id: string;
};

/** @internal */
export const UnifiedId$outboundSchema: z.ZodType<
  UnifiedId$Outbound,
  z.ZodTypeDef,
  UnifiedId
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnifiedId$ {
  /** @deprecated use `UnifiedId$inboundSchema` instead. */
  export const inboundSchema = UnifiedId$inboundSchema;
  /** @deprecated use `UnifiedId$outboundSchema` instead. */
  export const outboundSchema = UnifiedId$outboundSchema;
  /** @deprecated use `UnifiedId$Outbound` instead. */
  export type Outbound = UnifiedId$Outbound;
}

export function unifiedIdToJSON(unifiedId: UnifiedId): string {
  return JSON.stringify(UnifiedId$outboundSchema.parse(unifiedId));
}

export function unifiedIdFromJSON(
  jsonString: string,
): SafeParseResult<UnifiedId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UnifiedId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnifiedId' from JSON`,
  );
}

/** @internal */
export const CompaniesAddResponseBody$inboundSchema: z.ZodType<
  CompaniesAddResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => UnifiedId$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type CompaniesAddResponseBody$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: UnifiedId$Outbound;
};

/** @internal */
export const CompaniesAddResponseBody$outboundSchema: z.ZodType<
  CompaniesAddResponseBody$Outbound,
  z.ZodTypeDef,
  CompaniesAddResponseBody
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => UnifiedId$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompaniesAddResponseBody$ {
  /** @deprecated use `CompaniesAddResponseBody$inboundSchema` instead. */
  export const inboundSchema = CompaniesAddResponseBody$inboundSchema;
  /** @deprecated use `CompaniesAddResponseBody$outboundSchema` instead. */
  export const outboundSchema = CompaniesAddResponseBody$outboundSchema;
  /** @deprecated use `CompaniesAddResponseBody$Outbound` instead. */
  export type Outbound = CompaniesAddResponseBody$Outbound;
}

export function companiesAddResponseBodyToJSON(
  companiesAddResponseBody: CompaniesAddResponseBody,
): string {
  return JSON.stringify(
    CompaniesAddResponseBody$outboundSchema.parse(companiesAddResponseBody),
  );
}

export function companiesAddResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CompaniesAddResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompaniesAddResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompaniesAddResponseBody' from JSON`,
  );
}

/** @internal */
export const CompaniesAddResponse$inboundSchema: z.ZodType<
  CompaniesAddResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CompaniesAddResponseBody$inboundSchema),
  z.lazy(() => CompaniesAddCompaniesResponseBody$inboundSchema),
]);

/** @internal */
export type CompaniesAddResponse$Outbound =
  | CompaniesAddResponseBody$Outbound
  | CompaniesAddCompaniesResponseBody$Outbound;

/** @internal */
export const CompaniesAddResponse$outboundSchema: z.ZodType<
  CompaniesAddResponse$Outbound,
  z.ZodTypeDef,
  CompaniesAddResponse
> = z.union([
  z.lazy(() => CompaniesAddResponseBody$outboundSchema),
  z.lazy(() => CompaniesAddCompaniesResponseBody$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompaniesAddResponse$ {
  /** @deprecated use `CompaniesAddResponse$inboundSchema` instead. */
  export const inboundSchema = CompaniesAddResponse$inboundSchema;
  /** @deprecated use `CompaniesAddResponse$outboundSchema` instead. */
  export const outboundSchema = CompaniesAddResponse$outboundSchema;
  /** @deprecated use `CompaniesAddResponse$Outbound` instead. */
  export type Outbound = CompaniesAddResponse$Outbound;
}

export function companiesAddResponseToJSON(
  companiesAddResponse: CompaniesAddResponse,
): string {
  return JSON.stringify(
    CompaniesAddResponse$outboundSchema.parse(companiesAddResponse),
  );
}

export function companiesAddResponseFromJSON(
  jsonString: string,
): SafeParseResult<CompaniesAddResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompaniesAddResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompaniesAddResponse' from JSON`,
  );
}

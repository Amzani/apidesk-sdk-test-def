/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type NoteUpdateRequestExtendPaths = {
  /**
   * A JSONPath string that specifies the exact location within the user record where the value should be applied. This is essential for making precise updates to nested fields, ensuring that changes are made only to the intended parts of the data structure. The path must be valid and correspond to an existing field within the user record.
   */
  path: string;
  /**
   * This property represents the specific value that you wish to assign to a designated path within the user record. It can be of any data type, such as a string, number, boolean, or object, depending on the field being updated. The flexibility of this property allows for a wide range of updates, from simple text changes to complex data structures. In the context of the `usersUpdate` operation, this property is crucial for specifying the exact data modification you intend to make, ensuring that only the targeted fields are altered without affecting other data. Proper validation should be applied to ensure the value is compatible with the field's expected data type and business rules. Common use cases include updating user contact information, preferences, or custom attributes specific to your CRM's schema.
   */
  value?: any | undefined;
};

export type NoteUpdateRequestPassThrough = {
  /**
   * The unique identifier for the specific service to which this pass_through should be applied. This is crucial for directing the update operation to the correct service within the CRM system, ensuring that the modifications are executed in the appropriate context. It must be a valid service ID that corresponds to an active service integration, and it is required for the operation to proceed.
   */
  serviceId: string;
  /**
   * An optional identifier for a specific workflow operation within the CRM system to which this pass_through should be applied. This is particularly useful for Unify calls that involve multiple downstream requests, allowing for precise targeting and execution of specific operations. If provided, it should match an existing operation ID to ensure correct processing.
   */
  operationId?: string | undefined;
  /**
   * A flexible object that allows for the inclusion of any additional properties needed for direct extension of the user record. This can be used to add custom fields or metadata that are not part of the standard user schema, providing a way to tailor the user data to specific business needs. The structure of this object should align with the CRM's data model to ensure compatibility.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects designed for structured data modifications via specified paths. This allows for precise updates to nested data structures within the user record, enabling complex modifications without altering unrelated data. Each object in the array should define a clear path and value to be applied, ensuring targeted updates.
   */
  extendPaths?: Array<NoteUpdateRequestExtendPaths> | undefined;
};

export type NoteUpdateRequest = {
  /**
   * The title of the note. This serves as a brief summary or headline for the note's content, helping users quickly identify the note's subject matter. While not required, providing a clear and descriptive title can enhance searchability and organization within the CRM.
   */
  title?: string | null | undefined;
  /**
   * The content of the note. This field contains the main body of text for the note, where detailed information is recorded. It supports rich text formatting, allowing for a structured and readable presentation of information. Updating this field is essential when the note's details need to be revised or expanded.
   */
  content?: string | null | undefined;
  /**
   * The user that owns the note. This identifier links the note to a specific user within the CRM, typically the person responsible for the note's content. It is important for tracking accountability and managing access permissions. The owner ID should correspond to a valid user ID in the system.
   */
  ownerId?: string | null | undefined;
  /**
   * The contact that is related to the note. This field associates the note with a specific contact in the CRM, providing context and relevance to the note's content. It is particularly useful for notes that document interactions or information pertinent to a particular contact. Ensure this ID matches an existing contact ID in the CRM.
   */
  contactId?: string | null | undefined;
  /**
   * This field represents the unique identifier of the company associated with the note. It is used to link the note to a specific company within the CRM system, providing context and relevance to the note's content. While not mandatory, including this ID ensures that the note is correctly categorized under the appropriate company, facilitating better organization and retrieval of notes related to company activities. This is particularly useful in scenarios where notes are used to track interactions or updates related to specific companies.
   */
  companyId?: string | null | undefined;
  /**
   * This property holds the unique identifier for the opportunity linked to the note. It serves to associate the note with a particular sales opportunity within the CRM, thereby enhancing the note's relevance and context. Although optional, providing this ID helps in tracking the progress and updates related to specific opportunities, making it easier for sales teams to access all pertinent information in one place. This is especially beneficial in managing sales pipelines and ensuring that all notes are aligned with ongoing opportunities.
   */
  opportunityId?: string | null | undefined;
  /**
   * This attribute specifies the unique identifier for the lead associated with the note. It is used to connect the note to a particular lead in the CRM, adding context and specificity to the note's content. While not required, including this ID can significantly aid in organizing notes by lead, which is crucial for tracking interactions and follow-ups with potential clients. This is particularly important in lead management processes where maintaining detailed records of communications and updates is essential for conversion efforts.
   */
  leadId?: string | null | undefined;
  /**
   * This boolean field indicates whether the note is currently active. An active note is one that is considered relevant and up-to-date, whereas an inactive note might be archived or no longer applicable. This property is useful for filtering notes based on their current status, allowing users to focus on notes that are pertinent to ongoing activities or discussions. It is particularly valuable in maintaining an organized and efficient note management system within the CRM.
   */
  active?: boolean | null | undefined;
  /**
   * An array that allows the inclusion of service-specific custom data or structured modifications when updating the note. This property is particularly useful for integrations that require additional metadata or configuration settings that are not covered by standard fields. It enables flexibility and extensibility in handling diverse CRM requirements. Each element in the array should conform to the expected structure defined by the target service.
   */
  passThrough?: Array<NoteUpdateRequestPassThrough> | undefined;
};

/** @internal */
export const NoteUpdateRequestExtendPaths$inboundSchema: z.ZodType<
  NoteUpdateRequestExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type NoteUpdateRequestExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const NoteUpdateRequestExtendPaths$outboundSchema: z.ZodType<
  NoteUpdateRequestExtendPaths$Outbound,
  z.ZodTypeDef,
  NoteUpdateRequestExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteUpdateRequestExtendPaths$ {
  /** @deprecated use `NoteUpdateRequestExtendPaths$inboundSchema` instead. */
  export const inboundSchema = NoteUpdateRequestExtendPaths$inboundSchema;
  /** @deprecated use `NoteUpdateRequestExtendPaths$outboundSchema` instead. */
  export const outboundSchema = NoteUpdateRequestExtendPaths$outboundSchema;
  /** @deprecated use `NoteUpdateRequestExtendPaths$Outbound` instead. */
  export type Outbound = NoteUpdateRequestExtendPaths$Outbound;
}

export function noteUpdateRequestExtendPathsToJSON(
  noteUpdateRequestExtendPaths: NoteUpdateRequestExtendPaths,
): string {
  return JSON.stringify(
    NoteUpdateRequestExtendPaths$outboundSchema.parse(
      noteUpdateRequestExtendPaths,
    ),
  );
}

export function noteUpdateRequestExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<NoteUpdateRequestExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteUpdateRequestExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteUpdateRequestExtendPaths' from JSON`,
  );
}

/** @internal */
export const NoteUpdateRequestPassThrough$inboundSchema: z.ZodType<
  NoteUpdateRequestPassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => NoteUpdateRequestExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type NoteUpdateRequestPassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<NoteUpdateRequestExtendPaths$Outbound> | undefined;
};

/** @internal */
export const NoteUpdateRequestPassThrough$outboundSchema: z.ZodType<
  NoteUpdateRequestPassThrough$Outbound,
  z.ZodTypeDef,
  NoteUpdateRequestPassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => NoteUpdateRequestExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteUpdateRequestPassThrough$ {
  /** @deprecated use `NoteUpdateRequestPassThrough$inboundSchema` instead. */
  export const inboundSchema = NoteUpdateRequestPassThrough$inboundSchema;
  /** @deprecated use `NoteUpdateRequestPassThrough$outboundSchema` instead. */
  export const outboundSchema = NoteUpdateRequestPassThrough$outboundSchema;
  /** @deprecated use `NoteUpdateRequestPassThrough$Outbound` instead. */
  export type Outbound = NoteUpdateRequestPassThrough$Outbound;
}

export function noteUpdateRequestPassThroughToJSON(
  noteUpdateRequestPassThrough: NoteUpdateRequestPassThrough,
): string {
  return JSON.stringify(
    NoteUpdateRequestPassThrough$outboundSchema.parse(
      noteUpdateRequestPassThrough,
    ),
  );
}

export function noteUpdateRequestPassThroughFromJSON(
  jsonString: string,
): SafeParseResult<NoteUpdateRequestPassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteUpdateRequestPassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteUpdateRequestPassThrough' from JSON`,
  );
}

/** @internal */
export const NoteUpdateRequest$inboundSchema: z.ZodType<
  NoteUpdateRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  owner_id: z.nullable(z.string()).optional(),
  contact_id: z.nullable(z.string()).optional(),
  company_id: z.nullable(z.string()).optional(),
  opportunity_id: z.nullable(z.string()).optional(),
  lead_id: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  pass_through: z.array(
    z.lazy(() => NoteUpdateRequestPassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "contact_id": "contactId",
    "company_id": "companyId",
    "opportunity_id": "opportunityId",
    "lead_id": "leadId",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type NoteUpdateRequest$Outbound = {
  title?: string | null | undefined;
  content?: string | null | undefined;
  owner_id?: string | null | undefined;
  contact_id?: string | null | undefined;
  company_id?: string | null | undefined;
  opportunity_id?: string | null | undefined;
  lead_id?: string | null | undefined;
  active?: boolean | null | undefined;
  pass_through?: Array<NoteUpdateRequestPassThrough$Outbound> | undefined;
};

/** @internal */
export const NoteUpdateRequest$outboundSchema: z.ZodType<
  NoteUpdateRequest$Outbound,
  z.ZodTypeDef,
  NoteUpdateRequest
> = z.object({
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  ownerId: z.nullable(z.string()).optional(),
  contactId: z.nullable(z.string()).optional(),
  companyId: z.nullable(z.string()).optional(),
  opportunityId: z.nullable(z.string()).optional(),
  leadId: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  passThrough: z.array(
    z.lazy(() => NoteUpdateRequestPassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    contactId: "contact_id",
    companyId: "company_id",
    opportunityId: "opportunity_id",
    leadId: "lead_id",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteUpdateRequest$ {
  /** @deprecated use `NoteUpdateRequest$inboundSchema` instead. */
  export const inboundSchema = NoteUpdateRequest$inboundSchema;
  /** @deprecated use `NoteUpdateRequest$outboundSchema` instead. */
  export const outboundSchema = NoteUpdateRequest$outboundSchema;
  /** @deprecated use `NoteUpdateRequest$Outbound` instead. */
  export type Outbound = NoteUpdateRequest$Outbound;
}

export function noteUpdateRequestToJSON(
  noteUpdateRequest: NoteUpdateRequest,
): string {
  return JSON.stringify(
    NoteUpdateRequest$outboundSchema.parse(noteUpdateRequest),
  );
}

export function noteUpdateRequestFromJSON(
  jsonString: string,
): SafeParseResult<NoteUpdateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteUpdateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteUpdateRequest' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Specifies the type of address, such as 'home' or 'work', associated with the user. This helps categorize the address within the CRM for better organization and retrieval. Ensure the type is a valid string that accurately represents the address category.
 */
export const CreateUserRequestType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Office: "office",
  Shipping: "shipping",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the type of address, such as 'home' or 'work', associated with the user. This helps categorize the address within the CRM for better organization and retrieval. Ensure the type is a valid string that accurately represents the address category.
 */
export type CreateUserRequestType = ClosedEnum<typeof CreateUserRequestType>;

export type CreateUserRequestAddresses = {
  /**
   * A unique identifier for the address associated with the user being added. This ID is used to distinguish between different addresses within the CRM system. It should be a valid string that uniquely identifies an address record, if available.
   */
  id?: string | null | undefined;
  /**
   * Specifies the type of address, such as 'home' or 'work', associated with the user. This helps categorize the address within the CRM for better organization and retrieval. Ensure the type is a valid string that accurately represents the address category.
   */
  type?: CreateUserRequestType | null | undefined;
  /**
   * The full address in a single string format, used when structured address data is not available. This field allows for flexibility in address input, accommodating various address formats. It should be a comprehensive string that includes all necessary address details.
   */
  string?: string | null | undefined;
  /**
   * The name or label for the address, which can be used to identify it within the CRM system. This is useful for distinguishing between multiple addresses associated with a user. It should be a descriptive string that clearly identifies the address.
   */
  name?: string | null | undefined;
  /**
   * The first line of the address, typically including the street number, street name, and any apartment or suite number. This field is essential for accurately locating the address within the CRM. Ensure it is a detailed string that provides the primary address information.
   */
  line1?: string | null | undefined;
  /**
   * This optional field allows you to specify additional address details, such as apartment or suite numbers, to ensure accurate delivery and location identification within the CRM system. It enhances the primary address line by providing more specific location information. There are no specific format requirements, but it should be a string that complements the main address line.
   */
  line2?: string | null | undefined;
  /**
   * An optional field for further address details, such as building or floor information, to enhance the precision of the address in the CRM. This field is useful for complex addresses that require more than two lines for complete identification. It should be a string that provides additional context to the address.
   */
  line3?: string | null | undefined;
  /**
   * This field is used to capture any additional address information that cannot be accommodated in the previous lines, ensuring comprehensive address details in the CRM. It is particularly useful for addresses with multiple components that need to be distinctly recorded. The input should be a string that adds further detail to the address.
   */
  line4?: string | null | undefined;
  /**
   * The street number is a crucial part of the address, specifying the exact location on the street for the user being added to the CRM. This field should contain the numeric or alphanumeric identifier of the building or property. It is essential for precise address identification and should be formatted as a string.
   */
  streetNumber?: string | null | undefined;
  /**
   * This field specifies the city name where the user resides, which is vital for geographic identification and routing within the CRM system. It should be a valid city name formatted as a string, ensuring that the user's location is accurately recorded and managed.
   */
  city?: string | null | undefined;
  /**
   * Specifies the state or region associated with the user's address. This property helps in accurately locating the user within a specific geographical area, which is crucial for regional data management and analysis. The value should be a valid state name or abbreviation as recognized in the user's country.
   */
  state?: string | null | undefined;
  /**
   * Represents the postal code for the user's address, essential for mail delivery and location-based services. This property should be a valid postal code format as per the country's postal system, ensuring accurate address identification and processing.
   */
  postalCode?: string | null | undefined;
  /**
   * Denotes the country code of the user's address, following the ISO 3166-1 alpha-2 standard. This property is vital for internationalization and ensuring the address is correctly associated with the respective country. The value must be a valid two-letter country code.
   */
  country?: string | null | undefined;
  /**
   * Indicates the latitude coordinate of the user's address, used for precise geolocation and mapping services. This property should be a valid latitude value, typically ranging from -90 to 90, to ensure accurate geographical positioning.
   */
  latitude?: string | null | undefined;
  /**
   * Specifies the longitude coordinate of the user's address, crucial for accurate geolocation and mapping. This property must be a valid longitude value, generally ranging from -180 to 180, to facilitate precise location tracking and services.
   */
  longitude?: string | null | undefined;
  /**
   * This field specifies the county or sublocality for the address associated with the user being added. It helps in accurately identifying the geographical area for the address, which can be crucial for regional operations or services. The value should be a valid county name, if applicable, to ensure proper address formatting and validation.
   */
  county?: string | null | undefined;
  /**
   * The name of the contact person at the specified address. This is used to personalize communications and ensure that correspondence is directed to the correct individual. It should be a full name that accurately identifies the contact person associated with the address.
   */
  contactName?: string | null | undefined;
  /**
   * The salutation for the contact person at the address, such as 'Mr.', 'Ms.', or 'Dr.'. This field is used to address the contact person respectfully in communications. It should be a standard salutation that aligns with the contact's title or preference.
   */
  salutation?: string | null | undefined;
  /**
   * The phone number associated with the address, used for direct communication with the contact person. This should be a valid phone number format, including country and area codes if applicable, to ensure successful contact.
   */
  phoneNumber?: string | null | undefined;
  /**
   * The fax number for the address, which can be used for sending documents via fax. This should be a valid fax number format, including any necessary country and area codes, to ensure documents are sent correctly.
   */
  fax?: string | null | undefined;
  /**
   * The email address associated with the user's address. This field is used to contact the user and should be a valid email format to ensure proper communication. It is optional but recommended for effective user management within the CRM.
   */
  email?: string | null | undefined;
  /**
   * The website URL associated with the user's address. This property allows linking to the user's personal or business website, providing additional context and information. It should be a valid URL format if provided.
   */
  website?: string | null | undefined;
  /**
   * Additional notes related to the user's address. This field can be used to store any extra information or comments about the address that may be useful for CRM users. It is optional and can be left empty if not needed.
   */
  notes?: string | null | undefined;
  /**
   * A binary value used to detect updates to an object and prevent data conflicts. This field is crucial for maintaining data integrity by ensuring that updates are applied correctly and no conflicting changes occur. It is automatically incremented with each update to the object.
   */
  rowVersion?: string | null | undefined;
};

/**
 * Specifies the category of the phone number, such as 'home', 'work', or 'mobile'. This helps in identifying the context in which the phone number is used, aiding in better organization and retrieval of contact information. It is optional and can be left blank if the type is not specified.
 */
export const CreateUserRequestPhoneNumbersType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Work: "work",
  Office: "office",
  Mobile: "mobile",
  Assistant: "assistant",
  Fax: "fax",
  DirectDialIn: "direct-dial-in",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * Specifies the category of the phone number, such as 'home', 'work', or 'mobile'. This helps in identifying the context in which the phone number is used, aiding in better organization and retrieval of contact information. It is optional and can be left blank if the type is not specified.
 */
export type CreateUserRequestPhoneNumbersType = ClosedEnum<
  typeof CreateUserRequestPhoneNumbersType
>;

export type CreateUserRequestPhoneNumbers = {
  /**
   * This property serves as a unique identifier for the phone number within the CRM system. It is used to distinguish between different phone numbers associated with a user, although it is not mandatory to provide. If included, it should be a valid string that uniquely identifies the phone number entry.
   */
  id?: string | null | undefined;
  /**
   * The country code for the phone number, such as '+1' for the United States, is used to specify the international dialing code. This property helps ensure that the phone number is correctly formatted for international calls. It is optional but recommended for clarity and accuracy in global communications.
   */
  countryCode?: string | null | undefined;
  /**
   * The area code of the phone number, like '323' for Los Angeles, is used to specify the regional part of the phone number. This property is optional and helps in accurately routing calls within specific geographic areas. Providing an area code ensures that the phone number is complete and correctly formatted for local dialing.
   */
  areaCode?: string | null | undefined;
  /**
   * This is the main phone number associated with the user and is required for adding a new user to the CRM. It must be a valid string representing the user's phone number, excluding the country and area codes. This property is essential for contact purposes and must be provided to successfully create a user entry.
   */
  number: string;
  /**
   * The extension of the phone number is used to direct calls to a specific line within a larger phone system, such as an office or department. This property is optional and should be included if the phone number requires an extension for proper routing. It helps in reaching the intended recipient directly when calling.
   */
  extension?: string | null | undefined;
  /**
   * Specifies the category of the phone number, such as 'home', 'work', or 'mobile'. This helps in identifying the context in which the phone number is used, aiding in better organization and retrieval of contact information. It is optional and can be left blank if the type is not specified.
   */
  type?: CreateUserRequestPhoneNumbersType | null | undefined;
};

/**
 * Defines the nature of the email address, such as 'personal' or 'work'. This classification helps in organizing emails based on their usage context, enhancing user profile management. It is optional and can be omitted if not applicable.
 */
export const CreateUserRequestEmailsType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Defines the nature of the email address, such as 'personal' or 'work'. This classification helps in organizing emails based on their usage context, enhancing user profile management. It is optional and can be omitted if not applicable.
 */
export type CreateUserRequestEmailsType = ClosedEnum<
  typeof CreateUserRequestEmailsType
>;

export type CreateUserRequestEmails = {
  /**
   * A unique identifier for each email address entry. This ID is used to distinguish between different email records within the user's profile, facilitating updates and management of specific email addresses. It is optional and automatically generated if not provided.
   */
  id?: string | null | undefined;
  /**
   * The actual email address of the user, which is required for communication and identification purposes within the CRM. This field must be a valid email format and is essential for creating a user profile.
   */
  email: string | null;
  /**
   * Defines the nature of the email address, such as 'personal' or 'work'. This classification helps in organizing emails based on their usage context, enhancing user profile management. It is optional and can be omitted if not applicable.
   */
  type?: CreateUserRequestEmailsType | null | undefined;
};

export type CreateUserRequestExtendPaths = {
  /**
   * Specifies the JSONPath string where the value should be applied within the user data structure. This path is crucial for accurately placing the new data in the correct location, ensuring that the user information is updated or added precisely as intended. The path must be a valid JSONPath expression to navigate the user data structure effectively.
   */
  path: string;
  /**
   * Defines the value to be set at the specified JSONPath within the user data structure. This value can be of any data type, allowing flexibility in the kind of data you can add or update. It is essential for modifying user data accurately, ensuring that the correct information is stored at the designated path.
   */
  value?: any | undefined;
};

export type CreateUserRequestPassThrough = {
  /**
   * The service_id is a mandatory string that identifies the specific service to which the pass_through data should be applied. This ensures that the custom data is routed correctly to the intended service, facilitating precise service-specific operations.
   */
  serviceId: string;
  /**
   * The operation_id is an optional string that specifies a particular workflow operation for applying the pass_through data. This is particularly useful in scenarios where multiple downstream requests are involved, allowing for targeted application of custom data.
   */
  operationId?: string | undefined;
  /**
   * The extend_object is a flexible object that allows for the inclusion of any additional properties needed to extend the request. This feature supports direct extensions by enabling the addition of custom fields or data structures as required by the service.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * The extend_paths property is an array of objects designed for structured data modifications using paths. This allows developers to specify precise modifications to the data structure, facilitating complex updates or transformations within the request body.
   */
  extendPaths?: Array<CreateUserRequestExtendPaths> | undefined;
};

export type CreateUserRequest = {
  /**
   * This optional field specifies the ID of the parent user, allowing you to establish a hierarchical relationship between users within the CRM. It is useful for organizing users under a common parent, such as a team leader or department head, but is not required for all users. Ensure the ID provided corresponds to an existing user in the system to maintain data integrity.
   */
  parentId?: string | null | undefined;
  /**
   * The username serves as the unique identifier for the user within the CRM system. It is crucial for user login and authentication processes, ensuring each user can be distinctly recognized. While not mandatory, it is recommended to provide a unique username to facilitate user management and access control.
   */
  username?: string | null | undefined;
  /**
   * This field captures the user's first name, which is used for personalization and identification purposes within the CRM. It enhances user interaction by allowing the system to address users by their first name in communications and reports. Although optional, providing a first name can improve the user experience and data completeness.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the user, which is used in conjunction with the first name to fully identify the user within the CRM. This field supports personalization and accurate record-keeping, ensuring that users can be properly addressed and managed. While not required, including a last name helps maintain comprehensive user profiles.
   */
  lastName?: string | null | undefined;
  /**
   * This field denotes the user's job title, providing context about their role within the organization. It is useful for understanding the user's position and responsibilities, aiding in role-based access and reporting. Although optional, specifying a job title can enhance the clarity of user roles and organizational structure within the CRM.
   */
  title?: string | null | undefined;
  /**
   * Specifies the division within the organization where the user is currently assigned. This field helps categorize users into larger organizational units, such as regions or teams, for better management and reporting. It is optional and can be left blank if not applicable.
   */
  division?: string | null | undefined;
  /**
   * Indicates the department where the user is currently working. Although deprecated in favor of 'department_id' and 'department_name', it may still be used for backward compatibility. This field is optional and should be used with caution as it might be removed in future versions.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  department?: string | null | undefined;
  /**
   * Represents the name of the company associated with the user. This field is used to link the user to a specific company within the CRM, aiding in organization and data retrieval. It is optional and should be a valid string representing the company's name.
   */
  companyName?: string | null | undefined;
  /**
   * A unique identifier assigned to the user within the company, such as an Employee Number or ID. This field is crucial for distinguishing between users and managing employee records effectively. It is optional but should be unique and consistent across the organization.
   */
  employeeNumber?: string | null | undefined;
  /**
   * Provides additional information or context about the user being added. This field can be used to include notes or descriptions that are relevant to the user's role or status within the CRM. It is optional and should be a concise, informative string.
   */
  description?: string | null | undefined;
  /**
   * The URL of the user's avatar image. This property allows you to associate a visual representation with the user profile, enhancing user identification and personalization within the CRM. The URL must be a valid string pointing to an accessible image resource.
   */
  image?: string | null | undefined;
  /**
   * The language code for the user's preferred language, following the ISO 639-1 standard. This property helps tailor the user experience by displaying content in the user's preferred language. For example, 'EN' for English in the United States.
   */
  language?: string | null | undefined;
  /**
   * The current status of the user within the CRM system. This property indicates the user's operational state, such as active or inactive, affecting their ability to interact with the system. Ensure the status is a valid string that aligns with the system's user management policies.
   */
  status?: string | null | undefined;
  /**
   * The password for the user's account, used for authentication purposes. This property is crucial for securing user access and must comply with the system's password policy, typically requiring a mix of letters, numbers, and special characters.
   */
  password?: string | null | undefined;
  /**
   * A list of addresses associated with the user, which can include multiple entries for different address types such as home or work. This property supports comprehensive user profiles by storing detailed location information, enhancing CRM functionalities like location-based services.
   */
  addresses?: Array<CreateUserRequestAddresses> | undefined;
  /**
   * A list of phone numbers associated with the user. This array can include multiple phone numbers, allowing for comprehensive contact information. Each phone number should be formatted correctly to ensure accurate communication.
   */
  phoneNumbers?: Array<CreateUserRequestPhoneNumbers> | undefined;
  /**
   * A collection of email objects associated with the user. Each object within the array must contain at least the 'email' field, ensuring that the user has one or more email addresses registered in the CRM system. This property is mandatory and crucial for user identification and communication.
   */
  emails: Array<CreateUserRequestEmails>;
  /**
   * The pass_through property is used to include custom data or modifications specific to a service when creating or updating resources. This allows for flexibility in handling service-specific requirements without altering the core API structure. It should be an array containing objects that define these customizations.
   */
  passThrough?: Array<CreateUserRequestPassThrough> | undefined;
};

/** @internal */
export const CreateUserRequestType$inboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestType
> = z.nativeEnum(CreateUserRequestType);

/** @internal */
export const CreateUserRequestType$outboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestType
> = CreateUserRequestType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestType$ {
  /** @deprecated use `CreateUserRequestType$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestType$inboundSchema;
  /** @deprecated use `CreateUserRequestType$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestType$outboundSchema;
}

/** @internal */
export const CreateUserRequestAddresses$inboundSchema: z.ZodType<
  CreateUserRequestAddresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CreateUserRequestType$inboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  street_number: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postal_code: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contact_name: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phone_number: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  row_version: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "street_number": "streetNumber",
    "postal_code": "postalCode",
    "contact_name": "contactName",
    "phone_number": "phoneNumber",
    "row_version": "rowVersion",
  });
});

/** @internal */
export type CreateUserRequestAddresses$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
  string?: string | null | undefined;
  name?: string | null | undefined;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  line3?: string | null | undefined;
  line4?: string | null | undefined;
  street_number?: string | null | undefined;
  city?: string | null | undefined;
  state?: string | null | undefined;
  postal_code?: string | null | undefined;
  country?: string | null | undefined;
  latitude?: string | null | undefined;
  longitude?: string | null | undefined;
  county?: string | null | undefined;
  contact_name?: string | null | undefined;
  salutation?: string | null | undefined;
  phone_number?: string | null | undefined;
  fax?: string | null | undefined;
  email?: string | null | undefined;
  website?: string | null | undefined;
  notes?: string | null | undefined;
  row_version?: string | null | undefined;
};

/** @internal */
export const CreateUserRequestAddresses$outboundSchema: z.ZodType<
  CreateUserRequestAddresses$Outbound,
  z.ZodTypeDef,
  CreateUserRequestAddresses
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CreateUserRequestType$outboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  streetNumber: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contactName: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phoneNumber: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  rowVersion: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    streetNumber: "street_number",
    postalCode: "postal_code",
    contactName: "contact_name",
    phoneNumber: "phone_number",
    rowVersion: "row_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestAddresses$ {
  /** @deprecated use `CreateUserRequestAddresses$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestAddresses$inboundSchema;
  /** @deprecated use `CreateUserRequestAddresses$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestAddresses$outboundSchema;
  /** @deprecated use `CreateUserRequestAddresses$Outbound` instead. */
  export type Outbound = CreateUserRequestAddresses$Outbound;
}

export function createUserRequestAddressesToJSON(
  createUserRequestAddresses: CreateUserRequestAddresses,
): string {
  return JSON.stringify(
    CreateUserRequestAddresses$outboundSchema.parse(createUserRequestAddresses),
  );
}

export function createUserRequestAddressesFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestAddresses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequestAddresses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestAddresses' from JSON`,
  );
}

/** @internal */
export const CreateUserRequestPhoneNumbersType$inboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestPhoneNumbersType
> = z.nativeEnum(CreateUserRequestPhoneNumbersType);

/** @internal */
export const CreateUserRequestPhoneNumbersType$outboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestPhoneNumbersType
> = CreateUserRequestPhoneNumbersType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestPhoneNumbersType$ {
  /** @deprecated use `CreateUserRequestPhoneNumbersType$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestPhoneNumbersType$inboundSchema;
  /** @deprecated use `CreateUserRequestPhoneNumbersType$outboundSchema` instead. */
  export const outboundSchema =
    CreateUserRequestPhoneNumbersType$outboundSchema;
}

/** @internal */
export const CreateUserRequestPhoneNumbers$inboundSchema: z.ZodType<
  CreateUserRequestPhoneNumbers,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  country_code: z.nullable(z.string()).optional(),
  area_code: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(CreateUserRequestPhoneNumbersType$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "country_code": "countryCode",
    "area_code": "areaCode",
  });
});

/** @internal */
export type CreateUserRequestPhoneNumbers$Outbound = {
  id?: string | null | undefined;
  country_code?: string | null | undefined;
  area_code?: string | null | undefined;
  number: string;
  extension?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const CreateUserRequestPhoneNumbers$outboundSchema: z.ZodType<
  CreateUserRequestPhoneNumbers$Outbound,
  z.ZodTypeDef,
  CreateUserRequestPhoneNumbers
> = z.object({
  id: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  areaCode: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(CreateUserRequestPhoneNumbersType$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    countryCode: "country_code",
    areaCode: "area_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestPhoneNumbers$ {
  /** @deprecated use `CreateUserRequestPhoneNumbers$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestPhoneNumbers$inboundSchema;
  /** @deprecated use `CreateUserRequestPhoneNumbers$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestPhoneNumbers$outboundSchema;
  /** @deprecated use `CreateUserRequestPhoneNumbers$Outbound` instead. */
  export type Outbound = CreateUserRequestPhoneNumbers$Outbound;
}

export function createUserRequestPhoneNumbersToJSON(
  createUserRequestPhoneNumbers: CreateUserRequestPhoneNumbers,
): string {
  return JSON.stringify(
    CreateUserRequestPhoneNumbers$outboundSchema.parse(
      createUserRequestPhoneNumbers,
    ),
  );
}

export function createUserRequestPhoneNumbersFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestPhoneNumbers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequestPhoneNumbers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestPhoneNumbers' from JSON`,
  );
}

/** @internal */
export const CreateUserRequestEmailsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestEmailsType
> = z.nativeEnum(CreateUserRequestEmailsType);

/** @internal */
export const CreateUserRequestEmailsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestEmailsType
> = CreateUserRequestEmailsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestEmailsType$ {
  /** @deprecated use `CreateUserRequestEmailsType$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestEmailsType$inboundSchema;
  /** @deprecated use `CreateUserRequestEmailsType$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestEmailsType$outboundSchema;
}

/** @internal */
export const CreateUserRequestEmails$inboundSchema: z.ZodType<
  CreateUserRequestEmails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(CreateUserRequestEmailsType$inboundSchema).optional(),
});

/** @internal */
export type CreateUserRequestEmails$Outbound = {
  id?: string | null | undefined;
  email: string | null;
  type?: string | null | undefined;
};

/** @internal */
export const CreateUserRequestEmails$outboundSchema: z.ZodType<
  CreateUserRequestEmails$Outbound,
  z.ZodTypeDef,
  CreateUserRequestEmails
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(CreateUserRequestEmailsType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestEmails$ {
  /** @deprecated use `CreateUserRequestEmails$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestEmails$inboundSchema;
  /** @deprecated use `CreateUserRequestEmails$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestEmails$outboundSchema;
  /** @deprecated use `CreateUserRequestEmails$Outbound` instead. */
  export type Outbound = CreateUserRequestEmails$Outbound;
}

export function createUserRequestEmailsToJSON(
  createUserRequestEmails: CreateUserRequestEmails,
): string {
  return JSON.stringify(
    CreateUserRequestEmails$outboundSchema.parse(createUserRequestEmails),
  );
}

export function createUserRequestEmailsFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestEmails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequestEmails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestEmails' from JSON`,
  );
}

/** @internal */
export const CreateUserRequestExtendPaths$inboundSchema: z.ZodType<
  CreateUserRequestExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type CreateUserRequestExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const CreateUserRequestExtendPaths$outboundSchema: z.ZodType<
  CreateUserRequestExtendPaths$Outbound,
  z.ZodTypeDef,
  CreateUserRequestExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestExtendPaths$ {
  /** @deprecated use `CreateUserRequestExtendPaths$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestExtendPaths$inboundSchema;
  /** @deprecated use `CreateUserRequestExtendPaths$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestExtendPaths$outboundSchema;
  /** @deprecated use `CreateUserRequestExtendPaths$Outbound` instead. */
  export type Outbound = CreateUserRequestExtendPaths$Outbound;
}

export function createUserRequestExtendPathsToJSON(
  createUserRequestExtendPaths: CreateUserRequestExtendPaths,
): string {
  return JSON.stringify(
    CreateUserRequestExtendPaths$outboundSchema.parse(
      createUserRequestExtendPaths,
    ),
  );
}

export function createUserRequestExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequestExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestExtendPaths' from JSON`,
  );
}

/** @internal */
export const CreateUserRequestPassThrough$inboundSchema: z.ZodType<
  CreateUserRequestPassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => CreateUserRequestExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type CreateUserRequestPassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<CreateUserRequestExtendPaths$Outbound> | undefined;
};

/** @internal */
export const CreateUserRequestPassThrough$outboundSchema: z.ZodType<
  CreateUserRequestPassThrough$Outbound,
  z.ZodTypeDef,
  CreateUserRequestPassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => CreateUserRequestExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestPassThrough$ {
  /** @deprecated use `CreateUserRequestPassThrough$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestPassThrough$inboundSchema;
  /** @deprecated use `CreateUserRequestPassThrough$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestPassThrough$outboundSchema;
  /** @deprecated use `CreateUserRequestPassThrough$Outbound` instead. */
  export type Outbound = CreateUserRequestPassThrough$Outbound;
}

export function createUserRequestPassThroughToJSON(
  createUserRequestPassThrough: CreateUserRequestPassThrough,
): string {
  return JSON.stringify(
    CreateUserRequestPassThrough$outboundSchema.parse(
      createUserRequestPassThrough,
    ),
  );
}

export function createUserRequestPassThroughFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestPassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequestPassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestPassThrough' from JSON`,
  );
}

/** @internal */
export const CreateUserRequest$inboundSchema: z.ZodType<
  CreateUserRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  parent_id: z.nullable(z.string()).optional(),
  username: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  division: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  company_name: z.nullable(z.string()).optional(),
  employee_number: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  password: z.nullable(z.string()).optional(),
  addresses: z.array(z.lazy(() => CreateUserRequestAddresses$inboundSchema))
    .optional(),
  phone_numbers: z.array(
    z.lazy(() => CreateUserRequestPhoneNumbers$inboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => CreateUserRequestEmails$inboundSchema)),
  pass_through: z.array(
    z.lazy(() => CreateUserRequestPassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "parent_id": "parentId",
    "first_name": "firstName",
    "last_name": "lastName",
    "company_name": "companyName",
    "employee_number": "employeeNumber",
    "phone_numbers": "phoneNumbers",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type CreateUserRequest$Outbound = {
  parent_id?: string | null | undefined;
  username?: string | null | undefined;
  first_name?: string | null | undefined;
  last_name?: string | null | undefined;
  title?: string | null | undefined;
  division?: string | null | undefined;
  department?: string | null | undefined;
  company_name?: string | null | undefined;
  employee_number?: string | null | undefined;
  description?: string | null | undefined;
  image?: string | null | undefined;
  language?: string | null | undefined;
  status?: string | null | undefined;
  password?: string | null | undefined;
  addresses?: Array<CreateUserRequestAddresses$Outbound> | undefined;
  phone_numbers?: Array<CreateUserRequestPhoneNumbers$Outbound> | undefined;
  emails: Array<CreateUserRequestEmails$Outbound>;
  pass_through?: Array<CreateUserRequestPassThrough$Outbound> | undefined;
};

/** @internal */
export const CreateUserRequest$outboundSchema: z.ZodType<
  CreateUserRequest$Outbound,
  z.ZodTypeDef,
  CreateUserRequest
> = z.object({
  parentId: z.nullable(z.string()).optional(),
  username: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  division: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  companyName: z.nullable(z.string()).optional(),
  employeeNumber: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  password: z.nullable(z.string()).optional(),
  addresses: z.array(z.lazy(() => CreateUserRequestAddresses$outboundSchema))
    .optional(),
  phoneNumbers: z.array(
    z.lazy(() => CreateUserRequestPhoneNumbers$outboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => CreateUserRequestEmails$outboundSchema)),
  passThrough: z.array(
    z.lazy(() => CreateUserRequestPassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    parentId: "parent_id",
    firstName: "first_name",
    lastName: "last_name",
    companyName: "company_name",
    employeeNumber: "employee_number",
    phoneNumbers: "phone_numbers",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequest$ {
  /** @deprecated use `CreateUserRequest$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequest$inboundSchema;
  /** @deprecated use `CreateUserRequest$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequest$outboundSchema;
  /** @deprecated use `CreateUserRequest$Outbound` instead. */
  export type Outbound = CreateUserRequest$Outbound;
}

export function createUserRequestToJSON(
  createUserRequest: CreateUserRequest,
): string {
  return JSON.stringify(
    CreateUserRequest$outboundSchema.parse(createUserRequest),
  );
}

export function createUserRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequest' from JSON`,
  );
}

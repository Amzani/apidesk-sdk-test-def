/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Specifies the category or purpose of the address, such as 'home', 'work', or 'billing'. This helps in organizing and retrieving addresses based on their usage context. The value should be a valid string that clearly indicates the address type, though it is optional.
 */
export const CreateUserRequestType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Office: "office",
  Shipping: "shipping",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the category or purpose of the address, such as 'home', 'work', or 'billing'. This helps in organizing and retrieving addresses based on their usage context. The value should be a valid string that clearly indicates the address type, though it is optional.
 */
export type CreateUserRequestType = ClosedEnum<typeof CreateUserRequestType>;

export type CreateUserRequestAddresses = {
  /**
   * A unique identifier for the address within the CRM system. This ID is used to distinguish between different addresses associated with a user. It should be a valid string if provided, although it is not required for creating a new user.
   */
  id?: string | null | undefined;
  /**
   * Specifies the category or purpose of the address, such as 'home', 'work', or 'billing'. This helps in organizing and retrieving addresses based on their usage context. The value should be a valid string that clearly indicates the address type, though it is optional.
   */
  type?: CreateUserRequestType | null | undefined;
  /**
   * Represents the full address in a single string format. This is particularly useful when the API does not support structured address data. It should be a comprehensive string that includes all necessary address details, but it is not mandatory for the request.
   */
  string?: string | null | undefined;
  /**
   * The designated name for the address, which can be used to identify it easily within the user's address list. This could be a label like 'Headquarters' or 'Main Office'. It should be a descriptive string, although providing it is optional.
   */
  name?: string | null | undefined;
  /**
   * The first line of the address, typically including the street number, street name, and any apartment or suite numbers. This field is crucial for accurately locating the address, but it is not required for the operation.
   */
  line1?: string | null | undefined;
  /**
   * An optional second line for the user's address, typically used for apartment numbers or additional location details. This field can be left empty if not applicable. It helps in providing a more precise address for user records in the CRM.
   */
  line2?: string | null | undefined;
  /**
   * An optional third line for the user's address, often used for further address details such as building names or complex identifiers. This field is not mandatory and can be omitted if unnecessary. It aids in capturing comprehensive address information for CRM entries.
   */
  line3?: string | null | undefined;
  /**
   * An optional fourth line for the user's address, used for any additional address information that doesn't fit in the previous lines. This field is optional and should be used only when needed to ensure complete address details in the CRM system.
   */
  line4?: string | null | undefined;
  /**
   * The street number of the user's address, which is essential for accurately locating the address. This field should contain only the numeric part of the street address and is optional if not applicable. It contributes to the precise identification of the user's location within the CRM.
   */
  streetNumber?: string | null | undefined;
  /**
   * The name of the city where the user resides, crucial for identifying the geographical location of the user. This field should be a valid city name and is optional, but recommended for complete address records in the CRM.
   */
  city?: string | null | undefined;
  /**
   * The state or province name associated with the user's address. This field helps in identifying the specific region within a country where the user resides. It should be a valid state name recognized within the specified country, aiding in accurate geographical identification for CRM operations.
   */
  state?: string | null | undefined;
  /**
   * The postal code or ZIP code for the user's address. This code is crucial for pinpointing the exact location within a city or town, facilitating precise delivery and location-based services. It should conform to the postal format of the respective country.
   */
  postalCode?: string | null | undefined;
  /**
   * The country code for the user's address, following the ISO 3166-1 alpha-2 standard. This two-letter code is essential for identifying the user's country, ensuring that the address is correctly categorized and processed within the CRM system.
   */
  country?: string | null | undefined;
  /**
   * The latitude coordinate of the user's address, expressed as a decimal. This value is used for geolocation purposes, allowing the CRM system to map the user's exact position on the globe. It should be a valid latitude value ranging from -90 to 90.
   */
  latitude?: string | null | undefined;
  /**
   * The longitude coordinate of the user's address, expressed as a decimal. This property is vital for geolocation, enabling the CRM to accurately place the user's address on a map. It should be a valid longitude value ranging from -180 to 180.
   */
  longitude?: string | null | undefined;
  /**
   * Specifies the county or sublocality within the address. This field is optional and can be used to provide more detailed location information, which may be useful for regional segmentation or reporting within the CRM system.
   */
  county?: string | null | undefined;
  /**
   * The full name of the primary contact person associated with the address. This optional field helps identify the individual responsible for communications or transactions at this location, enhancing the CRM's contact management capabilities.
   */
  contactName?: string | null | undefined;
  /**
   * The salutation or title of the contact person, such as Mr., Ms., or Dr. This optional field personalizes communications and is useful for maintaining formal correspondence standards within the CRM.
   */
  salutation?: string | null | undefined;
  /**
   * The primary phone number associated with the address. This optional field should be formatted according to international standards to ensure proper connectivity and is crucial for direct communication with the contact person or organization at this location.
   */
  phoneNumber?: string | null | undefined;
  /**
   * The fax number for the address, if applicable. This optional field supports traditional communication methods and should be formatted correctly to ensure successful transmission of documents.
   */
  fax?: string | null | undefined;
  /**
   * The primary email address associated with the user's address. This field should be a valid email format and is used for communication purposes within the CRM system. Although optional, providing an email enhances the user's contact profile.
   */
  email?: string | null | undefined;
  /**
   * The website URL associated with the user's address. This should be a valid URL format and can be used to link to the user's personal or business website. Including a website helps in providing a comprehensive view of the user's online presence.
   */
  website?: string | null | undefined;
  /**
   * Additional notes or comments related to the user's address. This field can include any extra information that might be relevant for CRM users, such as delivery instructions or personal preferences. It is optional but useful for detailed record-keeping.
   */
  notes?: string | null | undefined;
  /**
   * A concurrency control token used to manage updates to the user's address object. This binary value is automatically incremented with each update to prevent data conflicts and ensure data integrity. It is optional but crucial for systems that require robust data synchronization.
   */
  rowVersion?: string | null | undefined;
};

/**
 * Specifies the category of the phone number, such as 'mobile', 'home', or 'work'. This helps in identifying the context in which the phone number is used, enhancing user contact management within the CRM.
 */
export const CreateUserRequestPhoneNumbersType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Work: "work",
  Office: "office",
  Mobile: "mobile",
  Assistant: "assistant",
  Fax: "fax",
  DirectDialIn: "direct-dial-in",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * Specifies the category of the phone number, such as 'mobile', 'home', or 'work'. This helps in identifying the context in which the phone number is used, enhancing user contact management within the CRM.
 */
export type CreateUserRequestPhoneNumbersType = ClosedEnum<
  typeof CreateUserRequestPhoneNumbersType
>;

export type CreateUserRequestPhoneNumbers = {
  /**
   * A unique identifier for the phone number entry within the user's contact information. This ID is used to distinguish between multiple phone numbers associated with a single user, ensuring accurate updates and retrievals. It should be a valid UUID string if provided.
   */
  id?: string | null | undefined;
  /**
   * The international dialing code for the phone number, such as '+1' for the United States. This code is essential for making international calls and should be included if the phone number is intended for global use. It must be a valid country code prefixed with a '+' sign.
   */
  countryCode?: string | null | undefined;
  /**
   * The regional area code that specifies the geographic region of the phone number, like '323' for Los Angeles. This code helps in routing calls to the correct local exchange and should be provided if applicable. It must be a valid area code without any leading zeros.
   */
  areaCode?: string | null | undefined;
  /**
   * The main phone number associated with the user, excluding any country or area codes. This number is crucial for direct contact and must be provided in a valid local format. Ensure it contains only digits and is free from spaces or special characters.
   */
  number: string;
  /**
   * An optional extension number used to direct calls to a specific department or individual within an organization. This is particularly useful in corporate environments where a single main number serves multiple endpoints. It should be numeric and can include up to five digits.
   */
  extension?: string | null | undefined;
  /**
   * Specifies the category of the phone number, such as 'mobile', 'home', or 'work'. This helps in identifying the context in which the phone number is used, enhancing user contact management within the CRM.
   */
  type?: CreateUserRequestPhoneNumbersType | null | undefined;
};

/**
 * Defines the nature of the email address, such as 'personal' or 'work'. This classification aids in organizing and prioritizing communications based on the email type.
 */
export const CreateUserRequestEmailsType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Defines the nature of the email address, such as 'personal' or 'work'. This classification aids in organizing and prioritizing communications based on the email type.
 */
export type CreateUserRequestEmailsType = ClosedEnum<
  typeof CreateUserRequestEmailsType
>;

export type CreateUserRequestEmails = {
  /**
   * A unique identifier for each email address object. This ID is used to distinguish between different email entries, facilitating updates and management of user email information.
   */
  id?: string | null | undefined;
  /**
   * The actual email address of the user. This field is mandatory and must be a valid email format, as it is crucial for user identification and communication within the CRM system.
   */
  email: string | null;
  /**
   * Defines the nature of the email address, such as 'personal' or 'work'. This classification aids in organizing and prioritizing communications based on the email type.
   */
  type?: CreateUserRequestEmailsType | null | undefined;
};

export type CreateUserRequestExtendPaths = {
  /**
   * Specifies the JSONPath string where the value should be applied within the user's data structure. This path must be a valid JSONPath expression, ensuring precise targeting of the data field to be updated or added. It is crucial for directing the operation to the correct location in the CRM's user data model.
   */
  path: string;
  /**
   * Defines the value to be set at the specified JSONPath within the user's data structure. This value can be of any data type, allowing flexibility in the kind of data that can be added or updated. It is essential for customizing user data fields according to specific application needs.
   */
  value?: any | undefined;
};

export type CreateUserRequestPassThrough = {
  /**
   * A mandatory string that specifies the service identifier to which the pass_through data should be applied. This ensures that the custom data is directed to the correct service, facilitating precise integration and operation within the CRM.
   */
  serviceId: string;
  /**
   * An optional string that identifies a specific workflow operation for which the pass_through data is intended. This is particularly useful for Unify calls that involve multiple downstream requests, allowing for targeted data application.
   */
  operationId?: string | undefined;
  /**
   * An optional object that allows for direct extension with any properties, enabling developers to include additional data fields as needed. This flexibility supports complex data structures and custom requirements in user management operations.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An optional array of objects designed for structured data modifications using paths. This feature allows developers to specify precise changes to data structures, enhancing the customization and flexibility of user-related requests.
   */
  extendPaths?: Array<CreateUserRequestExtendPaths> | undefined;
};

export type CreateUserRequest = {
  /**
   * The parent user ID associated with the new user being added. This is used to establish a hierarchical relationship within the CRM, linking the new user to an existing parent user. If applicable, ensure the ID corresponds to a valid user already present in the system.
   */
  parentId?: string | null | undefined;
  /**
   * The unique username assigned to the new user for login and identification purposes. It should be a non-empty string and must be unique within the CRM system to prevent conflicts. This username will be used for authentication and user management tasks.
   */
  username?: string | null | undefined;
  /**
   * The first name of the user being added to the CRM. This field is used for personal identification and communication purposes within the system. Ensure the name is correctly spelled as it will appear in user profiles and communications.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the user being added to the CRM. It complements the first name for full identification and is used in user profiles and official communications. Accurate spelling is important for consistency and professionalism.
   */
  lastName?: string | null | undefined;
  /**
   * The professional job title of the user within the organization. This field helps in defining the user's role and responsibilities in the CRM system. Ensure the title accurately reflects the user's position for clarity in organizational hierarchy and communication.
   */
  title?: string | null | undefined;
  /**
   * Specifies the division within the organization where the user is currently assigned. This can represent a collection of departments, teams, or regions. It helps categorize the user within the CRM system for better organizational management. This field is optional and can be left empty if not applicable.
   */
  division?: string | null | undefined;
  /**
   * Indicates the department where the user is currently working. This field is deprecated in favor of using 'department_id' and 'department_name' for more precise identification. It is optional and should be used only if the new fields are not available.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  department?: string | null | undefined;
  /**
   * Represents the name of the company associated with the user. This field is optional and should be a valid string that accurately reflects the company's official name. It is used to link the user to their respective organization within the CRM.
   */
  companyName?: string | null | undefined;
  /**
   * A unique identifier assigned to the user within the company, such as an Employee Number, ID, or Code. This optional field helps in uniquely identifying and managing the user within the CRM system. It should be a string that follows the company's internal format for employee identifiers.
   */
  employeeNumber?: string | null | undefined;
  /**
   * Provides additional information or context about the user being added. This optional field can include any relevant details that help describe the user's role or position within the company. It should be a concise string that enhances the user's profile in the CRM.
   */
  description?: string | null | undefined;
  /**
   * The URL of the user's avatar image. This property allows you to associate a visual representation with the user profile, enhancing user identification within the CRM. The URL must be a valid string format, pointing to an accessible image resource.
   */
  image?: string | null | undefined;
  /**
   * The preferred language code for the user, following the ISO 639-1 standard (e.g., 'EN' for English). This setting helps tailor the user experience by displaying content in the user's preferred language, if supported by the CRM system.
   */
  language?: string | null | undefined;
  /**
   * The current status of the user within the CRM system, such as 'active', 'inactive', or 'pending'. This property is crucial for managing user access and permissions, ensuring that only users with the appropriate status can interact with the system.
   */
  status?: string | null | undefined;
  /**
   * The password for the user account, used for authentication purposes. It should be a secure string that complies with the system's password policy, ensuring the user's account is protected against unauthorized access.
   */
  password?: string | null | undefined;
  /**
   * A list of addresses associated with the user, which may include home, work, or other relevant locations. Each address should be structured according to the CRM's address format, providing comprehensive location details for the user.
   */
  addresses?: Array<CreateUserRequestAddresses> | undefined;
  /**
   * A list of phone numbers associated with the user. Each entry in the array should be a valid phone number format, allowing multiple contact numbers to be stored. This property is optional but enhances the user's contact information within the CRM.
   */
  phoneNumbers?: Array<CreateUserRequestPhoneNumbers> | undefined;
  /**
   * A collection of email objects associated with the user. Each object must contain at least an 'email' field, ensuring that the user has one or more valid email addresses for communication purposes.
   */
  emails: Array<CreateUserRequestEmails>;
  /**
   * An optional array that allows developers to include service-specific custom data or modifications when adding or updating a user. This property is useful for tailoring requests to meet specific service requirements or workflows within the CRM system.
   */
  passThrough?: Array<CreateUserRequestPassThrough> | undefined;
};

/** @internal */
export const CreateUserRequestType$inboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestType
> = z.nativeEnum(CreateUserRequestType);

/** @internal */
export const CreateUserRequestType$outboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestType
> = CreateUserRequestType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestType$ {
  /** @deprecated use `CreateUserRequestType$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestType$inboundSchema;
  /** @deprecated use `CreateUserRequestType$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestType$outboundSchema;
}

/** @internal */
export const CreateUserRequestAddresses$inboundSchema: z.ZodType<
  CreateUserRequestAddresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CreateUserRequestType$inboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  street_number: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postal_code: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contact_name: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phone_number: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  row_version: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "street_number": "streetNumber",
    "postal_code": "postalCode",
    "contact_name": "contactName",
    "phone_number": "phoneNumber",
    "row_version": "rowVersion",
  });
});

/** @internal */
export type CreateUserRequestAddresses$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
  string?: string | null | undefined;
  name?: string | null | undefined;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  line3?: string | null | undefined;
  line4?: string | null | undefined;
  street_number?: string | null | undefined;
  city?: string | null | undefined;
  state?: string | null | undefined;
  postal_code?: string | null | undefined;
  country?: string | null | undefined;
  latitude?: string | null | undefined;
  longitude?: string | null | undefined;
  county?: string | null | undefined;
  contact_name?: string | null | undefined;
  salutation?: string | null | undefined;
  phone_number?: string | null | undefined;
  fax?: string | null | undefined;
  email?: string | null | undefined;
  website?: string | null | undefined;
  notes?: string | null | undefined;
  row_version?: string | null | undefined;
};

/** @internal */
export const CreateUserRequestAddresses$outboundSchema: z.ZodType<
  CreateUserRequestAddresses$Outbound,
  z.ZodTypeDef,
  CreateUserRequestAddresses
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CreateUserRequestType$outboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  streetNumber: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contactName: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phoneNumber: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  rowVersion: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    streetNumber: "street_number",
    postalCode: "postal_code",
    contactName: "contact_name",
    phoneNumber: "phone_number",
    rowVersion: "row_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestAddresses$ {
  /** @deprecated use `CreateUserRequestAddresses$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestAddresses$inboundSchema;
  /** @deprecated use `CreateUserRequestAddresses$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestAddresses$outboundSchema;
  /** @deprecated use `CreateUserRequestAddresses$Outbound` instead. */
  export type Outbound = CreateUserRequestAddresses$Outbound;
}

export function createUserRequestAddressesToJSON(
  createUserRequestAddresses: CreateUserRequestAddresses,
): string {
  return JSON.stringify(
    CreateUserRequestAddresses$outboundSchema.parse(createUserRequestAddresses),
  );
}

export function createUserRequestAddressesFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestAddresses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequestAddresses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestAddresses' from JSON`,
  );
}

/** @internal */
export const CreateUserRequestPhoneNumbersType$inboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestPhoneNumbersType
> = z.nativeEnum(CreateUserRequestPhoneNumbersType);

/** @internal */
export const CreateUserRequestPhoneNumbersType$outboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestPhoneNumbersType
> = CreateUserRequestPhoneNumbersType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestPhoneNumbersType$ {
  /** @deprecated use `CreateUserRequestPhoneNumbersType$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestPhoneNumbersType$inboundSchema;
  /** @deprecated use `CreateUserRequestPhoneNumbersType$outboundSchema` instead. */
  export const outboundSchema =
    CreateUserRequestPhoneNumbersType$outboundSchema;
}

/** @internal */
export const CreateUserRequestPhoneNumbers$inboundSchema: z.ZodType<
  CreateUserRequestPhoneNumbers,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  country_code: z.nullable(z.string()).optional(),
  area_code: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(CreateUserRequestPhoneNumbersType$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "country_code": "countryCode",
    "area_code": "areaCode",
  });
});

/** @internal */
export type CreateUserRequestPhoneNumbers$Outbound = {
  id?: string | null | undefined;
  country_code?: string | null | undefined;
  area_code?: string | null | undefined;
  number: string;
  extension?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const CreateUserRequestPhoneNumbers$outboundSchema: z.ZodType<
  CreateUserRequestPhoneNumbers$Outbound,
  z.ZodTypeDef,
  CreateUserRequestPhoneNumbers
> = z.object({
  id: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  areaCode: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(CreateUserRequestPhoneNumbersType$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    countryCode: "country_code",
    areaCode: "area_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestPhoneNumbers$ {
  /** @deprecated use `CreateUserRequestPhoneNumbers$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestPhoneNumbers$inboundSchema;
  /** @deprecated use `CreateUserRequestPhoneNumbers$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestPhoneNumbers$outboundSchema;
  /** @deprecated use `CreateUserRequestPhoneNumbers$Outbound` instead. */
  export type Outbound = CreateUserRequestPhoneNumbers$Outbound;
}

export function createUserRequestPhoneNumbersToJSON(
  createUserRequestPhoneNumbers: CreateUserRequestPhoneNumbers,
): string {
  return JSON.stringify(
    CreateUserRequestPhoneNumbers$outboundSchema.parse(
      createUserRequestPhoneNumbers,
    ),
  );
}

export function createUserRequestPhoneNumbersFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestPhoneNumbers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequestPhoneNumbers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestPhoneNumbers' from JSON`,
  );
}

/** @internal */
export const CreateUserRequestEmailsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestEmailsType
> = z.nativeEnum(CreateUserRequestEmailsType);

/** @internal */
export const CreateUserRequestEmailsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateUserRequestEmailsType
> = CreateUserRequestEmailsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestEmailsType$ {
  /** @deprecated use `CreateUserRequestEmailsType$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestEmailsType$inboundSchema;
  /** @deprecated use `CreateUserRequestEmailsType$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestEmailsType$outboundSchema;
}

/** @internal */
export const CreateUserRequestEmails$inboundSchema: z.ZodType<
  CreateUserRequestEmails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(CreateUserRequestEmailsType$inboundSchema).optional(),
});

/** @internal */
export type CreateUserRequestEmails$Outbound = {
  id?: string | null | undefined;
  email: string | null;
  type?: string | null | undefined;
};

/** @internal */
export const CreateUserRequestEmails$outboundSchema: z.ZodType<
  CreateUserRequestEmails$Outbound,
  z.ZodTypeDef,
  CreateUserRequestEmails
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(CreateUserRequestEmailsType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestEmails$ {
  /** @deprecated use `CreateUserRequestEmails$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestEmails$inboundSchema;
  /** @deprecated use `CreateUserRequestEmails$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestEmails$outboundSchema;
  /** @deprecated use `CreateUserRequestEmails$Outbound` instead. */
  export type Outbound = CreateUserRequestEmails$Outbound;
}

export function createUserRequestEmailsToJSON(
  createUserRequestEmails: CreateUserRequestEmails,
): string {
  return JSON.stringify(
    CreateUserRequestEmails$outboundSchema.parse(createUserRequestEmails),
  );
}

export function createUserRequestEmailsFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestEmails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequestEmails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestEmails' from JSON`,
  );
}

/** @internal */
export const CreateUserRequestExtendPaths$inboundSchema: z.ZodType<
  CreateUserRequestExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type CreateUserRequestExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const CreateUserRequestExtendPaths$outboundSchema: z.ZodType<
  CreateUserRequestExtendPaths$Outbound,
  z.ZodTypeDef,
  CreateUserRequestExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestExtendPaths$ {
  /** @deprecated use `CreateUserRequestExtendPaths$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestExtendPaths$inboundSchema;
  /** @deprecated use `CreateUserRequestExtendPaths$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestExtendPaths$outboundSchema;
  /** @deprecated use `CreateUserRequestExtendPaths$Outbound` instead. */
  export type Outbound = CreateUserRequestExtendPaths$Outbound;
}

export function createUserRequestExtendPathsToJSON(
  createUserRequestExtendPaths: CreateUserRequestExtendPaths,
): string {
  return JSON.stringify(
    CreateUserRequestExtendPaths$outboundSchema.parse(
      createUserRequestExtendPaths,
    ),
  );
}

export function createUserRequestExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequestExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestExtendPaths' from JSON`,
  );
}

/** @internal */
export const CreateUserRequestPassThrough$inboundSchema: z.ZodType<
  CreateUserRequestPassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => CreateUserRequestExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type CreateUserRequestPassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<CreateUserRequestExtendPaths$Outbound> | undefined;
};

/** @internal */
export const CreateUserRequestPassThrough$outboundSchema: z.ZodType<
  CreateUserRequestPassThrough$Outbound,
  z.ZodTypeDef,
  CreateUserRequestPassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => CreateUserRequestExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestPassThrough$ {
  /** @deprecated use `CreateUserRequestPassThrough$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestPassThrough$inboundSchema;
  /** @deprecated use `CreateUserRequestPassThrough$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestPassThrough$outboundSchema;
  /** @deprecated use `CreateUserRequestPassThrough$Outbound` instead. */
  export type Outbound = CreateUserRequestPassThrough$Outbound;
}

export function createUserRequestPassThroughToJSON(
  createUserRequestPassThrough: CreateUserRequestPassThrough,
): string {
  return JSON.stringify(
    CreateUserRequestPassThrough$outboundSchema.parse(
      createUserRequestPassThrough,
    ),
  );
}

export function createUserRequestPassThroughFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestPassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequestPassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestPassThrough' from JSON`,
  );
}

/** @internal */
export const CreateUserRequest$inboundSchema: z.ZodType<
  CreateUserRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  parent_id: z.nullable(z.string()).optional(),
  username: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  division: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  company_name: z.nullable(z.string()).optional(),
  employee_number: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  password: z.nullable(z.string()).optional(),
  addresses: z.array(z.lazy(() => CreateUserRequestAddresses$inboundSchema))
    .optional(),
  phone_numbers: z.array(
    z.lazy(() => CreateUserRequestPhoneNumbers$inboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => CreateUserRequestEmails$inboundSchema)),
  pass_through: z.array(
    z.lazy(() => CreateUserRequestPassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "parent_id": "parentId",
    "first_name": "firstName",
    "last_name": "lastName",
    "company_name": "companyName",
    "employee_number": "employeeNumber",
    "phone_numbers": "phoneNumbers",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type CreateUserRequest$Outbound = {
  parent_id?: string | null | undefined;
  username?: string | null | undefined;
  first_name?: string | null | undefined;
  last_name?: string | null | undefined;
  title?: string | null | undefined;
  division?: string | null | undefined;
  department?: string | null | undefined;
  company_name?: string | null | undefined;
  employee_number?: string | null | undefined;
  description?: string | null | undefined;
  image?: string | null | undefined;
  language?: string | null | undefined;
  status?: string | null | undefined;
  password?: string | null | undefined;
  addresses?: Array<CreateUserRequestAddresses$Outbound> | undefined;
  phone_numbers?: Array<CreateUserRequestPhoneNumbers$Outbound> | undefined;
  emails: Array<CreateUserRequestEmails$Outbound>;
  pass_through?: Array<CreateUserRequestPassThrough$Outbound> | undefined;
};

/** @internal */
export const CreateUserRequest$outboundSchema: z.ZodType<
  CreateUserRequest$Outbound,
  z.ZodTypeDef,
  CreateUserRequest
> = z.object({
  parentId: z.nullable(z.string()).optional(),
  username: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  division: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  companyName: z.nullable(z.string()).optional(),
  employeeNumber: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  password: z.nullable(z.string()).optional(),
  addresses: z.array(z.lazy(() => CreateUserRequestAddresses$outboundSchema))
    .optional(),
  phoneNumbers: z.array(
    z.lazy(() => CreateUserRequestPhoneNumbers$outboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => CreateUserRequestEmails$outboundSchema)),
  passThrough: z.array(
    z.lazy(() => CreateUserRequestPassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    parentId: "parent_id",
    firstName: "first_name",
    lastName: "last_name",
    companyName: "company_name",
    employeeNumber: "employee_number",
    phoneNumbers: "phone_numbers",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequest$ {
  /** @deprecated use `CreateUserRequest$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequest$inboundSchema;
  /** @deprecated use `CreateUserRequest$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequest$outboundSchema;
  /** @deprecated use `CreateUserRequest$Outbound` instead. */
  export type Outbound = CreateUserRequest$Outbound;
}

export function createUserRequestToJSON(
  createUserRequest: CreateUserRequest,
): string {
  return JSON.stringify(
    CreateUserRequest$outboundSchema.parse(createUserRequest),
  );
}

export function createUserRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUserRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequest' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * This object contains any custom mappings that have been configured for the note resource. Custom mappings allow for additional, user-defined fields to be associated with the note, providing flexibility to adapt the CRM to specific business needs. This property is included when such mappings are present, enabling users to extend the standard note functionality with custom attributes that can capture unique business data. This is particularly useful in scenarios where standard fields do not fully capture the required information, allowing for a more tailored CRM experience.
 */
export type NotesListResponseCustomMappings = {};

export type NotesListResponseExtendPaths = {
  /**
   * A JSONPath string that specifies the exact location within the user record where the value should be applied. This is essential for making precise updates to nested fields, ensuring that changes are made only to the intended parts of the data structure. The path must be valid and correspond to an existing field within the user record.
   */
  path: string;
  /**
   * This property represents the specific value that you wish to assign to a designated path within the user record. It can be of any data type, such as a string, number, boolean, or object, depending on the field being updated. The flexibility of this property allows for a wide range of updates, from simple text changes to complex data structures. In the context of the `usersUpdate` operation, this property is crucial for specifying the exact data modification you intend to make, ensuring that only the targeted fields are altered without affecting other data. Proper validation should be applied to ensure the value is compatible with the field's expected data type and business rules. Common use cases include updating user contact information, preferences, or custom attributes specific to your CRM's schema.
   */
  value?: any | undefined;
};

export type NotesListResponsePassThrough = {
  /**
   * The unique identifier for the specific service to which this pass_through should be applied. This is crucial for directing the update operation to the correct service within the CRM system, ensuring that the modifications are executed in the appropriate context. It must be a valid service ID that corresponds to an active service integration, and it is required for the operation to proceed.
   */
  serviceId: string;
  /**
   * An optional identifier for a specific workflow operation within the CRM system to which this pass_through should be applied. This is particularly useful for Unify calls that involve multiple downstream requests, allowing for precise targeting and execution of specific operations. If provided, it should match an existing operation ID to ensure correct processing.
   */
  operationId?: string | undefined;
  /**
   * A flexible object that allows for the inclusion of any additional properties needed for direct extension of the user record. This can be used to add custom fields or metadata that are not part of the standard user schema, providing a way to tailor the user data to specific business needs. The structure of this object should align with the CRM's data model to ensure compatibility.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects designed for structured data modifications via specified paths. This allows for precise updates to nested data structures within the user record, enabling complex modifications without altering unrelated data. Each object in the array should define a clear path and value to be applied, ensuring targeted updates.
   */
  extendPaths?: Array<NotesListResponseExtendPaths> | undefined;
};

export type NotesListResponseData = {
  /**
   * The unique identifier of the note. This ID is crucial for locating the specific note within the CRM system that you wish to update. It must be a valid, pre-existing identifier, as the operation will fail if the note does not exist. Typically, this ID is generated by the system when the note is created and is immutable.
   */
  id?: string | undefined;
  /**
   * The title of the note. This serves as a brief summary or headline for the note's content, helping users quickly identify the note's subject matter. While not required, providing a clear and descriptive title can enhance searchability and organization within the CRM.
   */
  title?: string | null | undefined;
  /**
   * The content of the note. This field contains the main body of text for the note, where detailed information is recorded. It supports rich text formatting, allowing for a structured and readable presentation of information. Updating this field is essential when the note's details need to be revised or expanded.
   */
  content?: string | null | undefined;
  /**
   * The user that owns the note. This identifier links the note to a specific user within the CRM, typically the person responsible for the note's content. It is important for tracking accountability and managing access permissions. The owner ID should correspond to a valid user ID in the system.
   */
  ownerId?: string | null | undefined;
  /**
   * The contact that is related to the note. This field associates the note with a specific contact in the CRM, providing context and relevance to the note's content. It is particularly useful for notes that document interactions or information pertinent to a particular contact. Ensure this ID matches an existing contact ID in the CRM.
   */
  contactId?: string | null | undefined;
  /**
   * This field represents the unique identifier of the company associated with the note. It is used to link the note to a specific company within the CRM system, providing context and relevance to the note's content. While not mandatory, including this ID ensures that the note is correctly categorized under the appropriate company, facilitating better organization and retrieval of notes related to company activities. This is particularly useful in scenarios where notes are used to track interactions or updates related to specific companies.
   */
  companyId?: string | null | undefined;
  /**
   * This property holds the unique identifier for the opportunity linked to the note. It serves to associate the note with a particular sales opportunity within the CRM, thereby enhancing the note's relevance and context. Although optional, providing this ID helps in tracking the progress and updates related to specific opportunities, making it easier for sales teams to access all pertinent information in one place. This is especially beneficial in managing sales pipelines and ensuring that all notes are aligned with ongoing opportunities.
   */
  opportunityId?: string | null | undefined;
  /**
   * This attribute specifies the unique identifier for the lead associated with the note. It is used to connect the note to a particular lead in the CRM, adding context and specificity to the note's content. While not required, including this ID can significantly aid in organizing notes by lead, which is crucial for tracking interactions and follow-ups with potential clients. This is particularly important in lead management processes where maintaining detailed records of communications and updates is essential for conversion efforts.
   */
  leadId?: string | null | undefined;
  /**
   * This boolean field indicates whether the note is currently active. An active note is one that is considered relevant and up-to-date, whereas an inactive note might be archived or no longer applicable. This property is useful for filtering notes based on their current status, allowing users to focus on notes that are pertinent to ongoing activities or discussions. It is particularly valuable in maintaining an organized and efficient note management system within the CRM.
   */
  active?: boolean | null | undefined;
  /**
   * This object contains any custom mappings that have been configured for the note resource. Custom mappings allow for additional, user-defined fields to be associated with the note, providing flexibility to adapt the CRM to specific business needs. This property is included when such mappings are present, enabling users to extend the standard note functionality with custom attributes that can capture unique business data. This is particularly useful in scenarios where standard fields do not fully capture the required information, allowing for a more tailored CRM experience.
   */
  customMappings?: NotesListResponseCustomMappings | null | undefined;
  /**
   * The identifier of the user who last modified the note. This field is crucial for tracking changes and maintaining an audit trail within the CRM system. It helps in identifying who made the last update, which is essential for accountability and historical reference. Typically, this would be a user ID or username that corresponds to a valid user in the system.
   */
  updatedBy?: string | null | undefined;
  /**
   * The identifier of the user who originally created the note. This information is important for understanding the origin of the note and for maintaining a complete historical record. It allows users to trace back to the creator for any clarifications or context regarding the note's initial content. This should be a valid user ID or username within the CRM system.
   */
  createdBy?: string | null | undefined;
  /**
   * The timestamp indicating when the note was last updated. This field is formatted in ISO 8601 and is vital for tracking the recency of changes. It helps users understand how current the note's information is and can be used to resolve conflicts in concurrent updates. This timestamp should reflect the exact time of the last modification in UTC.
   */
  updatedAt?: string | null | undefined;
  /**
   * The timestamp indicating when the note was originally created. This field, formatted in ISO 8601, provides a historical reference point for the note's existence. It is useful for chronological sorting and understanding the timeline of interactions related to the note. This timestamp should accurately reflect the creation time in UTC.
   */
  createdAt?: string | null | undefined;
  /**
   * An array that allows the inclusion of service-specific custom data or structured modifications when updating the note. This property is particularly useful for integrations that require additional metadata or configuration settings that are not covered by standard fields. It enables flexibility and extensibility in handling diverse CRM requirements. Each element in the array should conform to the expected structure defined by the target service.
   */
  passThrough?: Array<NotesListResponsePassThrough> | undefined;
};

/**
 * This property provides cursors that are used to navigate through paginated API responses, allowing clients to move to previous or next pages of data. It is included in the response when pagination is enabled, facilitating seamless data retrieval across multiple API calls. This ensures that applications can efficiently access large datasets without overwhelming the client or server.
 */
export type NotesListResponseCursors = {
  /**
   * The 'previous' cursor is a string token used to retrieve the preceding set of results in a paginated API response. It is included in the response when there are more results available before the current set, allowing clients to navigate backward through the data. This cursor is particularly useful in scenarios where users need to review or analyze data from earlier pages.
   */
  previous?: string | null | undefined;
  /**
   * The 'current' cursor is a string token representing the current position in the paginated list of results. It is included in the response to indicate the current page's starting point, helping clients maintain their place in the data sequence during navigation. This is essential for tracking the current dataset being viewed or processed.
   */
  current?: string | null | undefined;
  /**
   * The 'next' cursor is a string token that facilitates navigation to the subsequent set of results in a paginated API response. It is included when additional data is available beyond the current page, enabling clients to continue retrieving more results seamlessly. This is crucial for applications that need to process large datasets incrementally.
   */
  next?: string | null | undefined;
};

/**
 * This property contains metadata about the response, providing additional context and information about the data returned by the API. It may include details such as pagination information, request identifiers, or processing times. While not required, this metadata can be invaluable for debugging, logging, and optimizing data retrieval processes, offering insights into the API's operation and performance.
 */
export type NotesListResponseMeta = {
  /**
   * This property indicates the number of items that are included in the 'data' section of the response. It is particularly useful for understanding the volume of data returned in a single API call, especially when pagination is in use. This property is included in the response to help clients manage data processing and display, ensuring that applications can handle the data efficiently.
   */
  itemsOnPage?: number | undefined;
  /**
   * This property provides cursors that are used to navigate through paginated API responses, allowing clients to move to previous or next pages of data. It is included in the response when pagination is enabled, facilitating seamless data retrieval across multiple API calls. This ensures that applications can efficiently access large datasets without overwhelming the client or server.
   */
  cursors?: NotesListResponseCursors | undefined;
};

/**
 * An object containing hyperlinks that facilitate navigation to previous or next pages within the API response. This property is included in paginated responses to provide direct access to adjacent pages, enhancing the user experience by simplifying the process of moving through large sets of data.
 */
export type NotesListResponseLinks = {
  /**
   * The 'previous' link is a URL string that directs clients to the previous page of results in the API. It is included when there are earlier pages available, allowing users to easily navigate back to review or access prior data. This link is essential for applications that support backward navigation through paginated datasets.
   */
  previous?: string | null | undefined;
  /**
   * This property provides a URL link that directs to the current page of the user list in the API response. It is particularly useful for applications implementing pagination, allowing them to easily reload or refresh the current set of user data. This link is included in the response when pagination is in use, ensuring that users can maintain their current position within the dataset when navigating through multiple pages of results.
   */
  current?: string | undefined;
  /**
   * This property contains a URL link that directs to the next page of the user list in the API response. It is essential for applications that need to handle large datasets by breaking them into manageable pages. This link is included when there are additional pages of user data available beyond the current page, facilitating seamless navigation through the complete list of users without manually constructing URLs.
   */
  next?: string | null | undefined;
};

/**
 * Notes
 */
export type NotesListResponse = {
  /**
   * The HTTP response status code returned by the server. This integer value indicates the result of the API request, with common codes including 200 for success, 404 for not found, and 500 for server error. It is always included in the response to inform the client of the request's outcome and is crucial for error handling and debugging.
   */
  statusCode: number;
  /**
   * A textual representation of the HTTP response status. This string provides a human-readable explanation of the status code, such as 'OK' for 200 or 'Not Found' for 404. It complements the status code by offering a more descriptive context, helping developers understand the result of their API request at a glance.
   */
  status: string;
  /**
   * The Apideck ID of the service provider that processed the request. This string uniquely identifies which service within the Apideck ecosystem handled the API call, especially useful in environments with multiple integrations. It is included to help track and manage service-specific requests and responses.
   */
  service: string;
  /**
   * The name of the unified API resource that was accessed. This string identifies the specific resource within the Apideck platform, such as 'notes' in this context, and is essential for understanding what data or functionality was targeted by the request. It helps in mapping the request to the appropriate resource in the API documentation.
   */
  resource: string;
  /**
   * The specific operation that was performed during the API request. This string indicates the action taken, such as 'retrieve' or 'update', and is crucial for logging and auditing purposes. It provides clarity on what the API call was intended to do, ensuring that the response aligns with the expected operation.
   */
  operation: string;
  /**
   * An array containing the list of notes retrieved from the CRM system. Each element in this array represents a single note object, which includes various details about the note such as its ID, title, content, and owner. This array is always included in the response to provide a structured collection of notes, facilitating easy access and manipulation of note data.
   */
  data: Array<NotesListResponseData>;
  /**
   * This property contains metadata about the response, providing additional context and information about the data returned by the API. It may include details such as pagination information, request identifiers, or processing times. While not required, this metadata can be invaluable for debugging, logging, and optimizing data retrieval processes, offering insights into the API's operation and performance.
   */
  meta?: NotesListResponseMeta | undefined;
  /**
   * An object containing hyperlinks that facilitate navigation to previous or next pages within the API response. This property is included in paginated responses to provide direct access to adjacent pages, enhancing the user experience by simplifying the process of moving through large sets of data.
   */
  links?: NotesListResponseLinks | undefined;
};

/** @internal */
export const NotesListResponseCustomMappings$inboundSchema: z.ZodType<
  NotesListResponseCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type NotesListResponseCustomMappings$Outbound = {};

/** @internal */
export const NotesListResponseCustomMappings$outboundSchema: z.ZodType<
  NotesListResponseCustomMappings$Outbound,
  z.ZodTypeDef,
  NotesListResponseCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesListResponseCustomMappings$ {
  /** @deprecated use `NotesListResponseCustomMappings$inboundSchema` instead. */
  export const inboundSchema = NotesListResponseCustomMappings$inboundSchema;
  /** @deprecated use `NotesListResponseCustomMappings$outboundSchema` instead. */
  export const outboundSchema = NotesListResponseCustomMappings$outboundSchema;
  /** @deprecated use `NotesListResponseCustomMappings$Outbound` instead. */
  export type Outbound = NotesListResponseCustomMappings$Outbound;
}

export function notesListResponseCustomMappingsToJSON(
  notesListResponseCustomMappings: NotesListResponseCustomMappings,
): string {
  return JSON.stringify(
    NotesListResponseCustomMappings$outboundSchema.parse(
      notesListResponseCustomMappings,
    ),
  );
}

export function notesListResponseCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<NotesListResponseCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesListResponseCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesListResponseCustomMappings' from JSON`,
  );
}

/** @internal */
export const NotesListResponseExtendPaths$inboundSchema: z.ZodType<
  NotesListResponseExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type NotesListResponseExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const NotesListResponseExtendPaths$outboundSchema: z.ZodType<
  NotesListResponseExtendPaths$Outbound,
  z.ZodTypeDef,
  NotesListResponseExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesListResponseExtendPaths$ {
  /** @deprecated use `NotesListResponseExtendPaths$inboundSchema` instead. */
  export const inboundSchema = NotesListResponseExtendPaths$inboundSchema;
  /** @deprecated use `NotesListResponseExtendPaths$outboundSchema` instead. */
  export const outboundSchema = NotesListResponseExtendPaths$outboundSchema;
  /** @deprecated use `NotesListResponseExtendPaths$Outbound` instead. */
  export type Outbound = NotesListResponseExtendPaths$Outbound;
}

export function notesListResponseExtendPathsToJSON(
  notesListResponseExtendPaths: NotesListResponseExtendPaths,
): string {
  return JSON.stringify(
    NotesListResponseExtendPaths$outboundSchema.parse(
      notesListResponseExtendPaths,
    ),
  );
}

export function notesListResponseExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<NotesListResponseExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesListResponseExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesListResponseExtendPaths' from JSON`,
  );
}

/** @internal */
export const NotesListResponsePassThrough$inboundSchema: z.ZodType<
  NotesListResponsePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => NotesListResponseExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type NotesListResponsePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<NotesListResponseExtendPaths$Outbound> | undefined;
};

/** @internal */
export const NotesListResponsePassThrough$outboundSchema: z.ZodType<
  NotesListResponsePassThrough$Outbound,
  z.ZodTypeDef,
  NotesListResponsePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => NotesListResponseExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesListResponsePassThrough$ {
  /** @deprecated use `NotesListResponsePassThrough$inboundSchema` instead. */
  export const inboundSchema = NotesListResponsePassThrough$inboundSchema;
  /** @deprecated use `NotesListResponsePassThrough$outboundSchema` instead. */
  export const outboundSchema = NotesListResponsePassThrough$outboundSchema;
  /** @deprecated use `NotesListResponsePassThrough$Outbound` instead. */
  export type Outbound = NotesListResponsePassThrough$Outbound;
}

export function notesListResponsePassThroughToJSON(
  notesListResponsePassThrough: NotesListResponsePassThrough,
): string {
  return JSON.stringify(
    NotesListResponsePassThrough$outboundSchema.parse(
      notesListResponsePassThrough,
    ),
  );
}

export function notesListResponsePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<NotesListResponsePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesListResponsePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesListResponsePassThrough' from JSON`,
  );
}

/** @internal */
export const NotesListResponseData$inboundSchema: z.ZodType<
  NotesListResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  owner_id: z.nullable(z.string()).optional(),
  contact_id: z.nullable(z.string()).optional(),
  company_id: z.nullable(z.string()).optional(),
  opportunity_id: z.nullable(z.string()).optional(),
  lead_id: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  custom_mappings: z.nullable(
    z.lazy(() => NotesListResponseCustomMappings$inboundSchema),
  ).optional(),
  updated_by: z.nullable(z.string()).optional(),
  created_by: z.nullable(z.string()).optional(),
  updated_at: z.nullable(z.string()).optional(),
  created_at: z.nullable(z.string()).optional(),
  pass_through: z.array(
    z.lazy(() => NotesListResponsePassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "contact_id": "contactId",
    "company_id": "companyId",
    "opportunity_id": "opportunityId",
    "lead_id": "leadId",
    "custom_mappings": "customMappings",
    "updated_by": "updatedBy",
    "created_by": "createdBy",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type NotesListResponseData$Outbound = {
  id?: string | undefined;
  title?: string | null | undefined;
  content?: string | null | undefined;
  owner_id?: string | null | undefined;
  contact_id?: string | null | undefined;
  company_id?: string | null | undefined;
  opportunity_id?: string | null | undefined;
  lead_id?: string | null | undefined;
  active?: boolean | null | undefined;
  custom_mappings?: NotesListResponseCustomMappings$Outbound | null | undefined;
  updated_by?: string | null | undefined;
  created_by?: string | null | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  pass_through?: Array<NotesListResponsePassThrough$Outbound> | undefined;
};

/** @internal */
export const NotesListResponseData$outboundSchema: z.ZodType<
  NotesListResponseData$Outbound,
  z.ZodTypeDef,
  NotesListResponseData
> = z.object({
  id: z.string().optional(),
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  ownerId: z.nullable(z.string()).optional(),
  contactId: z.nullable(z.string()).optional(),
  companyId: z.nullable(z.string()).optional(),
  opportunityId: z.nullable(z.string()).optional(),
  leadId: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  customMappings: z.nullable(
    z.lazy(() => NotesListResponseCustomMappings$outboundSchema),
  ).optional(),
  updatedBy: z.nullable(z.string()).optional(),
  createdBy: z.nullable(z.string()).optional(),
  updatedAt: z.nullable(z.string()).optional(),
  createdAt: z.nullable(z.string()).optional(),
  passThrough: z.array(
    z.lazy(() => NotesListResponsePassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    contactId: "contact_id",
    companyId: "company_id",
    opportunityId: "opportunity_id",
    leadId: "lead_id",
    customMappings: "custom_mappings",
    updatedBy: "updated_by",
    createdBy: "created_by",
    updatedAt: "updated_at",
    createdAt: "created_at",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesListResponseData$ {
  /** @deprecated use `NotesListResponseData$inboundSchema` instead. */
  export const inboundSchema = NotesListResponseData$inboundSchema;
  /** @deprecated use `NotesListResponseData$outboundSchema` instead. */
  export const outboundSchema = NotesListResponseData$outboundSchema;
  /** @deprecated use `NotesListResponseData$Outbound` instead. */
  export type Outbound = NotesListResponseData$Outbound;
}

export function notesListResponseDataToJSON(
  notesListResponseData: NotesListResponseData,
): string {
  return JSON.stringify(
    NotesListResponseData$outboundSchema.parse(notesListResponseData),
  );
}

export function notesListResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<NotesListResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesListResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesListResponseData' from JSON`,
  );
}

/** @internal */
export const NotesListResponseCursors$inboundSchema: z.ZodType<
  NotesListResponseCursors,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type NotesListResponseCursors$Outbound = {
  previous?: string | null | undefined;
  current?: string | null | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const NotesListResponseCursors$outboundSchema: z.ZodType<
  NotesListResponseCursors$Outbound,
  z.ZodTypeDef,
  NotesListResponseCursors
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesListResponseCursors$ {
  /** @deprecated use `NotesListResponseCursors$inboundSchema` instead. */
  export const inboundSchema = NotesListResponseCursors$inboundSchema;
  /** @deprecated use `NotesListResponseCursors$outboundSchema` instead. */
  export const outboundSchema = NotesListResponseCursors$outboundSchema;
  /** @deprecated use `NotesListResponseCursors$Outbound` instead. */
  export type Outbound = NotesListResponseCursors$Outbound;
}

export function notesListResponseCursorsToJSON(
  notesListResponseCursors: NotesListResponseCursors,
): string {
  return JSON.stringify(
    NotesListResponseCursors$outboundSchema.parse(notesListResponseCursors),
  );
}

export function notesListResponseCursorsFromJSON(
  jsonString: string,
): SafeParseResult<NotesListResponseCursors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesListResponseCursors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesListResponseCursors' from JSON`,
  );
}

/** @internal */
export const NotesListResponseMeta$inboundSchema: z.ZodType<
  NotesListResponseMeta,
  z.ZodTypeDef,
  unknown
> = z.object({
  items_on_page: z.number().int().optional(),
  cursors: z.lazy(() => NotesListResponseCursors$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "items_on_page": "itemsOnPage",
  });
});

/** @internal */
export type NotesListResponseMeta$Outbound = {
  items_on_page?: number | undefined;
  cursors?: NotesListResponseCursors$Outbound | undefined;
};

/** @internal */
export const NotesListResponseMeta$outboundSchema: z.ZodType<
  NotesListResponseMeta$Outbound,
  z.ZodTypeDef,
  NotesListResponseMeta
> = z.object({
  itemsOnPage: z.number().int().optional(),
  cursors: z.lazy(() => NotesListResponseCursors$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    itemsOnPage: "items_on_page",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesListResponseMeta$ {
  /** @deprecated use `NotesListResponseMeta$inboundSchema` instead. */
  export const inboundSchema = NotesListResponseMeta$inboundSchema;
  /** @deprecated use `NotesListResponseMeta$outboundSchema` instead. */
  export const outboundSchema = NotesListResponseMeta$outboundSchema;
  /** @deprecated use `NotesListResponseMeta$Outbound` instead. */
  export type Outbound = NotesListResponseMeta$Outbound;
}

export function notesListResponseMetaToJSON(
  notesListResponseMeta: NotesListResponseMeta,
): string {
  return JSON.stringify(
    NotesListResponseMeta$outboundSchema.parse(notesListResponseMeta),
  );
}

export function notesListResponseMetaFromJSON(
  jsonString: string,
): SafeParseResult<NotesListResponseMeta, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesListResponseMeta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesListResponseMeta' from JSON`,
  );
}

/** @internal */
export const NotesListResponseLinks$inboundSchema: z.ZodType<
  NotesListResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type NotesListResponseLinks$Outbound = {
  previous?: string | null | undefined;
  current?: string | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const NotesListResponseLinks$outboundSchema: z.ZodType<
  NotesListResponseLinks$Outbound,
  z.ZodTypeDef,
  NotesListResponseLinks
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesListResponseLinks$ {
  /** @deprecated use `NotesListResponseLinks$inboundSchema` instead. */
  export const inboundSchema = NotesListResponseLinks$inboundSchema;
  /** @deprecated use `NotesListResponseLinks$outboundSchema` instead. */
  export const outboundSchema = NotesListResponseLinks$outboundSchema;
  /** @deprecated use `NotesListResponseLinks$Outbound` instead. */
  export type Outbound = NotesListResponseLinks$Outbound;
}

export function notesListResponseLinksToJSON(
  notesListResponseLinks: NotesListResponseLinks,
): string {
  return JSON.stringify(
    NotesListResponseLinks$outboundSchema.parse(notesListResponseLinks),
  );
}

export function notesListResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<NotesListResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesListResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesListResponseLinks' from JSON`,
  );
}

/** @internal */
export const NotesListResponse$inboundSchema: z.ZodType<
  NotesListResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => NotesListResponseData$inboundSchema)),
  meta: z.lazy(() => NotesListResponseMeta$inboundSchema).optional(),
  links: z.lazy(() => NotesListResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type NotesListResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: Array<NotesListResponseData$Outbound>;
  meta?: NotesListResponseMeta$Outbound | undefined;
  links?: NotesListResponseLinks$Outbound | undefined;
};

/** @internal */
export const NotesListResponse$outboundSchema: z.ZodType<
  NotesListResponse$Outbound,
  z.ZodTypeDef,
  NotesListResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => NotesListResponseData$outboundSchema)),
  meta: z.lazy(() => NotesListResponseMeta$outboundSchema).optional(),
  links: z.lazy(() => NotesListResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotesListResponse$ {
  /** @deprecated use `NotesListResponse$inboundSchema` instead. */
  export const inboundSchema = NotesListResponse$inboundSchema;
  /** @deprecated use `NotesListResponse$outboundSchema` instead. */
  export const outboundSchema = NotesListResponse$outboundSchema;
  /** @deprecated use `NotesListResponse$Outbound` instead. */
  export type Outbound = NotesListResponse$Outbound;
}

export function notesListResponseToJSON(
  notesListResponse: NotesListResponse,
): string {
  return JSON.stringify(
    NotesListResponse$outboundSchema.parse(notesListResponse),
  );
}

export function notesListResponseFromJSON(
  jsonString: string,
): SafeParseResult<NotesListResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotesListResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotesListResponse' from JSON`,
  );
}

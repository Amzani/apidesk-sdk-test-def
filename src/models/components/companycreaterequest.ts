/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { RFCDate } from "../../types/rfcdate.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Specifies the currency in which the company's financial transactions are conducted, adhering to the ISO 4217 standard. This field is important for financial consistency and reporting, especially for companies operating in multiple countries. It ensures that monetary values are accurately represented and understood across different regions.
 */
export const Currency = {
  UnknownCurrency: "UNKNOWN_CURRENCY",
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Bov: "BOV",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Che: "CHE",
  Chf: "CHF",
  Chw: "CHW",
  Clf: "CLF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Cou: "COU",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Ltl: "LTL",
  Lvl: "LVL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Mxv: "MXV",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Srd: "SRD",
  Ssp: "SSP",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Trc: "TRC",
  Try: "TRY",
  Ttd: "TTD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Usn: "USN",
  Uss: "USS",
  Uyi: "UYI",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xag: "XAG",
  Xau: "XAU",
  Xba: "XBA",
  Xbb: "XBB",
  Xbc: "XBC",
  Xbd: "XBD",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpd: "XPD",
  Xpf: "XPF",
  Xpt: "XPT",
  Xts: "XTS",
  Xxx: "XXX",
  Yer: "YER",
  Zar: "ZAR",
  Zmk: "ZMK",
  Zmw: "ZMW",
  Btc: "BTC",
  Eth: "ETH",
} as const;
/**
 * Specifies the currency in which the company's financial transactions are conducted, adhering to the ISO 4217 standard. This field is important for financial consistency and reporting, especially for companies operating in multiple countries. It ensures that monetary values are accurately represented and understood across different regions.
 */
export type Currency = ClosedEnum<typeof Currency>;

/**
 * Specifies the category of the bank account, such as 'savings', 'checking', or 'business'. This information is important for determining the nature of transactions that can be performed and may affect transaction limits and fees. Understanding the account type helps in aligning the company's financial operations with its banking capabilities.
 */
export const AccountType = {
  BankAccount: "bank_account",
  CreditCard: "credit_card",
  Other: "other",
} as const;
/**
 * Specifies the category of the bank account, such as 'savings', 'checking', or 'business'. This information is important for determining the nature of transactions that can be performed and may affect transaction limits and fees. Understanding the account type helps in aligning the company's financial operations with its banking capabilities.
 */
export type AccountType = ClosedEnum<typeof AccountType>;

/**
 * This property specifies the currency associated with the company's bank account, using the standardized codes defined by ISO 4217. When updating a company's financial information, specifying the correct currency is crucial for ensuring that all monetary transactions are recorded and processed in the appropriate currency. This is especially important for companies dealing with international clients or operating in multiple countries, as it helps in maintaining accurate financial records and avoiding currency conversion errors. While not mandatory, providing the currency code can enhance the clarity and precision of financial data management within the CRM.
 */
export const CompanyCreateRequestCurrency = {
  UnknownCurrency: "UNKNOWN_CURRENCY",
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Bov: "BOV",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Che: "CHE",
  Chf: "CHF",
  Chw: "CHW",
  Clf: "CLF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Cou: "COU",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Ltl: "LTL",
  Lvl: "LVL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Mxv: "MXV",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Srd: "SRD",
  Ssp: "SSP",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Trc: "TRC",
  Try: "TRY",
  Ttd: "TTD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Usn: "USN",
  Uss: "USS",
  Uyi: "UYI",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xag: "XAG",
  Xau: "XAU",
  Xba: "XBA",
  Xbb: "XBB",
  Xbc: "XBC",
  Xbd: "XBD",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpd: "XPD",
  Xpf: "XPF",
  Xpt: "XPT",
  Xts: "XTS",
  Xxx: "XXX",
  Yer: "YER",
  Zar: "ZAR",
  Zmk: "ZMK",
  Zmw: "ZMW",
  Btc: "BTC",
  Eth: "ETH",
} as const;
/**
 * This property specifies the currency associated with the company's bank account, using the standardized codes defined by ISO 4217. When updating a company's financial information, specifying the correct currency is crucial for ensuring that all monetary transactions are recorded and processed in the appropriate currency. This is especially important for companies dealing with international clients or operating in multiple countries, as it helps in maintaining accurate financial records and avoiding currency conversion errors. While not mandatory, providing the currency code can enhance the clarity and precision of financial data management within the CRM.
 */
export type CompanyCreateRequestCurrency = ClosedEnum<
  typeof CompanyCreateRequestCurrency
>;

export type BankAccounts = {
  /**
   * The name of the bank where the company's account is held. This field is part of the bank account details array and is optional. It provides clarity on the financial institutions the company is associated with, which can be important for financial audits, transactions, and maintaining accurate financial records within the CRM. It should be a valid bank name recognized by financial institutions.
   */
  bankName?: string | null | undefined;
  /**
   * The unique account number assigned to the company's bank account. This field is part of the bank account details array and is optional. It is crucial for identifying specific accounts for transactions, audits, and financial reporting. Each account number should be unique to avoid confusion and ensure accurate financial management within the CRM. It must adhere to the format and length specified by the bank.
   */
  accountNumber?: string | null | undefined;
  /**
   * The name associated with your bank account, typically the name of the account holder or business entity. This is crucial for verifying the ownership of the account during financial transactions and ensuring that payments are directed to the correct entity. It should match the name on official bank documents to avoid discrepancies.
   */
  accountName?: string | null | undefined;
  /**
   * Specifies the category of the bank account, such as 'savings', 'checking', or 'business'. This information is important for determining the nature of transactions that can be performed and may affect transaction limits and fees. Understanding the account type helps in aligning the company's financial operations with its banking capabilities.
   */
  accountType?: AccountType | null | undefined;
  /**
   * The International Bank Account Number (IBAN) is a standardized international numbering system used to identify bank accounts across borders. It is essential for facilitating international wire transfers and ensuring that funds are transferred accurately to the intended account. The IBAN must be correctly formatted according to the standards of the account's country to be valid.
   */
  iban?: string | null | undefined;
  /**
   * The Bank Identifier Code (BIC), also known as the SWIFT code, is used to uniquely identify a bank during international transactions. It is crucial for ensuring that funds are routed to the correct financial institution. The BIC is typically 8 or 11 characters long and must be provided accurately to avoid transaction errors.
   */
  bic?: string | null | undefined;
  /**
   * A routing number is a nine-digit code used to identify a financial institution within the United States. It is necessary for domestic wire transfers and direct deposits, ensuring that transactions are processed through the correct bank. The routing number must be accurate to facilitate smooth financial operations and prevent transaction delays.
   */
  routingNumber?: string | null | undefined;
  /**
   * The BSB (Bank State Branch) number is a 6-digit numeric code essential for identifying the specific branch of an Australian or New Zealand bank or financial institution. In the context of updating a company's bank account details, providing the correct BSB ensures that transactions are routed accurately to the intended branch. This is particularly important for companies operating in these regions, as it facilitates seamless financial operations and compliance with local banking regulations. While not mandatory, including the BSB number can prevent potential transaction errors and enhance the precision of financial data management within the CRM.
   */
  bsbNumber?: string | null | undefined;
  /**
   * The branch identifier serves as a unique code for pinpointing the exact branch of a bank or financial institution where the company's account is held. This identifier is crucial when updating bank account information to ensure that all financial transactions are directed to the correct branch, thereby minimizing the risk of errors. It is particularly useful for companies with multiple accounts across different branches, as it aids in maintaining organized and accurate financial records within the CRM system. Although not required, providing this information can significantly enhance the reliability of banking operations.
   */
  branchIdentifier?: string | null | undefined;
  /**
   * The bank code is a standardized code assigned by a central authority, such as a central bank or a banking association, to all licensed banks or financial institutions within a country. When updating a company's bank account details, the bank code is vital for identifying the specific bank where the account is held. This ensures that all financial transactions are processed correctly and efficiently. The bank code is particularly important for international transactions, as it helps in distinguishing between banks in different countries. Including this code, although optional, can greatly improve the accuracy and efficiency of financial operations within the CRM.
   */
  bankCode?: string | null | undefined;
  /**
   * This property specifies the currency associated with the company's bank account, using the standardized codes defined by ISO 4217. When updating a company's financial information, specifying the correct currency is crucial for ensuring that all monetary transactions are recorded and processed in the appropriate currency. This is especially important for companies dealing with international clients or operating in multiple countries, as it helps in maintaining accurate financial records and avoiding currency conversion errors. While not mandatory, providing the currency code can enhance the clarity and precision of financial data management within the CRM.
   */
  currency?: CompanyCreateRequestCurrency | null | undefined;
};

/**
 * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
 */
export const CompanyCreateRequestWebsitesType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
 */
export type CompanyCreateRequestWebsitesType = ClosedEnum<
  typeof CompanyCreateRequestWebsitesType
>;

export type Websites = {
  /**
   * A unique identifier for each website entry associated with the lead, ensuring that each website can be distinctly referenced and managed within the CRM system. This ID is crucial for operations that involve updating or removing specific websites from the lead's profile, maintaining data integrity and consistency.
   */
  id?: string | null | undefined;
  /**
   * The website URL for the lead's business or personal site. This URL serves as a digital point of contact and is essential for verifying the lead's online presence. It must be a valid URL format, starting with http:// or https://, and is crucial for CRM users to access further information about the lead's activities or offerings. This field is required to ensure that the lead's digital footprint is accurately captured and easily accessible.
   */
  url: string;
  /**
   * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
   */
  type?: CompanyCreateRequestWebsitesType | null | undefined;
};

/**
 * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
 */
export const CompanyCreateRequestType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Office: "office",
  Shipping: "shipping",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
 */
export type CompanyCreateRequestType = ClosedEnum<
  typeof CompanyCreateRequestType
>;

export type Addresses = {
  /**
   * A unique identifier for each address within the user's address array. This ID is crucial for distinguishing between different address records, especially when updating or deleting specific addresses. It ensures that each address can be individually referenced and managed within the CRM system, maintaining data integrity and accuracy.
   */
  id?: string | null | undefined;
  /**
   * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
   */
  type?: CompanyCreateRequestType | null | undefined;
  /**
   * The full address in a single string format, used when structured address data is not available. This field is essential for APIs that do not support detailed address components, allowing for a flexible representation of address information. It is particularly useful for quick data entry and display purposes.
   */
  string?: string | null | undefined;
  /**
   * A descriptive name for the address, often used to label or identify the address within the user's profile. This can include names like 'Headquarters', 'Main Office', or 'John's Apartment', providing a human-readable identifier that simplifies address management and selection within the CRM.
   */
  name?: string | null | undefined;
  /**
   * Line 1 of the address e.g. number, street, suite, apt #, etc.
   */
  line1?: string | null | undefined;
  /**
   * Line 2 of the address
   */
  line2?: string | null | undefined;
  /**
   * Line 3 of the address
   */
  line3?: string | null | undefined;
  /**
   * Line 4 of the address
   */
  line4?: string | null | undefined;
  /**
   * Street number
   */
  streetNumber?: string | null | undefined;
  /**
   * The name of the city associated with the user's address. This field is used to specify the city where the user resides or is located. It is important for geographical identification and can be used for location-based services or analytics. Ensure the city name is spelled correctly to maintain data accuracy and integrity within the CRM system.
   */
  city?: string | null | undefined;
  /**
   * The name of the state or region associated with the user's address. This field helps in identifying the specific administrative area within a country where the user is located. It is crucial for regional segmentation and can aid in compliance with local regulations. Ensure the state name is accurate to facilitate proper data management and reporting.
   */
  state?: string | null | undefined;
  /**
   * The postal code or equivalent for the user's address. This field is essential for precise location identification and is often used in mailing and shipping processes. It can also be used for demographic analysis and service eligibility checks. Ensure the postal code is valid and corresponds to the correct city and state to avoid errors in data processing.
   */
  postalCode?: string | null | undefined;
  /**
   * The country code for the user's address, following the ISO 3166-1 alpha-2 standard. This field is vital for internationalization and ensures that the user's location is correctly identified on a global scale. It supports cross-border operations and compliance with international standards. Ensure the country code is accurate to maintain consistency in global data management.
   */
  country?: string | null | undefined;
  /**
   * The latitude coordinate of the user's address. This field provides the geographical latitude, which is used in mapping and location-based services. It is important for applications that require precise geolocation, such as delivery services or geographic analysis. Ensure the latitude is accurate to enhance the reliability of location-dependent operations.
   */
  latitude?: string | null | undefined;
  /**
   * The longitude coordinate of the address, representing the east-west position on the Earth's surface. This value is crucial for geolocation services and mapping functionalities within the CRM, enabling precise location tracking and integration with geographic information systems. It should be a valid string representation of a decimal degree, typically ranging from -180.0 to 180.0.
   */
  longitude?: string | null | undefined;
  /**
   * This field captures the sublocality or county of the address, providing additional geographic context. It is particularly useful for regional segmentation and analysis, allowing for more granular data categorization and reporting. The county name should be accurately spelled to ensure consistency across records.
   */
  county?: string | null | undefined;
  /**
   * The full name of the primary contact person associated with the address. This information is vital for personalized communication and relationship management within the CRM. It should include both first and last names, and be kept up-to-date to reflect any changes in contact personnel.
   */
  contactName?: string | null | undefined;
  /**
   * The salutation or title used for the contact person at the address, such as Mr., Ms., Dr., etc. This field enhances formal communication and is important for maintaining professional etiquette in correspondence. It should be chosen based on the contact's preference and cultural norms.
   */
  salutation?: string | null | undefined;
  /**
   * The primary phone number associated with the address, used for direct communication with the contact person. This number should be formatted according to international standards to ensure it can be dialed from any location. It is essential for timely and effective communication, especially in customer service scenarios.
   */
  phoneNumber?: string | null | undefined;
  /**
   * The fax number associated with the user's address. This field allows for the inclusion of traditional communication methods, which may be necessary for certain business transactions or legal documentation. While not commonly used in modern digital communications, maintaining a fax number can be crucial for businesses that still rely on this method. Ensure the number is formatted correctly to avoid transmission errors.
   */
  fax?: string | null | undefined;
  /**
   * The email address linked to the user's address, serving as a primary mode of digital communication. This field is essential for sending notifications, updates, and other important information directly to the user. It should be a valid email format to ensure successful delivery and communication. Keeping this information up-to-date is vital for maintaining effective contact with the user.
   */
  email?: string | null | undefined;
  /**
   * The website URL associated with the user's address, providing a digital point of reference or contact. This can be used to direct users to a personal or business website, offering more information or services. Ensure the URL is complete and correctly formatted to facilitate seamless access. This field supports the user's digital presence and connectivity.
   */
  website?: string | null | undefined;
  /**
   * Additional notes related to the user's address, offering space for any extra information that might be relevant but does not fit into other predefined fields. This could include special delivery instructions, historical data, or personal preferences. These notes can be crucial for personalized service and ensuring all relevant details are captured.
   */
  notes?: string | null | undefined;
  /**
   * A binary value used to track changes to the user's address object, ensuring data integrity and preventing update conflicts. This field is automatically incremented with each update, allowing the system to detect concurrent modifications and manage them appropriately. It is crucial for maintaining accurate and consistent data across the CRM system, especially in environments with multiple users accessing the same records.
   */
  rowVersion?: string | null | undefined;
};

export type SocialLinks = {
  /**
   * A unique identifier for each social link entry within the array. This ID is used to distinguish between different social media profiles associated with the lead, ensuring that each link can be individually referenced and managed. It is essential for operations that involve updating or removing specific social links without affecting others.
   */
  id?: string | null | undefined;
  /**
   * The complete URL of the social media profile associated with the lead. This field is required and must be a valid URL format, such as 'https://www.twitter.com/apideck'. It provides direct access to the lead's social media presence, enabling CRM users to quickly view and interact with the lead's profiles. Accurate URLs are vital for maintaining effective communication and engagement strategies.
   */
  url: string;
  /**
   * Specifies the type of social media link associated with the lead, such as Twitter, LinkedIn, or Facebook. This field helps categorize and manage the lead's social media presence within the CRM, allowing for targeted communication strategies. It is optional but recommended for leads with active social media profiles to enhance engagement tracking.
   */
  type?: string | null | undefined;
};

/**
 * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
 */
export const CompanyCreateRequestPhoneNumbersType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Work: "work",
  Office: "office",
  Mobile: "mobile",
  Assistant: "assistant",
  Fax: "fax",
  DirectDialIn: "direct-dial-in",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
 */
export type CompanyCreateRequestPhoneNumbersType = ClosedEnum<
  typeof CompanyCreateRequestPhoneNumbersType
>;

export type PhoneNumbers = {
  /**
   * A unique identifier for each phone number entry within the user's phone numbers array. This ID is crucial for distinguishing between different phone numbers, especially when updating or deleting specific numbers. It ensures that operations are performed on the correct phone number entry, maintaining data integrity within the user's contact information.
   */
  id?: string | null | undefined;
  /**
   * The international dialing code associated with the phone number, such as '+1' for the United States. This field is essential for ensuring that phone numbers are formatted correctly for international dialing and can be used to validate the geographical origin of the number. It helps in standardizing phone numbers across different regions and is critical for applications that involve international communication.
   */
  countryCode?: string | null | undefined;
  /**
   * The regional area code that precedes the local phone number, such as '323' for parts of Los Angeles. This code is important for routing calls within specific geographic areas and is a key component of the full phone number. Including the area code ensures that the phone number is complete and can be dialed correctly from both local and international locations.
   */
  areaCode?: string | null | undefined;
  /**
   * The main part of the phone number, excluding the country and area codes. This field is required as it represents the actual number that will be dialed within the specified area and country codes. It is the core component of the user's contact information and must be accurate to ensure successful communication. This field is mandatory to ensure that there is a valid number associated with the user.
   */
  number: string;
  /**
   * The extension of the phone number, typically used in corporate environments to direct calls to specific departments or employees. This field is optional and should be used when the phone number is part of a larger system, such as a PBX, where extensions are necessary for routing calls internally. Including an extension ensures that calls reach the intended recipient without delay.
   */
  extension?: string | null | undefined;
  /**
   * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
   */
  type?: CompanyCreateRequestPhoneNumbersType | null | undefined;
};

/**
 * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
 */
export const CompanyCreateRequestEmailsType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
 */
export type CompanyCreateRequestEmailsType = ClosedEnum<
  typeof CompanyCreateRequestEmailsType
>;

export type Emails = {
  /**
   * A unique identifier for each email address within the user's email collection. This ID is used to distinguish between multiple email addresses associated with a single user, allowing for precise updates and management of contact information. It is optional but can be useful for operations that require specific email targeting.
   */
  id?: string | null | undefined;
  /**
   * The actual email address used for electronic communication with the user. This field is required and must be a valid email format to ensure successful delivery of messages. It serves as a primary contact method and is essential for user engagement and CRM operations.
   */
  email: string | null;
  /**
   * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
   */
  type?: CompanyCreateRequestEmailsType | null | undefined;
};

/**
 * An object representing the type of row or entry being updated within the company record. This can include various attributes that define the nature of the data being modified. It is optional and typically used when specific structured data needs to be updated or added.
 */
export type CompanyRowType = {
  /**
   * The unique identifier for the specific row type object within the company record. This ID is crucial when updating or referencing a particular structured data entry, ensuring precise modifications without affecting other data. It is optional unless targeting a specific row type for update.
   */
  id?: string | null | undefined;
  /**
   * The name of the row type, which specifies the category or classification of the company record being updated. This field is optional and can be used to organize or filter company records based on predefined categories within the CRM system. It helps in maintaining structured data and can be useful for reporting and analytics purposes.
   */
  name?: string | null | undefined;
};

export type Six = {};

export type Four = {};

/**
 * The value assigned to a custom field within the opportunity record. Custom fields allow for additional, user-defined data to be stored, providing flexibility to tailor the CRM to specific business needs. This field is optional and can be used to capture unique attributes or metrics relevant to the opportunity that are not covered by standard fields.
 */
export type Value =
  | Four
  | string
  | number
  | boolean
  | Array<string>
  | Array<Six>;

export type CustomFields = {
  /**
   * Unique identifier for the custom field. This ID is essential for distinguishing each custom field within the opportunity's data structure. It ensures that each field can be individually accessed, updated, or removed as needed. The ID must be unique within the context of the opportunity to prevent data conflicts and maintain data integrity.
   */
  id: string | null;
  /**
   * Name of the custom field. This name serves as a label for the custom field, providing a human-readable identifier that describes the field's purpose or content. While not required, including a name can improve clarity and usability, especially when multiple custom fields are present. It should be concise yet descriptive enough to convey the field's role in the opportunity's data.
   */
  name?: string | null | undefined;
  /**
   * More information about the custom field. This description offers additional context or details about the custom field's intended use or significance. It can include guidelines on what type of data should be entered or how the field relates to the overall sales process. Providing a description is optional but can enhance understanding and proper utilization of the custom field by users.
   */
  description?: string | null | undefined;
  /**
   * The value assigned to a custom field within the opportunity record. Custom fields allow for additional, user-defined data to be stored, providing flexibility to tailor the CRM to specific business needs. This field is optional and can be used to capture unique attributes or metrics relevant to the opportunity that are not covered by standard fields.
   */
  value?:
    | Four
    | string
    | number
    | boolean
    | Array<string>
    | Array<Six>
    | null
    | undefined;
};

export type ExtendPaths = {
  /**
   * A JSONPath string that specifies the exact location within the user record where the value should be applied. This is essential for making precise updates to nested fields, ensuring that changes are made only to the intended parts of the data structure. The path must be valid and correspond to an existing field within the user record.
   */
  path: string;
  /**
   * This property represents the specific value that you wish to assign to a designated path within the user record. It can be of any data type, such as a string, number, boolean, or object, depending on the field being updated. The flexibility of this property allows for a wide range of updates, from simple text changes to complex data structures. In the context of the `usersUpdate` operation, this property is crucial for specifying the exact data modification you intend to make, ensuring that only the targeted fields are altered without affecting other data. Proper validation should be applied to ensure the value is compatible with the field's expected data type and business rules. Common use cases include updating user contact information, preferences, or custom attributes specific to your CRM's schema.
   */
  value?: any | undefined;
};

export type PassThrough = {
  /**
   * The unique identifier for the specific service to which this pass_through should be applied. This is crucial for directing the update operation to the correct service within the CRM system, ensuring that the modifications are executed in the appropriate context. It must be a valid service ID that corresponds to an active service integration, and it is required for the operation to proceed.
   */
  serviceId: string;
  /**
   * An optional identifier for a specific workflow operation within the CRM system to which this pass_through should be applied. This is particularly useful for Unify calls that involve multiple downstream requests, allowing for precise targeting and execution of specific operations. If provided, it should match an existing operation ID to ensure correct processing.
   */
  operationId?: string | undefined;
  /**
   * A flexible object that allows for the inclusion of any additional properties needed for direct extension of the user record. This can be used to add custom fields or metadata that are not part of the standard user schema, providing a way to tailor the user data to specific business needs. The structure of this object should align with the CRM's data model to ensure compatibility.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects designed for structured data modifications via specified paths. This allows for precise updates to nested data structures within the user record, enabling complex modifications without altering unrelated data. Each object in the array should define a clear path and value to be applied, ensuring targeted updates.
   */
  extendPaths?: Array<ExtendPaths> | undefined;
};

export type CompanyCreateRequest = {
  /**
   * The official name of the company as recognized in the CRM. This field is mandatory for updates as it serves as a primary reference point for identifying the company within the system. Ensuring the name is accurate and up-to-date is essential for maintaining clear and consistent records, especially when multiple companies may have similar names.
   */
  name: string | null;
  /**
   * The unique identifier of the user or entity that owns or manages the company record within the CRM. This field helps in assigning responsibility and tracking who is accountable for the company's data. It is particularly useful in organizations with multiple users managing different accounts, ensuring clarity in ownership and management responsibilities.
   */
  ownerId?: string | null | undefined;
  /**
   * The URL of the company's logo or representative image. This visual identifier can enhance the user interface by providing a quick visual reference for the company. While optional, including an image URL can improve recognition and branding within the CRM, especially useful in dashboards or reports where visual elements aid in quick identification.
   */
  image?: string | null | undefined;
  /**
   * A detailed narrative about the company, providing insights into its operations, mission, and key aspects. This field is optional but can be valuable for giving context to the company's role and significance within the CRM. It helps users understand the company's background and can be used for internal documentation or customer-facing profiles.
   */
  description?: string | null | undefined;
  /**
   * The official VAT (Value Added Tax) number assigned to the company, used for tax identification purposes. This field is crucial for companies operating in regions where VAT is applicable, ensuring compliance with tax regulations. It should be formatted according to the country's specific VAT structure and is essential for financial transactions and reporting.
   */
  vatNumber?: string | null | undefined;
  /**
   * Specifies the currency in which the company's financial transactions are conducted, adhering to the ISO 4217 standard. This field is important for financial consistency and reporting, especially for companies operating in multiple countries. It ensures that monetary values are accurately represented and understood across different regions.
   */
  currency?: Currency | null | undefined;
  /**
   * Represents the current operational status of the company, such as active, inactive, or pending. This field helps in categorizing and managing company records within the CRM, allowing users to filter and prioritize companies based on their engagement level or operational state. It is crucial for maintaining up-to-date records and facilitating business decisions.
   */
  status?: string | null | undefined;
  /**
   * The company's fax number, used for sending and receiving documents via fax. Although less common in modern digital communications, this field can be important for businesses that still rely on fax for certain transactions or communications. It should be formatted according to international fax standards to ensure proper transmission.
   */
  fax?: string | null | undefined;
  /**
   * The annual revenue of the company, representing the total income generated by the company over a fiscal year. This figure is crucial for assessing the company's financial health and growth potential. It is typically used by stakeholders to make informed decisions regarding investments, partnerships, and strategic planning. When updating this field, ensure the value is accurate and reflects the most recent fiscal year to maintain data integrity within the CRM.
   */
  annualRevenue?: string | null | undefined;
  /**
   * Number of employees currently employed by the company. This metric provides insight into the company's size and operational capacity. It is often used to categorize companies into small, medium, or large enterprises, which can influence business strategies and market positioning. When updating, provide the latest headcount to ensure accurate representation in the CRM.
   */
  numberOfEmployees?: string | null | undefined;
  /**
   * The industry represents the type of business the company is in, such as technology, healthcare, or finance. This classification helps in segmenting the market and tailoring marketing strategies. It also aids in benchmarking performance against industry standards. Ensure the industry type is selected from a standardized list to maintain consistency across records.
   */
  industry?: string | null | undefined;
  /**
   * The ownership indicates the type of ownership of the company, such as private, public, or government-owned. This information is vital for understanding the company's governance structure and potential regulatory requirements. It can impact investor relations and compliance obligations. Update this field to reflect any changes in the company's ownership status accurately.
   */
  ownership?: string | null | undefined;
  /**
   * A sales tax number is a unique identifier assigned to a company for tax purposes, required for reporting and remitting sales tax to the government. This number is essential for legal compliance and is used in financial transactions to validate the company's tax status. Ensure the sales tax number is current and correctly formatted according to regional tax authority standards when updating.
   */
  salesTaxNumber?: string | null | undefined;
  /**
   * The payee number serves as a unique identifier for a payee within the tax system. In the context of updating a company's details, this number ensures that the company's tax-related transactions are accurately recorded and reported. It is particularly important for businesses that handle multiple payees or require precise tax documentation. While not mandatory, providing this number can facilitate smoother tax processing and compliance checks.
   */
  payeeNumber?: string | null | undefined;
  /**
   * The Australian Business Number (ABN) or Tax File Number (TFN) is crucial for businesses operating in Australia. The ABN is used for business identification in dealings with the Australian Taxation Office (ATO) and other government agencies, while the TFN is essential for individuals and entities to manage their tax obligations. In the context of updating company records, including the correct ABN or TFN ensures that the company's tax identity is accurately maintained, which is vital for legal and financial transactions. This field is optional but highly recommended for businesses operating in Australia.
   */
  abnOrTfn?: string | null | undefined;
  /**
   * The ABN Branch, also known as a GST Branch, is used when a segment of a business needs to report Goods and Services Tax (GST) separately from the main entity. This is particularly useful for large companies with multiple divisions or locations that require distinct GST reporting. When updating company information, specifying the ABN Branch can help in organizing financial records and ensuring compliance with tax regulations. This field is optional and should be used if applicable to the company's structure.
   */
  abnBranch?: string | null | undefined;
  /**
   * The Australian Company Number (ACN) is a unique nine-digit number issued to every company registered under the Corporations Act 2001. It is used to identify the company in legal and official documents. When updating a company's details, including the ACN ensures that the company's identity is correctly reflected in the CRM system, which is essential for legal compliance and business transactions. The ACN should be formatted as three blocks of three digits, separated by spaces, to match official documentation standards. This field is optional but recommended for companies registered in Australia.
   */
  acn?: string | null | undefined;
  /**
   * The first name of the contact person associated with the company. This field is used to personalize communications and maintain accurate contact records within the CRM. While updating company details, including the first name can enhance customer relationship management by ensuring that interactions are directed to the correct individual. This field is optional but can be valuable for businesses that prioritize personalized customer service.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the person associated with the company record being updated. This field is optional and can be used to update the surname of a contact person linked to the company. It is important for personalizing communications and ensuring accurate contact information within the CRM. Typically used in scenarios where the contact person for the company has changed or needs correction.
   */
  lastName?: string | null | undefined;
  /**
   * An array of bank account details associated with the company. This field is optional and allows for the inclusion of multiple bank accounts, each represented as an object within the array. It is useful for companies that manage multiple financial accounts, enabling comprehensive financial tracking and reporting within the CRM. Each bank account object can include details such as bank name and account number.
   */
  bankAccounts?: Array<BankAccounts> | undefined;
  /**
   * This property represents a list of websites associated with the company. When updating a company's profile, including its websites can provide valuable context and enhance the company's digital presence within the CRM. Websites can include the company's main homepage, product pages, or any other relevant online resources. This information is useful for sales and marketing teams to access up-to-date company information and for maintaining comprehensive company profiles. Although not required, adding websites can improve the richness of the company's data and support better engagement strategies.
   */
  websites?: Array<Websites> | undefined;
  /**
   * An array of address objects associated with the company, allowing for the management of multiple physical locations. Each address object can include details such as street, city, and postal code. This array is useful for companies with multiple branches or offices, enabling comprehensive location tracking and updates.
   */
  addresses?: Array<Addresses> | undefined;
  /**
   * An array of social media links associated with the company. This collection allows you to update or add multiple social media profiles, enhancing the company's digital footprint and engagement with customers. Each entry should be a valid URL pointing to the company's official social media pages. This field is optional and can be tailored to reflect the company's current social media strategy.
   */
  socialLinks?: Array<SocialLinks> | undefined;
  /**
   * An array of phone number objects associated with the company. Each object within the array can contain details such as the phone number's unique identifier, country code, and the number itself. This structure allows for the inclusion of multiple contact numbers, facilitating comprehensive communication options for the company. This field is optional but recommended for companies with multiple contact points.
   */
  phoneNumbers?: Array<PhoneNumbers> | undefined;
  /**
   * An array of email addresses associated with the company. This field allows for updating multiple email contacts for the company, which can include general inquiries, support, or specific department emails. Keeping email addresses current is vital for ensuring effective electronic communication and for maintaining accurate records in the CRM. Each email should be a valid format and relevant to the company's operations.
   */
  emails?: Array<Emails> | undefined;
  /**
   * An object representing the type of row or entry being updated within the company record. This can include various attributes that define the nature of the data being modified. It is optional and typically used when specific structured data needs to be updated or added.
   */
  rowType?: CompanyRowType | undefined;
  /**
   * An array of custom fields that allows for the extension of the standard company record with additional, user-defined data points. This flexibility is crucial for businesses that need to capture specific information not covered by default fields, enabling a more tailored CRM experience. Each entry in the array should conform to the structure defined by the custom field schema.
   */
  customFields?: Array<CustomFields> | undefined;
  /**
   * An array of tags associated with the company. Tags are used to categorize and organize companies within the CRM, allowing for easier filtering and retrieval of records. This property is optional and can include multiple tags to reflect various attributes or classifications relevant to the company. Tags should be meaningful and consistent to enhance searchability and reporting.
   */
  tags?: Array<string> | null | undefined;
  /**
   * Indicates whether the company record is read-only. A read-only status means that the company's details cannot be modified, which is useful for protecting critical or sensitive information from unauthorized changes. This property is optional and should be set to true only when updates to the company record are not permitted under any circumstances.
   */
  readOnly?: boolean | null | undefined;
  /**
   * A formal salutation or title associated with a contact person at the company, such as 'Mr.', 'Mrs.', 'Dr.', etc. This field is used to personalize communications and ensure respectful address in correspondence. It should be consistent with the contact's preferred form of address and is particularly useful in formal business interactions.
   */
  salutation?: string | null | undefined;
  /**
   * The birth date of a key contact person at the company, formatted as a string (e.g., 'YYYY-MM-DD'). This information can be used for personalizing interactions, sending birthday greetings, or for demographic analysis. Ensure the date is accurate and respects privacy regulations.
   */
  birthday?: RFCDate | null | undefined;
  /**
   * An array that allows the inclusion of service-specific custom data or structured modifications when updating the company record. This feature is particularly useful for integrating with third-party services that require additional parameters not covered by standard fields. Each entry in the array should conform to the expected structure of the target service.
   */
  passThrough?: Array<PassThrough> | undefined;
};

/** @internal */
export const Currency$inboundSchema: z.ZodNativeEnum<typeof Currency> = z
  .nativeEnum(Currency);

/** @internal */
export const Currency$outboundSchema: z.ZodNativeEnum<typeof Currency> =
  Currency$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Currency$ {
  /** @deprecated use `Currency$inboundSchema` instead. */
  export const inboundSchema = Currency$inboundSchema;
  /** @deprecated use `Currency$outboundSchema` instead. */
  export const outboundSchema = Currency$outboundSchema;
}

/** @internal */
export const AccountType$inboundSchema: z.ZodNativeEnum<typeof AccountType> = z
  .nativeEnum(AccountType);

/** @internal */
export const AccountType$outboundSchema: z.ZodNativeEnum<typeof AccountType> =
  AccountType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AccountType$ {
  /** @deprecated use `AccountType$inboundSchema` instead. */
  export const inboundSchema = AccountType$inboundSchema;
  /** @deprecated use `AccountType$outboundSchema` instead. */
  export const outboundSchema = AccountType$outboundSchema;
}

/** @internal */
export const CompanyCreateRequestCurrency$inboundSchema: z.ZodNativeEnum<
  typeof CompanyCreateRequestCurrency
> = z.nativeEnum(CompanyCreateRequestCurrency);

/** @internal */
export const CompanyCreateRequestCurrency$outboundSchema: z.ZodNativeEnum<
  typeof CompanyCreateRequestCurrency
> = CompanyCreateRequestCurrency$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyCreateRequestCurrency$ {
  /** @deprecated use `CompanyCreateRequestCurrency$inboundSchema` instead. */
  export const inboundSchema = CompanyCreateRequestCurrency$inboundSchema;
  /** @deprecated use `CompanyCreateRequestCurrency$outboundSchema` instead. */
  export const outboundSchema = CompanyCreateRequestCurrency$outboundSchema;
}

/** @internal */
export const BankAccounts$inboundSchema: z.ZodType<
  BankAccounts,
  z.ZodTypeDef,
  unknown
> = z.object({
  bank_name: z.nullable(z.string()).optional(),
  account_number: z.nullable(z.string()).optional(),
  account_name: z.nullable(z.string()).optional(),
  account_type: z.nullable(AccountType$inboundSchema).optional(),
  iban: z.nullable(z.string()).optional(),
  bic: z.nullable(z.string()).optional(),
  routing_number: z.nullable(z.string()).optional(),
  bsb_number: z.nullable(z.string()).optional(),
  branch_identifier: z.nullable(z.string()).optional(),
  bank_code: z.nullable(z.string()).optional(),
  currency: z.nullable(CompanyCreateRequestCurrency$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "bank_name": "bankName",
    "account_number": "accountNumber",
    "account_name": "accountName",
    "account_type": "accountType",
    "routing_number": "routingNumber",
    "bsb_number": "bsbNumber",
    "branch_identifier": "branchIdentifier",
    "bank_code": "bankCode",
  });
});

/** @internal */
export type BankAccounts$Outbound = {
  bank_name?: string | null | undefined;
  account_number?: string | null | undefined;
  account_name?: string | null | undefined;
  account_type?: string | null | undefined;
  iban?: string | null | undefined;
  bic?: string | null | undefined;
  routing_number?: string | null | undefined;
  bsb_number?: string | null | undefined;
  branch_identifier?: string | null | undefined;
  bank_code?: string | null | undefined;
  currency?: string | null | undefined;
};

/** @internal */
export const BankAccounts$outboundSchema: z.ZodType<
  BankAccounts$Outbound,
  z.ZodTypeDef,
  BankAccounts
> = z.object({
  bankName: z.nullable(z.string()).optional(),
  accountNumber: z.nullable(z.string()).optional(),
  accountName: z.nullable(z.string()).optional(),
  accountType: z.nullable(AccountType$outboundSchema).optional(),
  iban: z.nullable(z.string()).optional(),
  bic: z.nullable(z.string()).optional(),
  routingNumber: z.nullable(z.string()).optional(),
  bsbNumber: z.nullable(z.string()).optional(),
  branchIdentifier: z.nullable(z.string()).optional(),
  bankCode: z.nullable(z.string()).optional(),
  currency: z.nullable(CompanyCreateRequestCurrency$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    bankName: "bank_name",
    accountNumber: "account_number",
    accountName: "account_name",
    accountType: "account_type",
    routingNumber: "routing_number",
    bsbNumber: "bsb_number",
    branchIdentifier: "branch_identifier",
    bankCode: "bank_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BankAccounts$ {
  /** @deprecated use `BankAccounts$inboundSchema` instead. */
  export const inboundSchema = BankAccounts$inboundSchema;
  /** @deprecated use `BankAccounts$outboundSchema` instead. */
  export const outboundSchema = BankAccounts$outboundSchema;
  /** @deprecated use `BankAccounts$Outbound` instead. */
  export type Outbound = BankAccounts$Outbound;
}

export function bankAccountsToJSON(bankAccounts: BankAccounts): string {
  return JSON.stringify(BankAccounts$outboundSchema.parse(bankAccounts));
}

export function bankAccountsFromJSON(
  jsonString: string,
): SafeParseResult<BankAccounts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BankAccounts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BankAccounts' from JSON`,
  );
}

/** @internal */
export const CompanyCreateRequestWebsitesType$inboundSchema: z.ZodNativeEnum<
  typeof CompanyCreateRequestWebsitesType
> = z.nativeEnum(CompanyCreateRequestWebsitesType);

/** @internal */
export const CompanyCreateRequestWebsitesType$outboundSchema: z.ZodNativeEnum<
  typeof CompanyCreateRequestWebsitesType
> = CompanyCreateRequestWebsitesType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyCreateRequestWebsitesType$ {
  /** @deprecated use `CompanyCreateRequestWebsitesType$inboundSchema` instead. */
  export const inboundSchema = CompanyCreateRequestWebsitesType$inboundSchema;
  /** @deprecated use `CompanyCreateRequestWebsitesType$outboundSchema` instead. */
  export const outboundSchema = CompanyCreateRequestWebsitesType$outboundSchema;
}

/** @internal */
export const Websites$inboundSchema: z.ZodType<
  Websites,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(CompanyCreateRequestWebsitesType$inboundSchema).optional(),
});

/** @internal */
export type Websites$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const Websites$outboundSchema: z.ZodType<
  Websites$Outbound,
  z.ZodTypeDef,
  Websites
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(CompanyCreateRequestWebsitesType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Websites$ {
  /** @deprecated use `Websites$inboundSchema` instead. */
  export const inboundSchema = Websites$inboundSchema;
  /** @deprecated use `Websites$outboundSchema` instead. */
  export const outboundSchema = Websites$outboundSchema;
  /** @deprecated use `Websites$Outbound` instead. */
  export type Outbound = Websites$Outbound;
}

export function websitesToJSON(websites: Websites): string {
  return JSON.stringify(Websites$outboundSchema.parse(websites));
}

export function websitesFromJSON(
  jsonString: string,
): SafeParseResult<Websites, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Websites$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Websites' from JSON`,
  );
}

/** @internal */
export const CompanyCreateRequestType$inboundSchema: z.ZodNativeEnum<
  typeof CompanyCreateRequestType
> = z.nativeEnum(CompanyCreateRequestType);

/** @internal */
export const CompanyCreateRequestType$outboundSchema: z.ZodNativeEnum<
  typeof CompanyCreateRequestType
> = CompanyCreateRequestType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyCreateRequestType$ {
  /** @deprecated use `CompanyCreateRequestType$inboundSchema` instead. */
  export const inboundSchema = CompanyCreateRequestType$inboundSchema;
  /** @deprecated use `CompanyCreateRequestType$outboundSchema` instead. */
  export const outboundSchema = CompanyCreateRequestType$outboundSchema;
}

/** @internal */
export const Addresses$inboundSchema: z.ZodType<
  Addresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CompanyCreateRequestType$inboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  street_number: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postal_code: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contact_name: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phone_number: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  row_version: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "street_number": "streetNumber",
    "postal_code": "postalCode",
    "contact_name": "contactName",
    "phone_number": "phoneNumber",
    "row_version": "rowVersion",
  });
});

/** @internal */
export type Addresses$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
  string?: string | null | undefined;
  name?: string | null | undefined;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  line3?: string | null | undefined;
  line4?: string | null | undefined;
  street_number?: string | null | undefined;
  city?: string | null | undefined;
  state?: string | null | undefined;
  postal_code?: string | null | undefined;
  country?: string | null | undefined;
  latitude?: string | null | undefined;
  longitude?: string | null | undefined;
  county?: string | null | undefined;
  contact_name?: string | null | undefined;
  salutation?: string | null | undefined;
  phone_number?: string | null | undefined;
  fax?: string | null | undefined;
  email?: string | null | undefined;
  website?: string | null | undefined;
  notes?: string | null | undefined;
  row_version?: string | null | undefined;
};

/** @internal */
export const Addresses$outboundSchema: z.ZodType<
  Addresses$Outbound,
  z.ZodTypeDef,
  Addresses
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(CompanyCreateRequestType$outboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  streetNumber: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contactName: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phoneNumber: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  rowVersion: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    streetNumber: "street_number",
    postalCode: "postal_code",
    contactName: "contact_name",
    phoneNumber: "phone_number",
    rowVersion: "row_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Addresses$ {
  /** @deprecated use `Addresses$inboundSchema` instead. */
  export const inboundSchema = Addresses$inboundSchema;
  /** @deprecated use `Addresses$outboundSchema` instead. */
  export const outboundSchema = Addresses$outboundSchema;
  /** @deprecated use `Addresses$Outbound` instead. */
  export type Outbound = Addresses$Outbound;
}

export function addressesToJSON(addresses: Addresses): string {
  return JSON.stringify(Addresses$outboundSchema.parse(addresses));
}

export function addressesFromJSON(
  jsonString: string,
): SafeParseResult<Addresses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Addresses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Addresses' from JSON`,
  );
}

/** @internal */
export const SocialLinks$inboundSchema: z.ZodType<
  SocialLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/** @internal */
export type SocialLinks$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const SocialLinks$outboundSchema: z.ZodType<
  SocialLinks$Outbound,
  z.ZodTypeDef,
  SocialLinks
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SocialLinks$ {
  /** @deprecated use `SocialLinks$inboundSchema` instead. */
  export const inboundSchema = SocialLinks$inboundSchema;
  /** @deprecated use `SocialLinks$outboundSchema` instead. */
  export const outboundSchema = SocialLinks$outboundSchema;
  /** @deprecated use `SocialLinks$Outbound` instead. */
  export type Outbound = SocialLinks$Outbound;
}

export function socialLinksToJSON(socialLinks: SocialLinks): string {
  return JSON.stringify(SocialLinks$outboundSchema.parse(socialLinks));
}

export function socialLinksFromJSON(
  jsonString: string,
): SafeParseResult<SocialLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SocialLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SocialLinks' from JSON`,
  );
}

/** @internal */
export const CompanyCreateRequestPhoneNumbersType$inboundSchema:
  z.ZodNativeEnum<typeof CompanyCreateRequestPhoneNumbersType> = z.nativeEnum(
    CompanyCreateRequestPhoneNumbersType,
  );

/** @internal */
export const CompanyCreateRequestPhoneNumbersType$outboundSchema:
  z.ZodNativeEnum<typeof CompanyCreateRequestPhoneNumbersType> =
    CompanyCreateRequestPhoneNumbersType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyCreateRequestPhoneNumbersType$ {
  /** @deprecated use `CompanyCreateRequestPhoneNumbersType$inboundSchema` instead. */
  export const inboundSchema =
    CompanyCreateRequestPhoneNumbersType$inboundSchema;
  /** @deprecated use `CompanyCreateRequestPhoneNumbersType$outboundSchema` instead. */
  export const outboundSchema =
    CompanyCreateRequestPhoneNumbersType$outboundSchema;
}

/** @internal */
export const PhoneNumbers$inboundSchema: z.ZodType<
  PhoneNumbers,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  country_code: z.nullable(z.string()).optional(),
  area_code: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(CompanyCreateRequestPhoneNumbersType$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "country_code": "countryCode",
    "area_code": "areaCode",
  });
});

/** @internal */
export type PhoneNumbers$Outbound = {
  id?: string | null | undefined;
  country_code?: string | null | undefined;
  area_code?: string | null | undefined;
  number: string;
  extension?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const PhoneNumbers$outboundSchema: z.ZodType<
  PhoneNumbers$Outbound,
  z.ZodTypeDef,
  PhoneNumbers
> = z.object({
  id: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  areaCode: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(CompanyCreateRequestPhoneNumbersType$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    countryCode: "country_code",
    areaCode: "area_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PhoneNumbers$ {
  /** @deprecated use `PhoneNumbers$inboundSchema` instead. */
  export const inboundSchema = PhoneNumbers$inboundSchema;
  /** @deprecated use `PhoneNumbers$outboundSchema` instead. */
  export const outboundSchema = PhoneNumbers$outboundSchema;
  /** @deprecated use `PhoneNumbers$Outbound` instead. */
  export type Outbound = PhoneNumbers$Outbound;
}

export function phoneNumbersToJSON(phoneNumbers: PhoneNumbers): string {
  return JSON.stringify(PhoneNumbers$outboundSchema.parse(phoneNumbers));
}

export function phoneNumbersFromJSON(
  jsonString: string,
): SafeParseResult<PhoneNumbers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PhoneNumbers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PhoneNumbers' from JSON`,
  );
}

/** @internal */
export const CompanyCreateRequestEmailsType$inboundSchema: z.ZodNativeEnum<
  typeof CompanyCreateRequestEmailsType
> = z.nativeEnum(CompanyCreateRequestEmailsType);

/** @internal */
export const CompanyCreateRequestEmailsType$outboundSchema: z.ZodNativeEnum<
  typeof CompanyCreateRequestEmailsType
> = CompanyCreateRequestEmailsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyCreateRequestEmailsType$ {
  /** @deprecated use `CompanyCreateRequestEmailsType$inboundSchema` instead. */
  export const inboundSchema = CompanyCreateRequestEmailsType$inboundSchema;
  /** @deprecated use `CompanyCreateRequestEmailsType$outboundSchema` instead. */
  export const outboundSchema = CompanyCreateRequestEmailsType$outboundSchema;
}

/** @internal */
export const Emails$inboundSchema: z.ZodType<Emails, z.ZodTypeDef, unknown> = z
  .object({
    id: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()),
    type: z.nullable(CompanyCreateRequestEmailsType$inboundSchema).optional(),
  });

/** @internal */
export type Emails$Outbound = {
  id?: string | null | undefined;
  email: string | null;
  type?: string | null | undefined;
};

/** @internal */
export const Emails$outboundSchema: z.ZodType<
  Emails$Outbound,
  z.ZodTypeDef,
  Emails
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(CompanyCreateRequestEmailsType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Emails$ {
  /** @deprecated use `Emails$inboundSchema` instead. */
  export const inboundSchema = Emails$inboundSchema;
  /** @deprecated use `Emails$outboundSchema` instead. */
  export const outboundSchema = Emails$outboundSchema;
  /** @deprecated use `Emails$Outbound` instead. */
  export type Outbound = Emails$Outbound;
}

export function emailsToJSON(emails: Emails): string {
  return JSON.stringify(Emails$outboundSchema.parse(emails));
}

export function emailsFromJSON(
  jsonString: string,
): SafeParseResult<Emails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Emails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Emails' from JSON`,
  );
}

/** @internal */
export const CompanyRowType$inboundSchema: z.ZodType<
  CompanyRowType,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
});

/** @internal */
export type CompanyRowType$Outbound = {
  id?: string | null | undefined;
  name?: string | null | undefined;
};

/** @internal */
export const CompanyRowType$outboundSchema: z.ZodType<
  CompanyRowType$Outbound,
  z.ZodTypeDef,
  CompanyRowType
> = z.object({
  id: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyRowType$ {
  /** @deprecated use `CompanyRowType$inboundSchema` instead. */
  export const inboundSchema = CompanyRowType$inboundSchema;
  /** @deprecated use `CompanyRowType$outboundSchema` instead. */
  export const outboundSchema = CompanyRowType$outboundSchema;
  /** @deprecated use `CompanyRowType$Outbound` instead. */
  export type Outbound = CompanyRowType$Outbound;
}

export function companyRowTypeToJSON(companyRowType: CompanyRowType): string {
  return JSON.stringify(CompanyRowType$outboundSchema.parse(companyRowType));
}

export function companyRowTypeFromJSON(
  jsonString: string,
): SafeParseResult<CompanyRowType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompanyRowType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyRowType' from JSON`,
  );
}

/** @internal */
export const Six$inboundSchema: z.ZodType<Six, z.ZodTypeDef, unknown> = z
  .object({});

/** @internal */
export type Six$Outbound = {};

/** @internal */
export const Six$outboundSchema: z.ZodType<Six$Outbound, z.ZodTypeDef, Six> = z
  .object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Six$ {
  /** @deprecated use `Six$inboundSchema` instead. */
  export const inboundSchema = Six$inboundSchema;
  /** @deprecated use `Six$outboundSchema` instead. */
  export const outboundSchema = Six$outboundSchema;
  /** @deprecated use `Six$Outbound` instead. */
  export type Outbound = Six$Outbound;
}

export function sixToJSON(six: Six): string {
  return JSON.stringify(Six$outboundSchema.parse(six));
}

export function sixFromJSON(
  jsonString: string,
): SafeParseResult<Six, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Six$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Six' from JSON`,
  );
}

/** @internal */
export const Four$inboundSchema: z.ZodType<Four, z.ZodTypeDef, unknown> = z
  .object({});

/** @internal */
export type Four$Outbound = {};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> =
  z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Four$ {
  /** @deprecated use `Four$inboundSchema` instead. */
  export const inboundSchema = Four$inboundSchema;
  /** @deprecated use `Four$outboundSchema` instead. */
  export const outboundSchema = Four$outboundSchema;
  /** @deprecated use `Four$Outbound` instead. */
  export type Outbound = Four$Outbound;
}

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}

export function fourFromJSON(
  jsonString: string,
): SafeParseResult<Four, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Four$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Four' from JSON`,
  );
}

/** @internal */
export const Value$inboundSchema: z.ZodType<Value, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => Four$inboundSchema),
    z.string(),
    z.number(),
    z.boolean(),
    z.array(z.string()),
    z.array(z.lazy(() => Six$inboundSchema)),
  ]);

/** @internal */
export type Value$Outbound =
  | Four$Outbound
  | string
  | number
  | boolean
  | Array<string>
  | Array<Six$Outbound>;

/** @internal */
export const Value$outboundSchema: z.ZodType<
  Value$Outbound,
  z.ZodTypeDef,
  Value
> = z.union([
  z.lazy(() => Four$outboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
  z.array(z.string()),
  z.array(z.lazy(() => Six$outboundSchema)),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Value$ {
  /** @deprecated use `Value$inboundSchema` instead. */
  export const inboundSchema = Value$inboundSchema;
  /** @deprecated use `Value$outboundSchema` instead. */
  export const outboundSchema = Value$outboundSchema;
  /** @deprecated use `Value$Outbound` instead. */
  export type Outbound = Value$Outbound;
}

export function valueToJSON(value: Value): string {
  return JSON.stringify(Value$outboundSchema.parse(value));
}

export function valueFromJSON(
  jsonString: string,
): SafeParseResult<Value, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Value$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Value' from JSON`,
  );
}

/** @internal */
export const CustomFields$inboundSchema: z.ZodType<
  CustomFields,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => Four$inboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => Six$inboundSchema)),
    ]),
  ).optional(),
});

/** @internal */
export type CustomFields$Outbound = {
  id: string | null;
  name?: string | null | undefined;
  description?: string | null | undefined;
  value?:
    | Four$Outbound
    | string
    | number
    | boolean
    | Array<string>
    | Array<Six$Outbound>
    | null
    | undefined;
};

/** @internal */
export const CustomFields$outboundSchema: z.ZodType<
  CustomFields$Outbound,
  z.ZodTypeDef,
  CustomFields
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => Four$outboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => Six$outboundSchema)),
    ]),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomFields$ {
  /** @deprecated use `CustomFields$inboundSchema` instead. */
  export const inboundSchema = CustomFields$inboundSchema;
  /** @deprecated use `CustomFields$outboundSchema` instead. */
  export const outboundSchema = CustomFields$outboundSchema;
  /** @deprecated use `CustomFields$Outbound` instead. */
  export type Outbound = CustomFields$Outbound;
}

export function customFieldsToJSON(customFields: CustomFields): string {
  return JSON.stringify(CustomFields$outboundSchema.parse(customFields));
}

export function customFieldsFromJSON(
  jsonString: string,
): SafeParseResult<CustomFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomFields' from JSON`,
  );
}

/** @internal */
export const ExtendPaths$inboundSchema: z.ZodType<
  ExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type ExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const ExtendPaths$outboundSchema: z.ZodType<
  ExtendPaths$Outbound,
  z.ZodTypeDef,
  ExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExtendPaths$ {
  /** @deprecated use `ExtendPaths$inboundSchema` instead. */
  export const inboundSchema = ExtendPaths$inboundSchema;
  /** @deprecated use `ExtendPaths$outboundSchema` instead. */
  export const outboundSchema = ExtendPaths$outboundSchema;
  /** @deprecated use `ExtendPaths$Outbound` instead. */
  export type Outbound = ExtendPaths$Outbound;
}

export function extendPathsToJSON(extendPaths: ExtendPaths): string {
  return JSON.stringify(ExtendPaths$outboundSchema.parse(extendPaths));
}

export function extendPathsFromJSON(
  jsonString: string,
): SafeParseResult<ExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExtendPaths' from JSON`,
  );
}

/** @internal */
export const PassThrough$inboundSchema: z.ZodType<
  PassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(z.lazy(() => ExtendPaths$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type PassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<ExtendPaths$Outbound> | undefined;
};

/** @internal */
export const PassThrough$outboundSchema: z.ZodType<
  PassThrough$Outbound,
  z.ZodTypeDef,
  PassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(z.lazy(() => ExtendPaths$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PassThrough$ {
  /** @deprecated use `PassThrough$inboundSchema` instead. */
  export const inboundSchema = PassThrough$inboundSchema;
  /** @deprecated use `PassThrough$outboundSchema` instead. */
  export const outboundSchema = PassThrough$outboundSchema;
  /** @deprecated use `PassThrough$Outbound` instead. */
  export type Outbound = PassThrough$Outbound;
}

export function passThroughToJSON(passThrough: PassThrough): string {
  return JSON.stringify(PassThrough$outboundSchema.parse(passThrough));
}

export function passThroughFromJSON(
  jsonString: string,
): SafeParseResult<PassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PassThrough' from JSON`,
  );
}

/** @internal */
export const CompanyCreateRequest$inboundSchema: z.ZodType<
  CompanyCreateRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.nullable(z.string()),
  owner_id: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  vat_number: z.nullable(z.string()).optional(),
  currency: z.nullable(Currency$inboundSchema).optional(),
  status: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  annual_revenue: z.nullable(z.string()).optional(),
  number_of_employees: z.nullable(z.string()).optional(),
  industry: z.nullable(z.string()).optional(),
  ownership: z.nullable(z.string()).optional(),
  sales_tax_number: z.nullable(z.string()).optional(),
  payee_number: z.nullable(z.string()).optional(),
  abn_or_tfn: z.nullable(z.string()).optional(),
  abn_branch: z.nullable(z.string()).optional(),
  acn: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  bank_accounts: z.array(z.lazy(() => BankAccounts$inboundSchema)).optional(),
  websites: z.array(z.lazy(() => Websites$inboundSchema)).optional(),
  addresses: z.array(z.lazy(() => Addresses$inboundSchema)).optional(),
  social_links: z.array(z.lazy(() => SocialLinks$inboundSchema)).optional(),
  phone_numbers: z.array(z.lazy(() => PhoneNumbers$inboundSchema)).optional(),
  emails: z.array(z.lazy(() => Emails$inboundSchema)).optional(),
  row_type: z.lazy(() => CompanyRowType$inboundSchema).optional(),
  custom_fields: z.array(z.lazy(() => CustomFields$inboundSchema)).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  read_only: z.nullable(z.boolean()).optional(),
  salutation: z.nullable(z.string()).optional(),
  birthday: z.nullable(z.string().transform(v => new RFCDate(v))).optional(),
  pass_through: z.array(z.lazy(() => PassThrough$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "vat_number": "vatNumber",
    "annual_revenue": "annualRevenue",
    "number_of_employees": "numberOfEmployees",
    "sales_tax_number": "salesTaxNumber",
    "payee_number": "payeeNumber",
    "abn_or_tfn": "abnOrTfn",
    "abn_branch": "abnBranch",
    "first_name": "firstName",
    "last_name": "lastName",
    "bank_accounts": "bankAccounts",
    "social_links": "socialLinks",
    "phone_numbers": "phoneNumbers",
    "row_type": "rowType",
    "custom_fields": "customFields",
    "read_only": "readOnly",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type CompanyCreateRequest$Outbound = {
  name: string | null;
  owner_id?: string | null | undefined;
  image?: string | null | undefined;
  description?: string | null | undefined;
  vat_number?: string | null | undefined;
  currency?: string | null | undefined;
  status?: string | null | undefined;
  fax?: string | null | undefined;
  annual_revenue?: string | null | undefined;
  number_of_employees?: string | null | undefined;
  industry?: string | null | undefined;
  ownership?: string | null | undefined;
  sales_tax_number?: string | null | undefined;
  payee_number?: string | null | undefined;
  abn_or_tfn?: string | null | undefined;
  abn_branch?: string | null | undefined;
  acn?: string | null | undefined;
  first_name?: string | null | undefined;
  last_name?: string | null | undefined;
  bank_accounts?: Array<BankAccounts$Outbound> | undefined;
  websites?: Array<Websites$Outbound> | undefined;
  addresses?: Array<Addresses$Outbound> | undefined;
  social_links?: Array<SocialLinks$Outbound> | undefined;
  phone_numbers?: Array<PhoneNumbers$Outbound> | undefined;
  emails?: Array<Emails$Outbound> | undefined;
  row_type?: CompanyRowType$Outbound | undefined;
  custom_fields?: Array<CustomFields$Outbound> | undefined;
  tags?: Array<string> | null | undefined;
  read_only?: boolean | null | undefined;
  salutation?: string | null | undefined;
  birthday?: string | null | undefined;
  pass_through?: Array<PassThrough$Outbound> | undefined;
};

/** @internal */
export const CompanyCreateRequest$outboundSchema: z.ZodType<
  CompanyCreateRequest$Outbound,
  z.ZodTypeDef,
  CompanyCreateRequest
> = z.object({
  name: z.nullable(z.string()),
  ownerId: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  vatNumber: z.nullable(z.string()).optional(),
  currency: z.nullable(Currency$outboundSchema).optional(),
  status: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  annualRevenue: z.nullable(z.string()).optional(),
  numberOfEmployees: z.nullable(z.string()).optional(),
  industry: z.nullable(z.string()).optional(),
  ownership: z.nullable(z.string()).optional(),
  salesTaxNumber: z.nullable(z.string()).optional(),
  payeeNumber: z.nullable(z.string()).optional(),
  abnOrTfn: z.nullable(z.string()).optional(),
  abnBranch: z.nullable(z.string()).optional(),
  acn: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  bankAccounts: z.array(z.lazy(() => BankAccounts$outboundSchema)).optional(),
  websites: z.array(z.lazy(() => Websites$outboundSchema)).optional(),
  addresses: z.array(z.lazy(() => Addresses$outboundSchema)).optional(),
  socialLinks: z.array(z.lazy(() => SocialLinks$outboundSchema)).optional(),
  phoneNumbers: z.array(z.lazy(() => PhoneNumbers$outboundSchema)).optional(),
  emails: z.array(z.lazy(() => Emails$outboundSchema)).optional(),
  rowType: z.lazy(() => CompanyRowType$outboundSchema).optional(),
  customFields: z.array(z.lazy(() => CustomFields$outboundSchema)).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  readOnly: z.nullable(z.boolean()).optional(),
  salutation: z.nullable(z.string()).optional(),
  birthday: z.nullable(z.instanceof(RFCDate).transform(v => v.toString()))
    .optional(),
  passThrough: z.array(z.lazy(() => PassThrough$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    vatNumber: "vat_number",
    annualRevenue: "annual_revenue",
    numberOfEmployees: "number_of_employees",
    salesTaxNumber: "sales_tax_number",
    payeeNumber: "payee_number",
    abnOrTfn: "abn_or_tfn",
    abnBranch: "abn_branch",
    firstName: "first_name",
    lastName: "last_name",
    bankAccounts: "bank_accounts",
    socialLinks: "social_links",
    phoneNumbers: "phone_numbers",
    rowType: "row_type",
    customFields: "custom_fields",
    readOnly: "read_only",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyCreateRequest$ {
  /** @deprecated use `CompanyCreateRequest$inboundSchema` instead. */
  export const inboundSchema = CompanyCreateRequest$inboundSchema;
  /** @deprecated use `CompanyCreateRequest$outboundSchema` instead. */
  export const outboundSchema = CompanyCreateRequest$outboundSchema;
  /** @deprecated use `CompanyCreateRequest$Outbound` instead. */
  export type Outbound = CompanyCreateRequest$Outbound;
}

export function companyCreateRequestToJSON(
  companyCreateRequest: CompanyCreateRequest,
): string {
  return JSON.stringify(
    CompanyCreateRequest$outboundSchema.parse(companyCreateRequest),
  );
}

export function companyCreateRequestFromJSON(
  jsonString: string,
): SafeParseResult<CompanyCreateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompanyCreateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyCreateRequest' from JSON`,
  );
}

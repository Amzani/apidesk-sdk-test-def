/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Contains any custom mappings configured for the note resource. This object may include key-value pairs that map custom fields or identifiers to standard fields within the CRM, allowing for tailored data integration and retrieval.
 */
export type ListNotesResponseCustomMappings = {};

export type ListNotesResponseExtendPaths = {
  /**
   * Specifies the JSONPath string where the value should be applied within the note data structure. This path is crucial for targeting specific fields in the notes for updates or retrievals, ensuring precise data manipulation.
   */
  path: string;
  /**
   * Represents the value to be set at the specified JSONPath within the note data. This can be of any data type, allowing flexibility in the type of data that can be inserted or updated in the notes.
   */
  value?: any | undefined;
};

export type ListNotesResponsePassThrough = {
  /**
   * A string identifier for the service to which the pass_through data should be applied. This ensures that the custom data is correctly routed to the appropriate service during the retrieval of notes.
   */
  serviceId: string;
  /**
   * An optional string identifier for a specific workflow operation. This is useful when the retrieval of notes involves multiple downstream requests, allowing for precise tracking and application of the pass_through data.
   */
  operationId?: string | undefined;
  /**
   * An object that allows for direct extension with any properties. This flexible structure supports the inclusion of additional data fields that may be necessary for specific service integrations when retrieving notes.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects used for structured data modifications via paths. This property enables precise alterations to the data structure, facilitating advanced customization and integration capabilities when accessing notes.
   */
  extendPaths?: Array<ListNotesResponseExtendPaths> | undefined;
};

export type ListNotesResponseData = {
  /**
   * A unique string identifier for each note within the CRM. This ID is used to reference and manage individual notes programmatically, ensuring that each note can be distinctly accessed and manipulated.
   */
  id?: string | undefined;
  /**
   * The title or headline of the note, providing a brief summary or subject of the note's content. This string is useful for quickly identifying the note's purpose or topic within the list of notes.
   */
  title?: string | null | undefined;
  /**
   * The main body of the note, containing detailed text information. This string holds the full content of the note, which can include descriptions, comments, or any other relevant information captured in the note.
   */
  content?: string | null | undefined;
  /**
   * The unique identifier of the user who owns or created the note. This string helps in associating the note with a specific user, facilitating user-specific operations and access control within the CRM.
   */
  ownerId?: string | null | undefined;
  /**
   * The unique identifier of the contact associated with the note. This ID is a string that links the note to a specific contact within the CRM, allowing developers to easily retrieve or reference contact-related notes. It is optional and may not be present if the note is not linked to a contact.
   */
  contactId?: string | null | undefined;
  /**
   * The unique identifier of the company associated with the note. This string ID connects the note to a particular company in the CRM, facilitating the retrieval of company-related notes. It is optional and may be absent if the note is not linked to a company.
   */
  companyId?: string | null | undefined;
  /**
   * The unique identifier of the opportunity associated with the note. This string serves as a link between the note and a specific opportunity in the CRM, enabling developers to access notes related to particular opportunities. It is optional and may not be included if the note is not tied to an opportunity.
   */
  opportunityId?: string | null | undefined;
  /**
   * The unique identifier of the lead associated with the note. This ID is a string that connects the note to a specific lead within the CRM, allowing for easy retrieval of lead-related notes. It is optional and may not be present if the note is not linked to a lead.
   */
  leadId?: string | null | undefined;
  /**
   * Indicates whether the note is currently active. This boolean value helps developers determine the status of the note, where 'true' signifies an active note and 'false' indicates it is inactive. This property is optional and may not be included in all responses.
   */
  active?: boolean | null | undefined;
  /**
   * Contains any custom mappings configured for the note resource. This object may include key-value pairs that map custom fields or identifiers to standard fields within the CRM, allowing for tailored data integration and retrieval.
   */
  customMappings?: ListNotesResponseCustomMappings | null | undefined;
  /**
   * The identifier or username of the user who last modified the note. This string helps track changes and maintain an audit trail of user interactions with the note data.
   */
  updatedBy?: string | null | undefined;
  /**
   * The identifier or username of the user who originally created the note. This information is crucial for understanding the origin of the note and attributing it to the correct user within the CRM system.
   */
  createdBy?: string | null | undefined;
  /**
   * A timestamp indicating when the note was last updated, formatted in ISO 8601. This allows developers to determine the recency of changes and synchronize data accordingly.
   */
  updatedAt?: string | null | undefined;
  /**
   * A timestamp indicating when the note was initially created, formatted in ISO 8601. This provides a historical context for the note, useful for chronological sorting and data analysis.
   */
  createdAt?: string | null | undefined;
  /**
   * An array containing service-specific custom data or structured modifications. This property is used to pass additional information when retrieving notes, allowing for enhanced customization and integration with specific services.
   */
  passThrough?: Array<ListNotesResponsePassThrough> | undefined;
};

/**
 * Provides cursors for navigating between pages of results in the API. This object includes pointers to the next or previous pages, facilitating seamless data retrieval across multiple requests.
 */
export type ListNotesResponseCursors = {
  /**
   * A string representing the cursor used to navigate to the previous page of results in the API response. This is useful for implementing backward pagination in applications that consume the API.
   */
  previous?: string | null | undefined;
  /**
   * A string that indicates the cursor for the current page of results in the API response. This helps in tracking the current position within the paginated data set.
   */
  current?: string | null | undefined;
  /**
   * A string representing the cursor used to navigate to the next page of results in the API response. This is essential for forward pagination, allowing seamless data retrieval across multiple pages.
   */
  next?: string | null | undefined;
};

/**
 * Contains metadata about the response, including pagination details and other relevant information. This object helps in understanding the context of the returned data, such as how many items are included and navigation aids for paginated results.
 */
export type ListNotesResponseMeta = {
  /**
   * Indicates the number of note items returned in the current response page. This integer helps developers understand the volume of data retrieved and manage pagination effectively.
   */
  itemsOnPage?: number | undefined;
  /**
   * Provides cursors for navigating between pages of results in the API. This object includes pointers to the next or previous pages, facilitating seamless data retrieval across multiple requests.
   */
  cursors?: ListNotesResponseCursors | undefined;
};

/**
 * An object containing URLs that facilitate navigation to the previous or next pages of results in the API response. This is crucial for implementing pagination controls in client applications.
 */
export type ListNotesResponseLinks = {
  /**
   * A string URL that directs to the previous page of results in the API response. This link is part of the pagination mechanism, enabling users to easily access earlier data sets.
   */
  previous?: string | null | undefined;
  /**
   * This property contains the URL link to the current page of results in the API response. It is formatted as a string URL and is used to reload or refresh the current set of notes being viewed. This is particularly useful for maintaining the current view state in applications that paginate through CRM notes.
   */
  current?: string | undefined;
  /**
   * This property provides the URL link to the next page of results in the API response. It is formatted as a string URL and allows developers to programmatically navigate to the subsequent set of notes. This is essential for implementing pagination in applications that need to handle large volumes of CRM note data efficiently.
   */
  next?: string | null | undefined;
};

/**
 * Notes
 */
export type ListNotesResponse = {
  /**
   * The HTTP response status code indicating the result of the API request. This integer value helps determine if the request was successful (e.g., 200 for success) or if there was an error (e.g., 404 for not found). It is crucial for error handling and debugging in client applications.
   */
  statusCode: number;
  /**
   * A textual representation of the HTTP response status, such as 'OK' for a successful request or 'Not Found' for an error. This string provides a human-readable status that complements the status code, aiding in quick understanding of the response outcome.
   */
  status: string;
  /**
   * The Apideck ID of the service provider from which the notes are retrieved. This string uniquely identifies the service within the Apideck ecosystem, ensuring that the data is sourced from the correct provider, especially when multiple services are integrated.
   */
  service: string;
  /**
   * The name of the unified API resource, in this case, 'notes', indicating the type of data returned by the operation. This string helps developers understand the context of the data, ensuring they are working with the correct resource type in their applications.
   */
  resource: string;
  /**
   * The specific operation performed by the API, represented as a string. For this endpoint, it would typically be 'notesAll', indicating that the operation involved retrieving all notes. This helps in logging and tracking the actions performed via the API.
   */
  operation: string;
  /**
   * An array containing all the notes retrieved from the CRM system. Each element in the array represents a single note object, which includes detailed information such as the note's ID, title, content, and owner. This array is essential for accessing and processing multiple notes in a single API call.
   */
  data: Array<ListNotesResponseData>;
  /**
   * Contains metadata about the response, including pagination details and other relevant information. This object helps in understanding the context of the returned data, such as how many items are included and navigation aids for paginated results.
   */
  meta?: ListNotesResponseMeta | undefined;
  /**
   * An object containing URLs that facilitate navigation to the previous or next pages of results in the API response. This is crucial for implementing pagination controls in client applications.
   */
  links?: ListNotesResponseLinks | undefined;
};

/** @internal */
export const ListNotesResponseCustomMappings$inboundSchema: z.ZodType<
  ListNotesResponseCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ListNotesResponseCustomMappings$Outbound = {};

/** @internal */
export const ListNotesResponseCustomMappings$outboundSchema: z.ZodType<
  ListNotesResponseCustomMappings$Outbound,
  z.ZodTypeDef,
  ListNotesResponseCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListNotesResponseCustomMappings$ {
  /** @deprecated use `ListNotesResponseCustomMappings$inboundSchema` instead. */
  export const inboundSchema = ListNotesResponseCustomMappings$inboundSchema;
  /** @deprecated use `ListNotesResponseCustomMappings$outboundSchema` instead. */
  export const outboundSchema = ListNotesResponseCustomMappings$outboundSchema;
  /** @deprecated use `ListNotesResponseCustomMappings$Outbound` instead. */
  export type Outbound = ListNotesResponseCustomMappings$Outbound;
}

export function listNotesResponseCustomMappingsToJSON(
  listNotesResponseCustomMappings: ListNotesResponseCustomMappings,
): string {
  return JSON.stringify(
    ListNotesResponseCustomMappings$outboundSchema.parse(
      listNotesResponseCustomMappings,
    ),
  );
}

export function listNotesResponseCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<ListNotesResponseCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListNotesResponseCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListNotesResponseCustomMappings' from JSON`,
  );
}

/** @internal */
export const ListNotesResponseExtendPaths$inboundSchema: z.ZodType<
  ListNotesResponseExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type ListNotesResponseExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const ListNotesResponseExtendPaths$outboundSchema: z.ZodType<
  ListNotesResponseExtendPaths$Outbound,
  z.ZodTypeDef,
  ListNotesResponseExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListNotesResponseExtendPaths$ {
  /** @deprecated use `ListNotesResponseExtendPaths$inboundSchema` instead. */
  export const inboundSchema = ListNotesResponseExtendPaths$inboundSchema;
  /** @deprecated use `ListNotesResponseExtendPaths$outboundSchema` instead. */
  export const outboundSchema = ListNotesResponseExtendPaths$outboundSchema;
  /** @deprecated use `ListNotesResponseExtendPaths$Outbound` instead. */
  export type Outbound = ListNotesResponseExtendPaths$Outbound;
}

export function listNotesResponseExtendPathsToJSON(
  listNotesResponseExtendPaths: ListNotesResponseExtendPaths,
): string {
  return JSON.stringify(
    ListNotesResponseExtendPaths$outboundSchema.parse(
      listNotesResponseExtendPaths,
    ),
  );
}

export function listNotesResponseExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<ListNotesResponseExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListNotesResponseExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListNotesResponseExtendPaths' from JSON`,
  );
}

/** @internal */
export const ListNotesResponsePassThrough$inboundSchema: z.ZodType<
  ListNotesResponsePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => ListNotesResponseExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type ListNotesResponsePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<ListNotesResponseExtendPaths$Outbound> | undefined;
};

/** @internal */
export const ListNotesResponsePassThrough$outboundSchema: z.ZodType<
  ListNotesResponsePassThrough$Outbound,
  z.ZodTypeDef,
  ListNotesResponsePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => ListNotesResponseExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListNotesResponsePassThrough$ {
  /** @deprecated use `ListNotesResponsePassThrough$inboundSchema` instead. */
  export const inboundSchema = ListNotesResponsePassThrough$inboundSchema;
  /** @deprecated use `ListNotesResponsePassThrough$outboundSchema` instead. */
  export const outboundSchema = ListNotesResponsePassThrough$outboundSchema;
  /** @deprecated use `ListNotesResponsePassThrough$Outbound` instead. */
  export type Outbound = ListNotesResponsePassThrough$Outbound;
}

export function listNotesResponsePassThroughToJSON(
  listNotesResponsePassThrough: ListNotesResponsePassThrough,
): string {
  return JSON.stringify(
    ListNotesResponsePassThrough$outboundSchema.parse(
      listNotesResponsePassThrough,
    ),
  );
}

export function listNotesResponsePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<ListNotesResponsePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListNotesResponsePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListNotesResponsePassThrough' from JSON`,
  );
}

/** @internal */
export const ListNotesResponseData$inboundSchema: z.ZodType<
  ListNotesResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  owner_id: z.nullable(z.string()).optional(),
  contact_id: z.nullable(z.string()).optional(),
  company_id: z.nullable(z.string()).optional(),
  opportunity_id: z.nullable(z.string()).optional(),
  lead_id: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  custom_mappings: z.nullable(
    z.lazy(() => ListNotesResponseCustomMappings$inboundSchema),
  ).optional(),
  updated_by: z.nullable(z.string()).optional(),
  created_by: z.nullable(z.string()).optional(),
  updated_at: z.nullable(z.string()).optional(),
  created_at: z.nullable(z.string()).optional(),
  pass_through: z.array(
    z.lazy(() => ListNotesResponsePassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "contact_id": "contactId",
    "company_id": "companyId",
    "opportunity_id": "opportunityId",
    "lead_id": "leadId",
    "custom_mappings": "customMappings",
    "updated_by": "updatedBy",
    "created_by": "createdBy",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type ListNotesResponseData$Outbound = {
  id?: string | undefined;
  title?: string | null | undefined;
  content?: string | null | undefined;
  owner_id?: string | null | undefined;
  contact_id?: string | null | undefined;
  company_id?: string | null | undefined;
  opportunity_id?: string | null | undefined;
  lead_id?: string | null | undefined;
  active?: boolean | null | undefined;
  custom_mappings?: ListNotesResponseCustomMappings$Outbound | null | undefined;
  updated_by?: string | null | undefined;
  created_by?: string | null | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  pass_through?: Array<ListNotesResponsePassThrough$Outbound> | undefined;
};

/** @internal */
export const ListNotesResponseData$outboundSchema: z.ZodType<
  ListNotesResponseData$Outbound,
  z.ZodTypeDef,
  ListNotesResponseData
> = z.object({
  id: z.string().optional(),
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  ownerId: z.nullable(z.string()).optional(),
  contactId: z.nullable(z.string()).optional(),
  companyId: z.nullable(z.string()).optional(),
  opportunityId: z.nullable(z.string()).optional(),
  leadId: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  customMappings: z.nullable(
    z.lazy(() => ListNotesResponseCustomMappings$outboundSchema),
  ).optional(),
  updatedBy: z.nullable(z.string()).optional(),
  createdBy: z.nullable(z.string()).optional(),
  updatedAt: z.nullable(z.string()).optional(),
  createdAt: z.nullable(z.string()).optional(),
  passThrough: z.array(
    z.lazy(() => ListNotesResponsePassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    contactId: "contact_id",
    companyId: "company_id",
    opportunityId: "opportunity_id",
    leadId: "lead_id",
    customMappings: "custom_mappings",
    updatedBy: "updated_by",
    createdBy: "created_by",
    updatedAt: "updated_at",
    createdAt: "created_at",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListNotesResponseData$ {
  /** @deprecated use `ListNotesResponseData$inboundSchema` instead. */
  export const inboundSchema = ListNotesResponseData$inboundSchema;
  /** @deprecated use `ListNotesResponseData$outboundSchema` instead. */
  export const outboundSchema = ListNotesResponseData$outboundSchema;
  /** @deprecated use `ListNotesResponseData$Outbound` instead. */
  export type Outbound = ListNotesResponseData$Outbound;
}

export function listNotesResponseDataToJSON(
  listNotesResponseData: ListNotesResponseData,
): string {
  return JSON.stringify(
    ListNotesResponseData$outboundSchema.parse(listNotesResponseData),
  );
}

export function listNotesResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<ListNotesResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListNotesResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListNotesResponseData' from JSON`,
  );
}

/** @internal */
export const ListNotesResponseCursors$inboundSchema: z.ZodType<
  ListNotesResponseCursors,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type ListNotesResponseCursors$Outbound = {
  previous?: string | null | undefined;
  current?: string | null | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const ListNotesResponseCursors$outboundSchema: z.ZodType<
  ListNotesResponseCursors$Outbound,
  z.ZodTypeDef,
  ListNotesResponseCursors
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListNotesResponseCursors$ {
  /** @deprecated use `ListNotesResponseCursors$inboundSchema` instead. */
  export const inboundSchema = ListNotesResponseCursors$inboundSchema;
  /** @deprecated use `ListNotesResponseCursors$outboundSchema` instead. */
  export const outboundSchema = ListNotesResponseCursors$outboundSchema;
  /** @deprecated use `ListNotesResponseCursors$Outbound` instead. */
  export type Outbound = ListNotesResponseCursors$Outbound;
}

export function listNotesResponseCursorsToJSON(
  listNotesResponseCursors: ListNotesResponseCursors,
): string {
  return JSON.stringify(
    ListNotesResponseCursors$outboundSchema.parse(listNotesResponseCursors),
  );
}

export function listNotesResponseCursorsFromJSON(
  jsonString: string,
): SafeParseResult<ListNotesResponseCursors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListNotesResponseCursors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListNotesResponseCursors' from JSON`,
  );
}

/** @internal */
export const ListNotesResponseMeta$inboundSchema: z.ZodType<
  ListNotesResponseMeta,
  z.ZodTypeDef,
  unknown
> = z.object({
  items_on_page: z.number().int().optional(),
  cursors: z.lazy(() => ListNotesResponseCursors$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "items_on_page": "itemsOnPage",
  });
});

/** @internal */
export type ListNotesResponseMeta$Outbound = {
  items_on_page?: number | undefined;
  cursors?: ListNotesResponseCursors$Outbound | undefined;
};

/** @internal */
export const ListNotesResponseMeta$outboundSchema: z.ZodType<
  ListNotesResponseMeta$Outbound,
  z.ZodTypeDef,
  ListNotesResponseMeta
> = z.object({
  itemsOnPage: z.number().int().optional(),
  cursors: z.lazy(() => ListNotesResponseCursors$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    itemsOnPage: "items_on_page",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListNotesResponseMeta$ {
  /** @deprecated use `ListNotesResponseMeta$inboundSchema` instead. */
  export const inboundSchema = ListNotesResponseMeta$inboundSchema;
  /** @deprecated use `ListNotesResponseMeta$outboundSchema` instead. */
  export const outboundSchema = ListNotesResponseMeta$outboundSchema;
  /** @deprecated use `ListNotesResponseMeta$Outbound` instead. */
  export type Outbound = ListNotesResponseMeta$Outbound;
}

export function listNotesResponseMetaToJSON(
  listNotesResponseMeta: ListNotesResponseMeta,
): string {
  return JSON.stringify(
    ListNotesResponseMeta$outboundSchema.parse(listNotesResponseMeta),
  );
}

export function listNotesResponseMetaFromJSON(
  jsonString: string,
): SafeParseResult<ListNotesResponseMeta, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListNotesResponseMeta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListNotesResponseMeta' from JSON`,
  );
}

/** @internal */
export const ListNotesResponseLinks$inboundSchema: z.ZodType<
  ListNotesResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type ListNotesResponseLinks$Outbound = {
  previous?: string | null | undefined;
  current?: string | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const ListNotesResponseLinks$outboundSchema: z.ZodType<
  ListNotesResponseLinks$Outbound,
  z.ZodTypeDef,
  ListNotesResponseLinks
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListNotesResponseLinks$ {
  /** @deprecated use `ListNotesResponseLinks$inboundSchema` instead. */
  export const inboundSchema = ListNotesResponseLinks$inboundSchema;
  /** @deprecated use `ListNotesResponseLinks$outboundSchema` instead. */
  export const outboundSchema = ListNotesResponseLinks$outboundSchema;
  /** @deprecated use `ListNotesResponseLinks$Outbound` instead. */
  export type Outbound = ListNotesResponseLinks$Outbound;
}

export function listNotesResponseLinksToJSON(
  listNotesResponseLinks: ListNotesResponseLinks,
): string {
  return JSON.stringify(
    ListNotesResponseLinks$outboundSchema.parse(listNotesResponseLinks),
  );
}

export function listNotesResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListNotesResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListNotesResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListNotesResponseLinks' from JSON`,
  );
}

/** @internal */
export const ListNotesResponse$inboundSchema: z.ZodType<
  ListNotesResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => ListNotesResponseData$inboundSchema)),
  meta: z.lazy(() => ListNotesResponseMeta$inboundSchema).optional(),
  links: z.lazy(() => ListNotesResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type ListNotesResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: Array<ListNotesResponseData$Outbound>;
  meta?: ListNotesResponseMeta$Outbound | undefined;
  links?: ListNotesResponseLinks$Outbound | undefined;
};

/** @internal */
export const ListNotesResponse$outboundSchema: z.ZodType<
  ListNotesResponse$Outbound,
  z.ZodTypeDef,
  ListNotesResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => ListNotesResponseData$outboundSchema)),
  meta: z.lazy(() => ListNotesResponseMeta$outboundSchema).optional(),
  links: z.lazy(() => ListNotesResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListNotesResponse$ {
  /** @deprecated use `ListNotesResponse$inboundSchema` instead. */
  export const inboundSchema = ListNotesResponse$inboundSchema;
  /** @deprecated use `ListNotesResponse$outboundSchema` instead. */
  export const outboundSchema = ListNotesResponse$outboundSchema;
  /** @deprecated use `ListNotesResponse$Outbound` instead. */
  export type Outbound = ListNotesResponse$Outbound;
}

export function listNotesResponseToJSON(
  listNotesResponse: ListNotesResponse,
): string {
  return JSON.stringify(
    ListNotesResponse$outboundSchema.parse(listNotesResponse),
  );
}

export function listNotesResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListNotesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListNotesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListNotesResponse' from JSON`,
  );
}

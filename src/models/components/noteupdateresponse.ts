/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The 'data' object serves as the primary container for the response payload, encapsulating all relevant information about the updated note. This object is always included in the response to ensure that the client receives a structured and comprehensive representation of the note's current state after the update operation. It provides a clear context for the changes made and is essential for verifying the success of the update request.
 */
export type NoteUpdateResponseUnifiedId = {
  /**
   * The 'data.id' field represents the unique identifier of the user resource that has been updated. This identifier is crucial for confirming that the correct user record was modified. It is always included in the response to ensure that the client can verify the specific user record that was affected by the update operation.
   */
  id: string;
};

/**
 * Note updated
 */
export type NoteUpdateResponse = {
  /**
   * The HTTP response status code returned by the server. This integer value indicates the result of the PATCH operation on the note. A status code of 200 signifies a successful update, while other codes may indicate errors or issues with the request. It is always included in the response to inform the client of the outcome of their request.
   */
  statusCode: number;
  /**
   * A textual representation of the HTTP response status. This string provides a human-readable explanation of the status code, such as 'OK' for a successful operation. It complements the status code by offering additional context and is always included to aid in understanding the response.
   */
  status: string;
  /**
   * The Apideck ID of the service provider involved in the operation. This string uniquely identifies which service provider's integration was used to update the note. It is crucial when multiple services are integrated, ensuring the response is correctly attributed to the right service. Always included to maintain clarity in multi-service environments.
   */
  service: string;
  /**
   * The name of the unified API resource that was targeted by the operation. This string identifies the specific type of resource, such as 'note', that was updated. It helps in understanding what kind of entity was affected by the PATCH request and is always included to provide context about the operation's focus.
   */
  resource: string;
  /**
   * The specific operation that was performed, represented as a string. In this context, it indicates the 'notesUpdate' operation, confirming that the request was processed as intended. This property is always included to verify the action taken and ensure that the correct operation was executed.
   */
  operation: string;
  /**
   * The 'data' object serves as the primary container for the response payload, encapsulating all relevant information about the updated note. This object is always included in the response to ensure that the client receives a structured and comprehensive representation of the note's current state after the update operation. It provides a clear context for the changes made and is essential for verifying the success of the update request.
   */
  data: NoteUpdateResponseUnifiedId;
};

/** @internal */
export const NoteUpdateResponseUnifiedId$inboundSchema: z.ZodType<
  NoteUpdateResponseUnifiedId,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

/** @internal */
export type NoteUpdateResponseUnifiedId$Outbound = {
  id: string;
};

/** @internal */
export const NoteUpdateResponseUnifiedId$outboundSchema: z.ZodType<
  NoteUpdateResponseUnifiedId$Outbound,
  z.ZodTypeDef,
  NoteUpdateResponseUnifiedId
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteUpdateResponseUnifiedId$ {
  /** @deprecated use `NoteUpdateResponseUnifiedId$inboundSchema` instead. */
  export const inboundSchema = NoteUpdateResponseUnifiedId$inboundSchema;
  /** @deprecated use `NoteUpdateResponseUnifiedId$outboundSchema` instead. */
  export const outboundSchema = NoteUpdateResponseUnifiedId$outboundSchema;
  /** @deprecated use `NoteUpdateResponseUnifiedId$Outbound` instead. */
  export type Outbound = NoteUpdateResponseUnifiedId$Outbound;
}

export function noteUpdateResponseUnifiedIdToJSON(
  noteUpdateResponseUnifiedId: NoteUpdateResponseUnifiedId,
): string {
  return JSON.stringify(
    NoteUpdateResponseUnifiedId$outboundSchema.parse(
      noteUpdateResponseUnifiedId,
    ),
  );
}

export function noteUpdateResponseUnifiedIdFromJSON(
  jsonString: string,
): SafeParseResult<NoteUpdateResponseUnifiedId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteUpdateResponseUnifiedId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteUpdateResponseUnifiedId' from JSON`,
  );
}

/** @internal */
export const NoteUpdateResponse$inboundSchema: z.ZodType<
  NoteUpdateResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => NoteUpdateResponseUnifiedId$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type NoteUpdateResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: NoteUpdateResponseUnifiedId$Outbound;
};

/** @internal */
export const NoteUpdateResponse$outboundSchema: z.ZodType<
  NoteUpdateResponse$Outbound,
  z.ZodTypeDef,
  NoteUpdateResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => NoteUpdateResponseUnifiedId$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteUpdateResponse$ {
  /** @deprecated use `NoteUpdateResponse$inboundSchema` instead. */
  export const inboundSchema = NoteUpdateResponse$inboundSchema;
  /** @deprecated use `NoteUpdateResponse$outboundSchema` instead. */
  export const outboundSchema = NoteUpdateResponse$outboundSchema;
  /** @deprecated use `NoteUpdateResponse$Outbound` instead. */
  export type Outbound = NoteUpdateResponse$Outbound;
}

export function noteUpdateResponseToJSON(
  noteUpdateResponse: NoteUpdateResponse,
): string {
  return JSON.stringify(
    NoteUpdateResponse$outboundSchema.parse(noteUpdateResponse),
  );
}

export function noteUpdateResponseFromJSON(
  jsonString: string,
): SafeParseResult<NoteUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteUpdateResponse' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
 */
export const UsersListResponseType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Office: "office",
  Shipping: "shipping",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
 */
export type UsersListResponseType = ClosedEnum<typeof UsersListResponseType>;

export type UsersListResponseAddresses = {
  /**
   * A unique identifier for each address within the user's address array. This ID is crucial for distinguishing between different address records, especially when updating or deleting specific addresses. It ensures that each address can be individually referenced and managed within the CRM system, maintaining data integrity and accuracy.
   */
  id?: string | null | undefined;
  /**
   * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
   */
  type?: UsersListResponseType | null | undefined;
  /**
   * The full address in a single string format, used when structured address data is not available. This field is essential for APIs that do not support detailed address components, allowing for a flexible representation of address information. It is particularly useful for quick data entry and display purposes.
   */
  string?: string | null | undefined;
  /**
   * A descriptive name for the address, often used to label or identify the address within the user's profile. This can include names like 'Headquarters', 'Main Office', or 'John's Apartment', providing a human-readable identifier that simplifies address management and selection within the CRM.
   */
  name?: string | null | undefined;
  /**
   * Line 1 of the address e.g. number, street, suite, apt #, etc.
   */
  line1?: string | null | undefined;
  /**
   * Line 2 of the address
   */
  line2?: string | null | undefined;
  /**
   * Line 3 of the address
   */
  line3?: string | null | undefined;
  /**
   * Line 4 of the address
   */
  line4?: string | null | undefined;
  /**
   * Street number
   */
  streetNumber?: string | null | undefined;
  /**
   * The name of the city associated with the user's address. This field is used to specify the city where the user resides or is located. It is important for geographical identification and can be used for location-based services or analytics. Ensure the city name is spelled correctly to maintain data accuracy and integrity within the CRM system.
   */
  city?: string | null | undefined;
  /**
   * The name of the state or region associated with the user's address. This field helps in identifying the specific administrative area within a country where the user is located. It is crucial for regional segmentation and can aid in compliance with local regulations. Ensure the state name is accurate to facilitate proper data management and reporting.
   */
  state?: string | null | undefined;
  /**
   * The postal code or equivalent for the user's address. This field is essential for precise location identification and is often used in mailing and shipping processes. It can also be used for demographic analysis and service eligibility checks. Ensure the postal code is valid and corresponds to the correct city and state to avoid errors in data processing.
   */
  postalCode?: string | null | undefined;
  /**
   * The country code for the user's address, following the ISO 3166-1 alpha-2 standard. This field is vital for internationalization and ensures that the user's location is correctly identified on a global scale. It supports cross-border operations and compliance with international standards. Ensure the country code is accurate to maintain consistency in global data management.
   */
  country?: string | null | undefined;
  /**
   * The latitude coordinate of the user's address. This field provides the geographical latitude, which is used in mapping and location-based services. It is important for applications that require precise geolocation, such as delivery services or geographic analysis. Ensure the latitude is accurate to enhance the reliability of location-dependent operations.
   */
  latitude?: string | null | undefined;
  /**
   * The longitude coordinate of the address, representing the east-west position on the Earth's surface. This value is crucial for geolocation services and mapping functionalities within the CRM, enabling precise location tracking and integration with geographic information systems. It should be a valid string representation of a decimal degree, typically ranging from -180.0 to 180.0.
   */
  longitude?: string | null | undefined;
  /**
   * This field captures the sublocality or county of the address, providing additional geographic context. It is particularly useful for regional segmentation and analysis, allowing for more granular data categorization and reporting. The county name should be accurately spelled to ensure consistency across records.
   */
  county?: string | null | undefined;
  /**
   * The full name of the primary contact person associated with the address. This information is vital for personalized communication and relationship management within the CRM. It should include both first and last names, and be kept up-to-date to reflect any changes in contact personnel.
   */
  contactName?: string | null | undefined;
  /**
   * The salutation or title used for the contact person at the address, such as Mr., Ms., Dr., etc. This field enhances formal communication and is important for maintaining professional etiquette in correspondence. It should be chosen based on the contact's preference and cultural norms.
   */
  salutation?: string | null | undefined;
  /**
   * The primary phone number associated with the address, used for direct communication with the contact person. This number should be formatted according to international standards to ensure it can be dialed from any location. It is essential for timely and effective communication, especially in customer service scenarios.
   */
  phoneNumber?: string | null | undefined;
  /**
   * The fax number associated with the user's address. This field allows for the inclusion of traditional communication methods, which may be necessary for certain business transactions or legal documentation. While not commonly used in modern digital communications, maintaining a fax number can be crucial for businesses that still rely on this method. Ensure the number is formatted correctly to avoid transmission errors.
   */
  fax?: string | null | undefined;
  /**
   * The email address linked to the user's address, serving as a primary mode of digital communication. This field is essential for sending notifications, updates, and other important information directly to the user. It should be a valid email format to ensure successful delivery and communication. Keeping this information up-to-date is vital for maintaining effective contact with the user.
   */
  email?: string | null | undefined;
  /**
   * The website URL associated with the user's address, providing a digital point of reference or contact. This can be used to direct users to a personal or business website, offering more information or services. Ensure the URL is complete and correctly formatted to facilitate seamless access. This field supports the user's digital presence and connectivity.
   */
  website?: string | null | undefined;
  /**
   * Additional notes related to the user's address, offering space for any extra information that might be relevant but does not fit into other predefined fields. This could include special delivery instructions, historical data, or personal preferences. These notes can be crucial for personalized service and ensuring all relevant details are captured.
   */
  notes?: string | null | undefined;
  /**
   * A binary value used to track changes to the user's address object, ensuring data integrity and preventing update conflicts. This field is automatically incremented with each update, allowing the system to detect concurrent modifications and manage them appropriately. It is crucial for maintaining accurate and consistent data across the CRM system, especially in environments with multiple users accessing the same records.
   */
  rowVersion?: string | null | undefined;
};

/**
 * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
 */
export const UsersListResponseDataType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Work: "work",
  Office: "office",
  Mobile: "mobile",
  Assistant: "assistant",
  Fax: "fax",
  DirectDialIn: "direct-dial-in",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
 */
export type UsersListResponseDataType = ClosedEnum<
  typeof UsersListResponseDataType
>;

export type UsersListResponsePhoneNumbers = {
  /**
   * A unique identifier for each phone number entry within the user's phone numbers array. This ID is crucial for distinguishing between different phone numbers, especially when updating or deleting specific numbers. It ensures that operations are performed on the correct phone number entry, maintaining data integrity within the user's contact information.
   */
  id?: string | null | undefined;
  /**
   * The international dialing code associated with the phone number, such as '+1' for the United States. This field is essential for ensuring that phone numbers are formatted correctly for international dialing and can be used to validate the geographical origin of the number. It helps in standardizing phone numbers across different regions and is critical for applications that involve international communication.
   */
  countryCode?: string | null | undefined;
  /**
   * The regional area code that precedes the local phone number, such as '323' for parts of Los Angeles. This code is important for routing calls within specific geographic areas and is a key component of the full phone number. Including the area code ensures that the phone number is complete and can be dialed correctly from both local and international locations.
   */
  areaCode?: string | null | undefined;
  /**
   * The main part of the phone number, excluding the country and area codes. This field is required as it represents the actual number that will be dialed within the specified area and country codes. It is the core component of the user's contact information and must be accurate to ensure successful communication. This field is mandatory to ensure that there is a valid number associated with the user.
   */
  number: string;
  /**
   * The extension of the phone number, typically used in corporate environments to direct calls to specific departments or employees. This field is optional and should be used when the phone number is part of a larger system, such as a PBX, where extensions are necessary for routing calls internally. Including an extension ensures that calls reach the intended recipient without delay.
   */
  extension?: string | null | undefined;
  /**
   * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
   */
  type?: UsersListResponseDataType | null | undefined;
};

/**
 * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
 */
export const UsersListResponseDataEmailsType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
 */
export type UsersListResponseDataEmailsType = ClosedEnum<
  typeof UsersListResponseDataEmailsType
>;

export type UsersListResponseEmails = {
  /**
   * A unique identifier for each email address within the user's email collection. This ID is used to distinguish between multiple email addresses associated with a single user, allowing for precise updates and management of contact information. It is optional but can be useful for operations that require specific email targeting.
   */
  id?: string | null | undefined;
  /**
   * The actual email address used for electronic communication with the user. This field is required and must be a valid email format to ensure successful delivery of messages. It serves as a primary contact method and is essential for user engagement and CRM operations.
   */
  email: string | null;
  /**
   * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
   */
  type?: UsersListResponseDataEmailsType | null | undefined;
};

/**
 * Contains any custom field mappings that have been configured for the user resource. This is particularly useful when integrating with external systems that require specific data formats or field names. It allows for flexible data handling and ensures that user data can be accurately synchronized across different platforms. This field is optional and should be used when custom integration requirements exist.
 */
export type UsersListResponseCustomMappings = {};

export type UsersListResponseExtendPaths = {
  /**
   * A JSONPath string that specifies the exact location within the user record where the value should be applied. This is essential for making precise updates to nested fields, ensuring that changes are made only to the intended parts of the data structure. The path must be valid and correspond to an existing field within the user record.
   */
  path: string;
  /**
   * This property represents the specific value that you wish to assign to a designated path within the user record. It can be of any data type, such as a string, number, boolean, or object, depending on the field being updated. The flexibility of this property allows for a wide range of updates, from simple text changes to complex data structures. In the context of the `usersUpdate` operation, this property is crucial for specifying the exact data modification you intend to make, ensuring that only the targeted fields are altered without affecting other data. Proper validation should be applied to ensure the value is compatible with the field's expected data type and business rules. Common use cases include updating user contact information, preferences, or custom attributes specific to your CRM's schema.
   */
  value?: any | undefined;
};

export type UsersListResponsePassThrough = {
  /**
   * The unique identifier for the specific service to which this pass_through should be applied. This is crucial for directing the update operation to the correct service within the CRM system, ensuring that the modifications are executed in the appropriate context. It must be a valid service ID that corresponds to an active service integration, and it is required for the operation to proceed.
   */
  serviceId: string;
  /**
   * An optional identifier for a specific workflow operation within the CRM system to which this pass_through should be applied. This is particularly useful for Unify calls that involve multiple downstream requests, allowing for precise targeting and execution of specific operations. If provided, it should match an existing operation ID to ensure correct processing.
   */
  operationId?: string | undefined;
  /**
   * A flexible object that allows for the inclusion of any additional properties needed for direct extension of the user record. This can be used to add custom fields or metadata that are not part of the standard user schema, providing a way to tailor the user data to specific business needs. The structure of this object should align with the CRM's data model to ensure compatibility.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects designed for structured data modifications via specified paths. This allows for precise updates to nested data structures within the user record, enabling complex modifications without altering unrelated data. Each object in the array should define a clear path and value to be applied, ensuring targeted updates.
   */
  extendPaths?: Array<UsersListResponseExtendPaths> | undefined;
};

export type UsersListResponseData = {
  /**
   * The unique identifier for the user. This ID is crucial for pinpointing the exact user record you wish to update within the CRM system. It ensures that modifications are applied to the correct user, maintaining data integrity. Typically, this ID is generated by the system and should be used consistently across all operations involving this user.
   */
  id?: string | undefined;
  /**
   * The parent user ID, which links this user to a parent account or entity within the CRM. This relationship is important for hierarchical data structures, such as in organizations where users may report to a parent user or belong to a parent group. It helps in organizing users under a common entity for better management and reporting.
   */
  parentId?: string | null | undefined;
  /**
   * The username of the user, serving as a unique identifier for login and authentication purposes. This field is essential for user access and identity verification within the CRM. It should be unique across the system to prevent conflicts and ensure secure access.
   */
  username?: string | null | undefined;
  /**
   * The first name of the person, used for personal identification and communication within the CRM. This field helps personalize user interactions and is often displayed in user interfaces and reports. It should be entered accurately to reflect the user's real name.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the person, which complements the first name to fully identify the user within the CRM. This field is important for formal identification and is used in conjunction with the first name in communications and documentation. Accurate entry is crucial for maintaining correct user records.
   */
  lastName?: string | null | undefined;
  /**
   * The job title of the person within the organization. This field helps in identifying the role and responsibilities of the user in the company hierarchy. It is crucial for understanding the user's position and can influence access permissions and workflow assignments in the CRM system. Although not mandatory, providing an accurate job title ensures better role-based management and reporting.
   */
  title?: string | null | undefined;
  /**
   * The division within the organization where the person is currently assigned. Divisions are typically larger organizational units that may encompass multiple departments, teams, or regions. This field is important for organizational reporting and analytics, helping to categorize users according to their broader functional areas. While not required, specifying the division can enhance data segmentation and targeted communication strategies.
   */
  division?: string | null | undefined;
  /**
   * The specific department within the organization where the person is currently working. Note that this field is deprecated in favor of using 'department_id' and 'department_name' for more precise identification. Departments are smaller units within divisions and are essential for detailed organizational structure mapping. Although deprecated, it may still be used for backward compatibility in some systems.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  department?: string | null | undefined;
  /**
   * The official name of the company where the user is employed. This field is used to associate the user with their employer and is vital for maintaining accurate employment records within the CRM. It supports the integration of user data with company-wide analytics and reporting tools. While not required, providing the company name can facilitate better data organization and retrieval.
   */
  companyName?: string | null | undefined;
  /**
   * A unique identifier assigned to each employee within the company, such as an Employee Number, ID, or Code. This field is crucial for distinguishing between users, especially in large organizations, and is often used in payroll, attendance, and internal tracking systems. While not mandatory, having a unique employee number helps in maintaining precise employee records and streamlining HR processes.
   */
  employeeNumber?: string | null | undefined;
  /**
   * A brief overview or summary of the user profile or role within the organization. This field is optional but can provide valuable context about the user's responsibilities or position, aiding in better understanding and management of user roles within the CRM system. It can be updated to reflect changes in the user's role or responsibilities.
   */
  description?: string | null | undefined;
  /**
   * The URL link to the user's avatar or profile picture. This optional field enhances user profiles by providing a visual identifier, which can be particularly useful in systems with many users, facilitating easier recognition and personalization of user interactions. Ensure the URL is accessible and points to a valid image file.
   */
  image?: string | null | undefined;
  /**
   * The language preference of the user, specified using the ISO 639-1 standard language codes (e.g., 'EN' for English). This optional field helps tailor the user experience by displaying content in the user's preferred language, enhancing usability and accessibility. It should be updated if the user's language preference changes.
   */
  language?: string | null | undefined;
  /**
   * The current operational status of the user within the CRM system, such as 'active', 'inactive', or 'suspended'. This optional field is crucial for managing user access and permissions, ensuring that only authorized users can perform certain actions. Regular updates to this field help maintain security and operational efficiency.
   */
  status?: string | null | undefined;
  /**
   * An array of address objects associated with the user. Each object within this array represents a distinct address record, allowing for the storage of multiple addresses per user. This is particularly useful for users who may have different billing and shipping addresses, or for businesses with multiple locations. The array can be updated partially, meaning you can add, remove, or modify individual address entries without affecting others.
   */
  addresses?: Array<UsersListResponseAddresses> | undefined;
  /**
   * An array of phone number objects associated with the user. Each object within this array represents a distinct phone number entry, allowing for multiple contact numbers to be stored and managed for a single user. This is particularly useful for users who have different numbers for personal, work, or other purposes. The array structure supports flexibility in updating or adding new numbers without affecting existing entries.
   */
  phoneNumbers?: Array<UsersListResponsePhoneNumbers> | undefined;
  /**
   * A collection of email objects associated with the user, each containing detailed information about individual email addresses. This array is required to ensure that there is at least one method of electronic communication available for the user, facilitating essential CRM functions such as notifications and updates.
   */
  emails: Array<UsersListResponseEmails>;
  /**
   * Contains any custom field mappings that have been configured for the user resource. This is particularly useful when integrating with external systems that require specific data formats or field names. It allows for flexible data handling and ensures that user data can be accurately synchronized across different platforms. This field is optional and should be used when custom integration requirements exist.
   */
  customMappings?: UsersListResponseCustomMappings | null | undefined;
  /**
   * Records the exact date and time when the user record was last modified. This timestamp is crucial for tracking changes and maintaining an audit trail of updates made to user information. It helps in ensuring data accuracy and consistency over time, and is automatically updated by the system whenever a change is made to the user record.
   */
  updatedAt?: string | null | undefined;
  /**
   * Indicates the date and time when the user record was initially created in the CRM system. This information is vital for historical data analysis and understanding the lifecycle of user records. It provides context for the age of the data and can be used to assess data retention policies. This field is automatically populated by the system at the time of record creation.
   */
  createdAt?: string | null | undefined;
  /**
   * Allows the inclusion of service-specific custom data or structured modifications directly in the request body when updating user resources. This feature is designed to support advanced customization needs, enabling the transmission of additional parameters that may be required by specific services or integrations. It is optional and should be used when there is a need to pass extra data that is not covered by standard fields.
   */
  passThrough?: Array<UsersListResponsePassThrough> | undefined;
};

/**
 * This property provides cursors that are used to navigate through paginated API responses, allowing clients to move to previous or next pages of data. It is included in the response when pagination is enabled, facilitating seamless data retrieval across multiple API calls. This ensures that applications can efficiently access large datasets without overwhelming the client or server.
 */
export type UsersListResponseCursors = {
  /**
   * The 'previous' cursor is a string token used to retrieve the preceding set of results in a paginated API response. It is included in the response when there are more results available before the current set, allowing clients to navigate backward through the data. This cursor is particularly useful in scenarios where users need to review or analyze data from earlier pages.
   */
  previous?: string | null | undefined;
  /**
   * The 'current' cursor is a string token representing the current position in the paginated list of results. It is included in the response to indicate the current page's starting point, helping clients maintain their place in the data sequence during navigation. This is essential for tracking the current dataset being viewed or processed.
   */
  current?: string | null | undefined;
  /**
   * The 'next' cursor is a string token that facilitates navigation to the subsequent set of results in a paginated API response. It is included when additional data is available beyond the current page, enabling clients to continue retrieving more results seamlessly. This is crucial for applications that need to process large datasets incrementally.
   */
  next?: string | null | undefined;
};

/**
 * This property contains metadata about the response, providing additional context and information about the data returned by the API. It is not always required but is included when there is a need to convey supplementary details such as pagination information or request processing time. This helps in understanding the response structure and any additional operations that might be needed.
 */
export type UsersListResponseMeta = {
  /**
   * This property indicates the number of items that are included in the 'data' section of the response. It is particularly useful for understanding the volume of data returned in a single API call, especially when pagination is in use. This property is included in the response to help clients manage data processing and display, ensuring that applications can handle the data efficiently.
   */
  itemsOnPage?: number | undefined;
  /**
   * This property provides cursors that are used to navigate through paginated API responses, allowing clients to move to previous or next pages of data. It is included in the response when pagination is enabled, facilitating seamless data retrieval across multiple API calls. This ensures that applications can efficiently access large datasets without overwhelming the client or server.
   */
  cursors?: UsersListResponseCursors | undefined;
};

/**
 * The 'links' object contains hypermedia links that provide URLs for navigating between pages of results in the API. It is included in the response to offer direct access to previous or next pages, enhancing the ease of data traversal in client applications. This object is particularly beneficial for implementing intuitive user interfaces that require seamless pagination controls.
 */
export type UsersListResponseLinks = {
  /**
   * The 'previous' link is a URL string that directs clients to the previous page of results in the API. It is included when there are earlier pages available, allowing users to easily navigate back to review or access prior data. This link is essential for applications that support backward navigation through paginated datasets.
   */
  previous?: string | null | undefined;
  /**
   * This property provides a URL link that directs to the current page of the user list in the API response. It is particularly useful for applications implementing pagination, allowing them to easily reload or refresh the current set of user data. This link is included in the response when pagination is in use, ensuring that users can maintain their current position within the dataset when navigating through multiple pages of results.
   */
  current?: string | undefined;
  /**
   * This property contains a URL link that directs to the next page of the user list in the API response. It is essential for applications that need to handle large datasets by breaking them into manageable pages. This link is included when there are additional pages of user data available beyond the current page, facilitating seamless navigation through the complete list of users without manually constructing URLs.
   */
  next?: string | null | undefined;
};

/**
 * Users
 */
export type UsersListResponse = {
  /**
   * The HTTP response status code returned by the server. This integer value indicates the result of the HTTP request, such as 200 for success or 404 for not found. It is always included in the response to inform the client of the outcome of their request, allowing for appropriate handling of the response based on the code received.
   */
  statusCode: number;
  /**
   * A textual representation of the HTTP response status. This string provides a human-readable explanation of the status code, such as 'OK' for a 200 status code or 'Not Found' for a 404 status code. It is included to give a clear, concise description of the response outcome, aiding in debugging and logging processes.
   */
  status: string;
  /**
   * The Apideck ID of the service provider that processed the request. This string uniquely identifies the service within the Apideck ecosystem, ensuring that the response can be traced back to the correct service provider. It is crucial when multiple services are integrated, as it helps in identifying which service handled the request.
   */
  service: string;
  /**
   * The name of the Unified API resource that was accessed. This string indicates which specific resource within the API was targeted by the request, such as 'users' for the '/crm/users' endpoint. It helps in understanding the context of the response, especially when dealing with multiple API resources.
   */
  resource: string;
  /**
   * The specific operation that was performed as part of the API request. This string describes the action taken, such as 'retrieve' for fetching data or 'update' for modifying data. It provides clarity on what the API call was intended to achieve, which is essential for tracking and auditing purposes.
   */
  operation: string;
  /**
   * An array containing user objects, each representing a unique user retrieved from the CRM system. This array is the main body of the response and includes detailed user information based on the specified query parameters. It is always included in the response to provide a structured list of users.
   */
  data: Array<UsersListResponseData>;
  /**
   * This property contains metadata about the response, providing additional context and information about the data returned by the API. It is not always required but is included when there is a need to convey supplementary details such as pagination information or request processing time. This helps in understanding the response structure and any additional operations that might be needed.
   */
  meta?: UsersListResponseMeta | undefined;
  /**
   * The 'links' object contains hypermedia links that provide URLs for navigating between pages of results in the API. It is included in the response to offer direct access to previous or next pages, enhancing the ease of data traversal in client applications. This object is particularly beneficial for implementing intuitive user interfaces that require seamless pagination controls.
   */
  links?: UsersListResponseLinks | undefined;
};

/** @internal */
export const UsersListResponseType$inboundSchema: z.ZodNativeEnum<
  typeof UsersListResponseType
> = z.nativeEnum(UsersListResponseType);

/** @internal */
export const UsersListResponseType$outboundSchema: z.ZodNativeEnum<
  typeof UsersListResponseType
> = UsersListResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseType$ {
  /** @deprecated use `UsersListResponseType$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseType$inboundSchema;
  /** @deprecated use `UsersListResponseType$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseType$outboundSchema;
}

/** @internal */
export const UsersListResponseAddresses$inboundSchema: z.ZodType<
  UsersListResponseAddresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(UsersListResponseType$inboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  street_number: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postal_code: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contact_name: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phone_number: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  row_version: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "street_number": "streetNumber",
    "postal_code": "postalCode",
    "contact_name": "contactName",
    "phone_number": "phoneNumber",
    "row_version": "rowVersion",
  });
});

/** @internal */
export type UsersListResponseAddresses$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
  string?: string | null | undefined;
  name?: string | null | undefined;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  line3?: string | null | undefined;
  line4?: string | null | undefined;
  street_number?: string | null | undefined;
  city?: string | null | undefined;
  state?: string | null | undefined;
  postal_code?: string | null | undefined;
  country?: string | null | undefined;
  latitude?: string | null | undefined;
  longitude?: string | null | undefined;
  county?: string | null | undefined;
  contact_name?: string | null | undefined;
  salutation?: string | null | undefined;
  phone_number?: string | null | undefined;
  fax?: string | null | undefined;
  email?: string | null | undefined;
  website?: string | null | undefined;
  notes?: string | null | undefined;
  row_version?: string | null | undefined;
};

/** @internal */
export const UsersListResponseAddresses$outboundSchema: z.ZodType<
  UsersListResponseAddresses$Outbound,
  z.ZodTypeDef,
  UsersListResponseAddresses
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(UsersListResponseType$outboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  streetNumber: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contactName: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phoneNumber: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  rowVersion: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    streetNumber: "street_number",
    postalCode: "postal_code",
    contactName: "contact_name",
    phoneNumber: "phone_number",
    rowVersion: "row_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseAddresses$ {
  /** @deprecated use `UsersListResponseAddresses$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseAddresses$inboundSchema;
  /** @deprecated use `UsersListResponseAddresses$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseAddresses$outboundSchema;
  /** @deprecated use `UsersListResponseAddresses$Outbound` instead. */
  export type Outbound = UsersListResponseAddresses$Outbound;
}

export function usersListResponseAddressesToJSON(
  usersListResponseAddresses: UsersListResponseAddresses,
): string {
  return JSON.stringify(
    UsersListResponseAddresses$outboundSchema.parse(usersListResponseAddresses),
  );
}

export function usersListResponseAddressesFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponseAddresses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponseAddresses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponseAddresses' from JSON`,
  );
}

/** @internal */
export const UsersListResponseDataType$inboundSchema: z.ZodNativeEnum<
  typeof UsersListResponseDataType
> = z.nativeEnum(UsersListResponseDataType);

/** @internal */
export const UsersListResponseDataType$outboundSchema: z.ZodNativeEnum<
  typeof UsersListResponseDataType
> = UsersListResponseDataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseDataType$ {
  /** @deprecated use `UsersListResponseDataType$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseDataType$inboundSchema;
  /** @deprecated use `UsersListResponseDataType$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseDataType$outboundSchema;
}

/** @internal */
export const UsersListResponsePhoneNumbers$inboundSchema: z.ZodType<
  UsersListResponsePhoneNumbers,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  country_code: z.nullable(z.string()).optional(),
  area_code: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(UsersListResponseDataType$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "country_code": "countryCode",
    "area_code": "areaCode",
  });
});

/** @internal */
export type UsersListResponsePhoneNumbers$Outbound = {
  id?: string | null | undefined;
  country_code?: string | null | undefined;
  area_code?: string | null | undefined;
  number: string;
  extension?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const UsersListResponsePhoneNumbers$outboundSchema: z.ZodType<
  UsersListResponsePhoneNumbers$Outbound,
  z.ZodTypeDef,
  UsersListResponsePhoneNumbers
> = z.object({
  id: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  areaCode: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(UsersListResponseDataType$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    countryCode: "country_code",
    areaCode: "area_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponsePhoneNumbers$ {
  /** @deprecated use `UsersListResponsePhoneNumbers$inboundSchema` instead. */
  export const inboundSchema = UsersListResponsePhoneNumbers$inboundSchema;
  /** @deprecated use `UsersListResponsePhoneNumbers$outboundSchema` instead. */
  export const outboundSchema = UsersListResponsePhoneNumbers$outboundSchema;
  /** @deprecated use `UsersListResponsePhoneNumbers$Outbound` instead. */
  export type Outbound = UsersListResponsePhoneNumbers$Outbound;
}

export function usersListResponsePhoneNumbersToJSON(
  usersListResponsePhoneNumbers: UsersListResponsePhoneNumbers,
): string {
  return JSON.stringify(
    UsersListResponsePhoneNumbers$outboundSchema.parse(
      usersListResponsePhoneNumbers,
    ),
  );
}

export function usersListResponsePhoneNumbersFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponsePhoneNumbers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponsePhoneNumbers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponsePhoneNumbers' from JSON`,
  );
}

/** @internal */
export const UsersListResponseDataEmailsType$inboundSchema: z.ZodNativeEnum<
  typeof UsersListResponseDataEmailsType
> = z.nativeEnum(UsersListResponseDataEmailsType);

/** @internal */
export const UsersListResponseDataEmailsType$outboundSchema: z.ZodNativeEnum<
  typeof UsersListResponseDataEmailsType
> = UsersListResponseDataEmailsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseDataEmailsType$ {
  /** @deprecated use `UsersListResponseDataEmailsType$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseDataEmailsType$inboundSchema;
  /** @deprecated use `UsersListResponseDataEmailsType$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseDataEmailsType$outboundSchema;
}

/** @internal */
export const UsersListResponseEmails$inboundSchema: z.ZodType<
  UsersListResponseEmails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(UsersListResponseDataEmailsType$inboundSchema).optional(),
});

/** @internal */
export type UsersListResponseEmails$Outbound = {
  id?: string | null | undefined;
  email: string | null;
  type?: string | null | undefined;
};

/** @internal */
export const UsersListResponseEmails$outboundSchema: z.ZodType<
  UsersListResponseEmails$Outbound,
  z.ZodTypeDef,
  UsersListResponseEmails
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(UsersListResponseDataEmailsType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseEmails$ {
  /** @deprecated use `UsersListResponseEmails$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseEmails$inboundSchema;
  /** @deprecated use `UsersListResponseEmails$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseEmails$outboundSchema;
  /** @deprecated use `UsersListResponseEmails$Outbound` instead. */
  export type Outbound = UsersListResponseEmails$Outbound;
}

export function usersListResponseEmailsToJSON(
  usersListResponseEmails: UsersListResponseEmails,
): string {
  return JSON.stringify(
    UsersListResponseEmails$outboundSchema.parse(usersListResponseEmails),
  );
}

export function usersListResponseEmailsFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponseEmails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponseEmails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponseEmails' from JSON`,
  );
}

/** @internal */
export const UsersListResponseCustomMappings$inboundSchema: z.ZodType<
  UsersListResponseCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type UsersListResponseCustomMappings$Outbound = {};

/** @internal */
export const UsersListResponseCustomMappings$outboundSchema: z.ZodType<
  UsersListResponseCustomMappings$Outbound,
  z.ZodTypeDef,
  UsersListResponseCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseCustomMappings$ {
  /** @deprecated use `UsersListResponseCustomMappings$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseCustomMappings$inboundSchema;
  /** @deprecated use `UsersListResponseCustomMappings$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseCustomMappings$outboundSchema;
  /** @deprecated use `UsersListResponseCustomMappings$Outbound` instead. */
  export type Outbound = UsersListResponseCustomMappings$Outbound;
}

export function usersListResponseCustomMappingsToJSON(
  usersListResponseCustomMappings: UsersListResponseCustomMappings,
): string {
  return JSON.stringify(
    UsersListResponseCustomMappings$outboundSchema.parse(
      usersListResponseCustomMappings,
    ),
  );
}

export function usersListResponseCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponseCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponseCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponseCustomMappings' from JSON`,
  );
}

/** @internal */
export const UsersListResponseExtendPaths$inboundSchema: z.ZodType<
  UsersListResponseExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type UsersListResponseExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const UsersListResponseExtendPaths$outboundSchema: z.ZodType<
  UsersListResponseExtendPaths$Outbound,
  z.ZodTypeDef,
  UsersListResponseExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseExtendPaths$ {
  /** @deprecated use `UsersListResponseExtendPaths$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseExtendPaths$inboundSchema;
  /** @deprecated use `UsersListResponseExtendPaths$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseExtendPaths$outboundSchema;
  /** @deprecated use `UsersListResponseExtendPaths$Outbound` instead. */
  export type Outbound = UsersListResponseExtendPaths$Outbound;
}

export function usersListResponseExtendPathsToJSON(
  usersListResponseExtendPaths: UsersListResponseExtendPaths,
): string {
  return JSON.stringify(
    UsersListResponseExtendPaths$outboundSchema.parse(
      usersListResponseExtendPaths,
    ),
  );
}

export function usersListResponseExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponseExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponseExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponseExtendPaths' from JSON`,
  );
}

/** @internal */
export const UsersListResponsePassThrough$inboundSchema: z.ZodType<
  UsersListResponsePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => UsersListResponseExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type UsersListResponsePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<UsersListResponseExtendPaths$Outbound> | undefined;
};

/** @internal */
export const UsersListResponsePassThrough$outboundSchema: z.ZodType<
  UsersListResponsePassThrough$Outbound,
  z.ZodTypeDef,
  UsersListResponsePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => UsersListResponseExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponsePassThrough$ {
  /** @deprecated use `UsersListResponsePassThrough$inboundSchema` instead. */
  export const inboundSchema = UsersListResponsePassThrough$inboundSchema;
  /** @deprecated use `UsersListResponsePassThrough$outboundSchema` instead. */
  export const outboundSchema = UsersListResponsePassThrough$outboundSchema;
  /** @deprecated use `UsersListResponsePassThrough$Outbound` instead. */
  export type Outbound = UsersListResponsePassThrough$Outbound;
}

export function usersListResponsePassThroughToJSON(
  usersListResponsePassThrough: UsersListResponsePassThrough,
): string {
  return JSON.stringify(
    UsersListResponsePassThrough$outboundSchema.parse(
      usersListResponsePassThrough,
    ),
  );
}

export function usersListResponsePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponsePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponsePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponsePassThrough' from JSON`,
  );
}

/** @internal */
export const UsersListResponseData$inboundSchema: z.ZodType<
  UsersListResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  parent_id: z.nullable(z.string()).optional(),
  username: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  division: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  company_name: z.nullable(z.string()).optional(),
  employee_number: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  addresses: z.array(z.lazy(() => UsersListResponseAddresses$inboundSchema))
    .optional(),
  phone_numbers: z.array(
    z.lazy(() => UsersListResponsePhoneNumbers$inboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => UsersListResponseEmails$inboundSchema)),
  custom_mappings: z.nullable(
    z.lazy(() => UsersListResponseCustomMappings$inboundSchema),
  ).optional(),
  updated_at: z.nullable(z.string()).optional(),
  created_at: z.nullable(z.string()).optional(),
  pass_through: z.array(
    z.lazy(() => UsersListResponsePassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "parent_id": "parentId",
    "first_name": "firstName",
    "last_name": "lastName",
    "company_name": "companyName",
    "employee_number": "employeeNumber",
    "phone_numbers": "phoneNumbers",
    "custom_mappings": "customMappings",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type UsersListResponseData$Outbound = {
  id?: string | undefined;
  parent_id?: string | null | undefined;
  username?: string | null | undefined;
  first_name?: string | null | undefined;
  last_name?: string | null | undefined;
  title?: string | null | undefined;
  division?: string | null | undefined;
  department?: string | null | undefined;
  company_name?: string | null | undefined;
  employee_number?: string | null | undefined;
  description?: string | null | undefined;
  image?: string | null | undefined;
  language?: string | null | undefined;
  status?: string | null | undefined;
  addresses?: Array<UsersListResponseAddresses$Outbound> | undefined;
  phone_numbers?: Array<UsersListResponsePhoneNumbers$Outbound> | undefined;
  emails: Array<UsersListResponseEmails$Outbound>;
  custom_mappings?: UsersListResponseCustomMappings$Outbound | null | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  pass_through?: Array<UsersListResponsePassThrough$Outbound> | undefined;
};

/** @internal */
export const UsersListResponseData$outboundSchema: z.ZodType<
  UsersListResponseData$Outbound,
  z.ZodTypeDef,
  UsersListResponseData
> = z.object({
  id: z.string().optional(),
  parentId: z.nullable(z.string()).optional(),
  username: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  division: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  companyName: z.nullable(z.string()).optional(),
  employeeNumber: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  addresses: z.array(z.lazy(() => UsersListResponseAddresses$outboundSchema))
    .optional(),
  phoneNumbers: z.array(
    z.lazy(() => UsersListResponsePhoneNumbers$outboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => UsersListResponseEmails$outboundSchema)),
  customMappings: z.nullable(
    z.lazy(() => UsersListResponseCustomMappings$outboundSchema),
  ).optional(),
  updatedAt: z.nullable(z.string()).optional(),
  createdAt: z.nullable(z.string()).optional(),
  passThrough: z.array(
    z.lazy(() => UsersListResponsePassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    parentId: "parent_id",
    firstName: "first_name",
    lastName: "last_name",
    companyName: "company_name",
    employeeNumber: "employee_number",
    phoneNumbers: "phone_numbers",
    customMappings: "custom_mappings",
    updatedAt: "updated_at",
    createdAt: "created_at",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseData$ {
  /** @deprecated use `UsersListResponseData$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseData$inboundSchema;
  /** @deprecated use `UsersListResponseData$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseData$outboundSchema;
  /** @deprecated use `UsersListResponseData$Outbound` instead. */
  export type Outbound = UsersListResponseData$Outbound;
}

export function usersListResponseDataToJSON(
  usersListResponseData: UsersListResponseData,
): string {
  return JSON.stringify(
    UsersListResponseData$outboundSchema.parse(usersListResponseData),
  );
}

export function usersListResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponseData' from JSON`,
  );
}

/** @internal */
export const UsersListResponseCursors$inboundSchema: z.ZodType<
  UsersListResponseCursors,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type UsersListResponseCursors$Outbound = {
  previous?: string | null | undefined;
  current?: string | null | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const UsersListResponseCursors$outboundSchema: z.ZodType<
  UsersListResponseCursors$Outbound,
  z.ZodTypeDef,
  UsersListResponseCursors
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseCursors$ {
  /** @deprecated use `UsersListResponseCursors$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseCursors$inboundSchema;
  /** @deprecated use `UsersListResponseCursors$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseCursors$outboundSchema;
  /** @deprecated use `UsersListResponseCursors$Outbound` instead. */
  export type Outbound = UsersListResponseCursors$Outbound;
}

export function usersListResponseCursorsToJSON(
  usersListResponseCursors: UsersListResponseCursors,
): string {
  return JSON.stringify(
    UsersListResponseCursors$outboundSchema.parse(usersListResponseCursors),
  );
}

export function usersListResponseCursorsFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponseCursors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponseCursors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponseCursors' from JSON`,
  );
}

/** @internal */
export const UsersListResponseMeta$inboundSchema: z.ZodType<
  UsersListResponseMeta,
  z.ZodTypeDef,
  unknown
> = z.object({
  items_on_page: z.number().int().optional(),
  cursors: z.lazy(() => UsersListResponseCursors$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "items_on_page": "itemsOnPage",
  });
});

/** @internal */
export type UsersListResponseMeta$Outbound = {
  items_on_page?: number | undefined;
  cursors?: UsersListResponseCursors$Outbound | undefined;
};

/** @internal */
export const UsersListResponseMeta$outboundSchema: z.ZodType<
  UsersListResponseMeta$Outbound,
  z.ZodTypeDef,
  UsersListResponseMeta
> = z.object({
  itemsOnPage: z.number().int().optional(),
  cursors: z.lazy(() => UsersListResponseCursors$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    itemsOnPage: "items_on_page",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseMeta$ {
  /** @deprecated use `UsersListResponseMeta$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseMeta$inboundSchema;
  /** @deprecated use `UsersListResponseMeta$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseMeta$outboundSchema;
  /** @deprecated use `UsersListResponseMeta$Outbound` instead. */
  export type Outbound = UsersListResponseMeta$Outbound;
}

export function usersListResponseMetaToJSON(
  usersListResponseMeta: UsersListResponseMeta,
): string {
  return JSON.stringify(
    UsersListResponseMeta$outboundSchema.parse(usersListResponseMeta),
  );
}

export function usersListResponseMetaFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponseMeta, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponseMeta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponseMeta' from JSON`,
  );
}

/** @internal */
export const UsersListResponseLinks$inboundSchema: z.ZodType<
  UsersListResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type UsersListResponseLinks$Outbound = {
  previous?: string | null | undefined;
  current?: string | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const UsersListResponseLinks$outboundSchema: z.ZodType<
  UsersListResponseLinks$Outbound,
  z.ZodTypeDef,
  UsersListResponseLinks
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponseLinks$ {
  /** @deprecated use `UsersListResponseLinks$inboundSchema` instead. */
  export const inboundSchema = UsersListResponseLinks$inboundSchema;
  /** @deprecated use `UsersListResponseLinks$outboundSchema` instead. */
  export const outboundSchema = UsersListResponseLinks$outboundSchema;
  /** @deprecated use `UsersListResponseLinks$Outbound` instead. */
  export type Outbound = UsersListResponseLinks$Outbound;
}

export function usersListResponseLinksToJSON(
  usersListResponseLinks: UsersListResponseLinks,
): string {
  return JSON.stringify(
    UsersListResponseLinks$outboundSchema.parse(usersListResponseLinks),
  );
}

export function usersListResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponseLinks' from JSON`,
  );
}

/** @internal */
export const UsersListResponse$inboundSchema: z.ZodType<
  UsersListResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => UsersListResponseData$inboundSchema)),
  meta: z.lazy(() => UsersListResponseMeta$inboundSchema).optional(),
  links: z.lazy(() => UsersListResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type UsersListResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: Array<UsersListResponseData$Outbound>;
  meta?: UsersListResponseMeta$Outbound | undefined;
  links?: UsersListResponseLinks$Outbound | undefined;
};

/** @internal */
export const UsersListResponse$outboundSchema: z.ZodType<
  UsersListResponse$Outbound,
  z.ZodTypeDef,
  UsersListResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => UsersListResponseData$outboundSchema)),
  meta: z.lazy(() => UsersListResponseMeta$outboundSchema).optional(),
  links: z.lazy(() => UsersListResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UsersListResponse$ {
  /** @deprecated use `UsersListResponse$inboundSchema` instead. */
  export const inboundSchema = UsersListResponse$inboundSchema;
  /** @deprecated use `UsersListResponse$outboundSchema` instead. */
  export const outboundSchema = UsersListResponse$outboundSchema;
  /** @deprecated use `UsersListResponse$Outbound` instead. */
  export type Outbound = UsersListResponse$Outbound;
}

export function usersListResponseToJSON(
  usersListResponse: UsersListResponse,
): string {
  return JSON.stringify(
    UsersListResponse$outboundSchema.parse(usersListResponse),
  );
}

export function usersListResponseFromJSON(
  jsonString: string,
): SafeParseResult<UsersListResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersListResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersListResponse' from JSON`,
  );
}

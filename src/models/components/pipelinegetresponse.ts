/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Indicates the associated currency for an amount of money within the pipeline. This field uses ISO 4217 currency codes (e.g., USD, EUR) to standardize financial data across different regions and systems. While not mandatory, specifying a currency is essential for pipelines that involve financial transactions, ensuring that all monetary values are correctly interpreted and reported. This is particularly useful in multi-national operations where currency consistency is critical.
 */
export const PipelineGetResponseCurrency = {
  UnknownCurrency: "UNKNOWN_CURRENCY",
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Bov: "BOV",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Che: "CHE",
  Chf: "CHF",
  Chw: "CHW",
  Clf: "CLF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Cou: "COU",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Ltl: "LTL",
  Lvl: "LVL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Mxv: "MXV",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Srd: "SRD",
  Ssp: "SSP",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Trc: "TRC",
  Try: "TRY",
  Ttd: "TTD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Usn: "USN",
  Uss: "USS",
  Uyi: "UYI",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xag: "XAG",
  Xau: "XAU",
  Xba: "XBA",
  Xbb: "XBB",
  Xbc: "XBC",
  Xbd: "XBD",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpd: "XPD",
  Xpf: "XPF",
  Xpt: "XPT",
  Xts: "XTS",
  Xxx: "XXX",
  Yer: "YER",
  Zar: "ZAR",
  Zmk: "ZMK",
  Zmw: "ZMW",
  Btc: "BTC",
  Eth: "ETH",
} as const;
/**
 * Indicates the associated currency for an amount of money within the pipeline. This field uses ISO 4217 currency codes (e.g., USD, EUR) to standardize financial data across different regions and systems. While not mandatory, specifying a currency is essential for pipelines that involve financial transactions, ensuring that all monetary values are correctly interpreted and reported. This is particularly useful in multi-national operations where currency consistency is critical.
 */
export type PipelineGetResponseCurrency = ClosedEnum<
  typeof PipelineGetResponseCurrency
>;

export type PipelineGetResponseStages = {
  /**
   * A unique identifier for each stage within the pipeline. This ID is essential for distinguishing between different stages, especially when updating or retrieving specific stage information. It ensures that each stage can be individually managed and referenced, facilitating precise updates and data integrity within the pipeline.
   */
  id?: string | null | undefined;
  /**
   * The descriptive name assigned to each stage within the pipeline. This name should clearly convey the purpose or focus of the stage, aiding users in quickly understanding the stage's role within the pipeline. Naming conventions should be consistent and meaningful to ensure clarity and ease of use across the CRM system.
   */
  name?: string | null | undefined;
  /**
   * The name or label assigned to a specific stage within the pipeline. This value is used to identify and differentiate stages in the pipeline, allowing users to track the progress of opportunities as they move through various phases. It is crucial for organizing and managing the sales process effectively, ensuring that each stage is clearly defined and understood by all team members.
   */
  value?: string | null | undefined;
  /**
   * An integer representing the likelihood, expressed as a percentage, that an opportunity will be successfully closed at this stage of the pipeline. Valid values range from 0 to 100, where 0 indicates no chance of winning and 100 indicates certainty. This metric helps sales teams prioritize efforts and forecast potential revenue by assessing the probability of success at different stages.
   */
  winProbability?: number | null | undefined;
  /**
   * A numerical value that determines the sequence in which this pipeline stage appears in the user interface. Lower numbers typically indicate earlier stages in the pipeline, while higher numbers represent later stages. This ordering is essential for visualizing the sales process flow and ensuring that stages are presented in a logical and intuitive manner for users.
   */
  displayOrder?: number | null | undefined;
};

export type PipelineGetResponseExtendPaths = {
  /**
   * A JSONPath string that specifies the exact location within the user record where the value should be applied. This is essential for making precise updates to nested fields, ensuring that changes are made only to the intended parts of the data structure. The path must be valid and correspond to an existing field within the user record.
   */
  path: string;
  /**
   * This property represents the specific value that you wish to assign to a designated path within the user record. It can be of any data type, such as a string, number, boolean, or object, depending on the field being updated. The flexibility of this property allows for a wide range of updates, from simple text changes to complex data structures. In the context of the `usersUpdate` operation, this property is crucial for specifying the exact data modification you intend to make, ensuring that only the targeted fields are altered without affecting other data. Proper validation should be applied to ensure the value is compatible with the field's expected data type and business rules. Common use cases include updating user contact information, preferences, or custom attributes specific to your CRM's schema.
   */
  value?: any | undefined;
};

export type PipelineGetResponsePassThrough = {
  /**
   * The unique identifier for the specific service to which this pass_through should be applied. This is crucial for directing the update operation to the correct service within the CRM system, ensuring that the modifications are executed in the appropriate context. It must be a valid service ID that corresponds to an active service integration, and it is required for the operation to proceed.
   */
  serviceId: string;
  /**
   * An optional identifier for a specific workflow operation within the CRM system to which this pass_through should be applied. This is particularly useful for Unify calls that involve multiple downstream requests, allowing for precise targeting and execution of specific operations. If provided, it should match an existing operation ID to ensure correct processing.
   */
  operationId?: string | undefined;
  /**
   * A flexible object that allows for the inclusion of any additional properties needed for direct extension of the user record. This can be used to add custom fields or metadata that are not part of the standard user schema, providing a way to tailor the user data to specific business needs. The structure of this object should align with the CRM's data model to ensure compatibility.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects designed for structured data modifications via specified paths. This allows for precise updates to nested data structures within the user record, enabling complex modifications without altering unrelated data. Each object in the array should define a clear path and value to be applied, ensuring targeted updates.
   */
  extendPaths?: Array<PipelineGetResponseExtendPaths> | undefined;
};

/**
 * The main container object that holds all the detailed information about the specific CRM pipeline being retrieved. This object includes various attributes that describe the pipeline's characteristics and status. It is always included in the response to ensure that the consumer receives a comprehensive set of data about the requested pipeline.
 */
export type PipelineGetResponseData = {
  /**
   * The unique identifier of the Pipeline. This ID is crucial for identifying which specific pipeline you wish to update within the CRM system. It must match an existing pipeline's ID to ensure the correct data is modified. Typically, this ID is generated by the system when the pipeline is created and is immutable. It is not required in the request body for this operation, as it is specified in the path parameter.
   */
  id?: string | undefined;
  /**
   * The name of the Pipeline. This is a mandatory field that serves as the primary label for the pipeline within the CRM. It should be descriptive enough to convey the purpose or stage of the pipeline, aiding users in quickly identifying and managing different sales or project processes. The name must be unique within the context of the CRM to avoid confusion and ensure accurate reporting and tracking.
   */
  name: string;
  /**
   * Indicates the associated currency for an amount of money within the pipeline. This field uses ISO 4217 currency codes (e.g., USD, EUR) to standardize financial data across different regions and systems. While not mandatory, specifying a currency is essential for pipelines that involve financial transactions, ensuring that all monetary values are correctly interpreted and reported. This is particularly useful in multi-national operations where currency consistency is critical.
   */
  currency?: PipelineGetResponseCurrency | null | undefined;
  /**
   * Whether the Pipeline is archived or not. This boolean flag indicates the current status of the pipeline, where 'true' means the pipeline is archived and no longer active in day-to-day operations. Archiving a pipeline can help declutter the CRM interface by hiding pipelines that are no longer in use, while still retaining their data for historical analysis or compliance purposes. This field is optional but useful for lifecycle management of pipelines.
   */
  archived?: boolean | undefined;
  /**
   * Whether the Pipeline is active or not. This boolean field determines if the pipeline is currently in use and visible to users within the CRM. An active pipeline is one that is part of ongoing operations, such as sales processes or project management workflows. Setting this field to 'false' can help manage resources by deactivating pipelines that are temporarily not needed, without archiving them completely. This field is optional and can be used to toggle the operational status of a pipeline.
   */
  active?: boolean | undefined;
  /**
   * Defines the sequence in which the pipeline appears within the user interface. This property is crucial for organizing multiple pipelines in a logical order, enhancing user navigation and workflow efficiency. Typically, a lower number indicates a higher priority or earlier position in the list. Adjusting this value can help prioritize certain pipelines over others based on business needs or user preferences.
   */
  displayOrder?: number | null | undefined;
  /**
   * Indicates whether the pipeline has the win probability feature activated. This feature is used to estimate the likelihood of successfully closing deals within this pipeline, providing valuable insights for sales forecasting and strategy planning. Enabling this feature can help sales teams focus on high-probability deals, optimizing resource allocation and effort.
   */
  winProbabilityEnabled?: boolean | undefined;
  /**
   * An array representing the various stages within the pipeline. Each stage is a critical step in the sales or project process, and defining these stages helps in tracking progress and managing tasks effectively. This property allows for the customization of the pipeline to fit specific business processes or sales cycles.
   */
  stages?: Array<PipelineGetResponseStages> | undefined;
  /**
   * A timestamp indicating the most recent date and time when the pipeline or its stages were modified. This information is vital for tracking changes and maintaining an audit trail of updates, ensuring that users can identify the latest version of the pipeline configuration. The format typically follows ISO 8601 standards, such as 'YYYY-MM-DDTHH:MM:SSZ'.
   */
  updatedAt?: Date | null | undefined;
  /**
   * A timestamp marking the original creation date and time of the pipeline or its stages. This property is important for historical reference and auditing purposes, allowing users to understand the lifecycle of the pipeline from inception. Like 'updated_at', it usually adheres to ISO 8601 format, providing a standardized way to record and display date-time information.
   */
  createdAt?: Date | null | undefined;
  /**
   * The `pass_through` property is an array that allows you to include service-specific custom data or structured modifications directly within the request body. This is particularly useful when updating resources in a CRM system where additional, non-standard data needs to be sent to the service. By using this property, you can ensure that any unique requirements of the service are met without altering the core API structure. It supports flexibility in handling diverse data formats required by different services.
   */
  passThrough?: Array<PipelineGetResponsePassThrough> | undefined;
};

/**
 * Pipeline
 */
export type PipelineGetResponse = {
  /**
   * The HTTP response status code returned by the server. This integer value indicates the result of the HTTP request, with a 200 status code signifying a successful retrieval of the pipeline data. It is always included in the response to inform the client about the outcome of their request, helping in error handling and debugging processes.
   */
  statusCode: number;
  /**
   * The HTTP response status message accompanying the status code. This string provides a textual representation of the status code, such as 'OK' for a 200 status code. It is included in the response to give a human-readable explanation of the request's outcome, aiding in understanding the server's response.
   */
  status: string;
  /**
   * The Apideck ID of the service provider that processed the request. This string uniquely identifies the service within the Apideck ecosystem, ensuring that the response is correctly attributed to the intended service. It is crucial for consumers with multiple integrations to verify which service handled the request.
   */
  service: string;
  /**
   * The name of the unified API resource that was accessed. This string indicates the specific resource within the CRM system that the operation targeted, such as a pipeline. It helps in identifying the type of data returned and is essential for understanding the context of the response.
   */
  resource: string;
  /**
   * The specific operation that was performed on the resource. This string describes the action taken, such as 'retrieve' or 'update', and is included to provide clarity on what the API call accomplished. It is vital for tracking the sequence of operations in integration workflows.
   */
  operation: string;
  /**
   * The main container object that holds all the detailed information about the specific CRM pipeline being retrieved. This object includes various attributes that describe the pipeline's characteristics and status. It is always included in the response to ensure that the consumer receives a comprehensive set of data about the requested pipeline.
   */
  data: PipelineGetResponseData;
};

/** @internal */
export const PipelineGetResponseCurrency$inboundSchema: z.ZodNativeEnum<
  typeof PipelineGetResponseCurrency
> = z.nativeEnum(PipelineGetResponseCurrency);

/** @internal */
export const PipelineGetResponseCurrency$outboundSchema: z.ZodNativeEnum<
  typeof PipelineGetResponseCurrency
> = PipelineGetResponseCurrency$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PipelineGetResponseCurrency$ {
  /** @deprecated use `PipelineGetResponseCurrency$inboundSchema` instead. */
  export const inboundSchema = PipelineGetResponseCurrency$inboundSchema;
  /** @deprecated use `PipelineGetResponseCurrency$outboundSchema` instead. */
  export const outboundSchema = PipelineGetResponseCurrency$outboundSchema;
}

/** @internal */
export const PipelineGetResponseStages$inboundSchema: z.ZodType<
  PipelineGetResponseStages,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  value: z.nullable(z.string()).optional(),
  win_probability: z.nullable(z.number().int()).optional(),
  display_order: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "win_probability": "winProbability",
    "display_order": "displayOrder",
  });
});

/** @internal */
export type PipelineGetResponseStages$Outbound = {
  id?: string | null | undefined;
  name?: string | null | undefined;
  value?: string | null | undefined;
  win_probability?: number | null | undefined;
  display_order?: number | null | undefined;
};

/** @internal */
export const PipelineGetResponseStages$outboundSchema: z.ZodType<
  PipelineGetResponseStages$Outbound,
  z.ZodTypeDef,
  PipelineGetResponseStages
> = z.object({
  id: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  value: z.nullable(z.string()).optional(),
  winProbability: z.nullable(z.number().int()).optional(),
  displayOrder: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    winProbability: "win_probability",
    displayOrder: "display_order",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PipelineGetResponseStages$ {
  /** @deprecated use `PipelineGetResponseStages$inboundSchema` instead. */
  export const inboundSchema = PipelineGetResponseStages$inboundSchema;
  /** @deprecated use `PipelineGetResponseStages$outboundSchema` instead. */
  export const outboundSchema = PipelineGetResponseStages$outboundSchema;
  /** @deprecated use `PipelineGetResponseStages$Outbound` instead. */
  export type Outbound = PipelineGetResponseStages$Outbound;
}

export function pipelineGetResponseStagesToJSON(
  pipelineGetResponseStages: PipelineGetResponseStages,
): string {
  return JSON.stringify(
    PipelineGetResponseStages$outboundSchema.parse(pipelineGetResponseStages),
  );
}

export function pipelineGetResponseStagesFromJSON(
  jsonString: string,
): SafeParseResult<PipelineGetResponseStages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PipelineGetResponseStages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineGetResponseStages' from JSON`,
  );
}

/** @internal */
export const PipelineGetResponseExtendPaths$inboundSchema: z.ZodType<
  PipelineGetResponseExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type PipelineGetResponseExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const PipelineGetResponseExtendPaths$outboundSchema: z.ZodType<
  PipelineGetResponseExtendPaths$Outbound,
  z.ZodTypeDef,
  PipelineGetResponseExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PipelineGetResponseExtendPaths$ {
  /** @deprecated use `PipelineGetResponseExtendPaths$inboundSchema` instead. */
  export const inboundSchema = PipelineGetResponseExtendPaths$inboundSchema;
  /** @deprecated use `PipelineGetResponseExtendPaths$outboundSchema` instead. */
  export const outboundSchema = PipelineGetResponseExtendPaths$outboundSchema;
  /** @deprecated use `PipelineGetResponseExtendPaths$Outbound` instead. */
  export type Outbound = PipelineGetResponseExtendPaths$Outbound;
}

export function pipelineGetResponseExtendPathsToJSON(
  pipelineGetResponseExtendPaths: PipelineGetResponseExtendPaths,
): string {
  return JSON.stringify(
    PipelineGetResponseExtendPaths$outboundSchema.parse(
      pipelineGetResponseExtendPaths,
    ),
  );
}

export function pipelineGetResponseExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<PipelineGetResponseExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PipelineGetResponseExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineGetResponseExtendPaths' from JSON`,
  );
}

/** @internal */
export const PipelineGetResponsePassThrough$inboundSchema: z.ZodType<
  PipelineGetResponsePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => PipelineGetResponseExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type PipelineGetResponsePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<PipelineGetResponseExtendPaths$Outbound> | undefined;
};

/** @internal */
export const PipelineGetResponsePassThrough$outboundSchema: z.ZodType<
  PipelineGetResponsePassThrough$Outbound,
  z.ZodTypeDef,
  PipelineGetResponsePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => PipelineGetResponseExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PipelineGetResponsePassThrough$ {
  /** @deprecated use `PipelineGetResponsePassThrough$inboundSchema` instead. */
  export const inboundSchema = PipelineGetResponsePassThrough$inboundSchema;
  /** @deprecated use `PipelineGetResponsePassThrough$outboundSchema` instead. */
  export const outboundSchema = PipelineGetResponsePassThrough$outboundSchema;
  /** @deprecated use `PipelineGetResponsePassThrough$Outbound` instead. */
  export type Outbound = PipelineGetResponsePassThrough$Outbound;
}

export function pipelineGetResponsePassThroughToJSON(
  pipelineGetResponsePassThrough: PipelineGetResponsePassThrough,
): string {
  return JSON.stringify(
    PipelineGetResponsePassThrough$outboundSchema.parse(
      pipelineGetResponsePassThrough,
    ),
  );
}

export function pipelineGetResponsePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<PipelineGetResponsePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PipelineGetResponsePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineGetResponsePassThrough' from JSON`,
  );
}

/** @internal */
export const PipelineGetResponseData$inboundSchema: z.ZodType<
  PipelineGetResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  name: z.string(),
  currency: z.nullable(PipelineGetResponseCurrency$inboundSchema).optional(),
  archived: z.boolean().optional(),
  active: z.boolean().optional(),
  display_order: z.nullable(z.number().int()).optional(),
  win_probability_enabled: z.boolean().optional(),
  stages: z.array(z.lazy(() => PipelineGetResponseStages$inboundSchema))
    .optional(),
  updated_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  created_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  pass_through: z.array(
    z.lazy(() => PipelineGetResponsePassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_order": "displayOrder",
    "win_probability_enabled": "winProbabilityEnabled",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type PipelineGetResponseData$Outbound = {
  id?: string | undefined;
  name: string;
  currency?: string | null | undefined;
  archived?: boolean | undefined;
  active?: boolean | undefined;
  display_order?: number | null | undefined;
  win_probability_enabled?: boolean | undefined;
  stages?: Array<PipelineGetResponseStages$Outbound> | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  pass_through?: Array<PipelineGetResponsePassThrough$Outbound> | undefined;
};

/** @internal */
export const PipelineGetResponseData$outboundSchema: z.ZodType<
  PipelineGetResponseData$Outbound,
  z.ZodTypeDef,
  PipelineGetResponseData
> = z.object({
  id: z.string().optional(),
  name: z.string(),
  currency: z.nullable(PipelineGetResponseCurrency$outboundSchema).optional(),
  archived: z.boolean().optional(),
  active: z.boolean().optional(),
  displayOrder: z.nullable(z.number().int()).optional(),
  winProbabilityEnabled: z.boolean().optional(),
  stages: z.array(z.lazy(() => PipelineGetResponseStages$outboundSchema))
    .optional(),
  updatedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  createdAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  passThrough: z.array(
    z.lazy(() => PipelineGetResponsePassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    displayOrder: "display_order",
    winProbabilityEnabled: "win_probability_enabled",
    updatedAt: "updated_at",
    createdAt: "created_at",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PipelineGetResponseData$ {
  /** @deprecated use `PipelineGetResponseData$inboundSchema` instead. */
  export const inboundSchema = PipelineGetResponseData$inboundSchema;
  /** @deprecated use `PipelineGetResponseData$outboundSchema` instead. */
  export const outboundSchema = PipelineGetResponseData$outboundSchema;
  /** @deprecated use `PipelineGetResponseData$Outbound` instead. */
  export type Outbound = PipelineGetResponseData$Outbound;
}

export function pipelineGetResponseDataToJSON(
  pipelineGetResponseData: PipelineGetResponseData,
): string {
  return JSON.stringify(
    PipelineGetResponseData$outboundSchema.parse(pipelineGetResponseData),
  );
}

export function pipelineGetResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<PipelineGetResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PipelineGetResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineGetResponseData' from JSON`,
  );
}

/** @internal */
export const PipelineGetResponse$inboundSchema: z.ZodType<
  PipelineGetResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => PipelineGetResponseData$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type PipelineGetResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: PipelineGetResponseData$Outbound;
};

/** @internal */
export const PipelineGetResponse$outboundSchema: z.ZodType<
  PipelineGetResponse$Outbound,
  z.ZodTypeDef,
  PipelineGetResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => PipelineGetResponseData$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PipelineGetResponse$ {
  /** @deprecated use `PipelineGetResponse$inboundSchema` instead. */
  export const inboundSchema = PipelineGetResponse$inboundSchema;
  /** @deprecated use `PipelineGetResponse$outboundSchema` instead. */
  export const outboundSchema = PipelineGetResponse$outboundSchema;
  /** @deprecated use `PipelineGetResponse$Outbound` instead. */
  export type Outbound = PipelineGetResponse$Outbound;
}

export function pipelineGetResponseToJSON(
  pipelineGetResponse: PipelineGetResponse,
): string {
  return JSON.stringify(
    PipelineGetResponse$outboundSchema.parse(pipelineGetResponse),
  );
}

export function pipelineGetResponseFromJSON(
  jsonString: string,
): SafeParseResult<PipelineGetResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PipelineGetResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineGetResponse' from JSON`,
  );
}

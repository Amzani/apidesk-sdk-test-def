/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Specifies the currency type for the monetary amount associated with the lead, following the ISO 4217 standard (e.g., USD for US Dollar, EUR for Euro). This ensures consistency in financial reporting and analysis across different regions and markets. It is essential for accurate financial calculations and comparisons, especially in multinational operations.
 */
export const LeadsListResponseCurrency = {
  UnknownCurrency: "UNKNOWN_CURRENCY",
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Bov: "BOV",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Che: "CHE",
  Chf: "CHF",
  Chw: "CHW",
  Clf: "CLF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Cou: "COU",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Ltl: "LTL",
  Lvl: "LVL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Mxv: "MXV",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Srd: "SRD",
  Ssp: "SSP",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Trc: "TRC",
  Try: "TRY",
  Ttd: "TTD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Usn: "USN",
  Uss: "USS",
  Uyi: "UYI",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xag: "XAG",
  Xau: "XAU",
  Xba: "XBA",
  Xbb: "XBB",
  Xbc: "XBC",
  Xbd: "XBD",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpd: "XPD",
  Xpf: "XPF",
  Xpt: "XPT",
  Xts: "XTS",
  Xxx: "XXX",
  Yer: "YER",
  Zar: "ZAR",
  Zmk: "ZMK",
  Zmw: "ZMW",
  Btc: "BTC",
  Eth: "ETH",
} as const;
/**
 * Specifies the currency type for the monetary amount associated with the lead, following the ISO 4217 standard (e.g., USD for US Dollar, EUR for Euro). This ensures consistency in financial reporting and analysis across different regions and markets. It is essential for accurate financial calculations and comparisons, especially in multinational operations.
 */
export type LeadsListResponseCurrency = ClosedEnum<
  typeof LeadsListResponseCurrency
>;

/**
 * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
 */
export const LeadsListResponseType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
 */
export type LeadsListResponseType = ClosedEnum<typeof LeadsListResponseType>;

export type LeadsListResponseWebsites = {
  /**
   * A unique identifier for each website entry associated with the lead, ensuring that each website can be distinctly referenced and managed within the CRM system. This ID is crucial for operations that involve updating or removing specific websites from the lead's profile, maintaining data integrity and consistency.
   */
  id?: string | null | undefined;
  /**
   * The website URL for the lead's business or personal site. This URL serves as a digital point of contact and is essential for verifying the lead's online presence. It must be a valid URL format, starting with http:// or https://, and is crucial for CRM users to access further information about the lead's activities or offerings. This field is required to ensure that the lead's digital footprint is accurately captured and easily accessible.
   */
  url: string;
  /**
   * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
   */
  type?: LeadsListResponseType | null | undefined;
};

/**
 * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
 */
export const LeadsListResponseDataType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Office: "office",
  Shipping: "shipping",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
 */
export type LeadsListResponseDataType = ClosedEnum<
  typeof LeadsListResponseDataType
>;

export type LeadsListResponseAddresses = {
  /**
   * A unique identifier for each address within the user's address array. This ID is crucial for distinguishing between different address records, especially when updating or deleting specific addresses. It ensures that each address can be individually referenced and managed within the CRM system, maintaining data integrity and accuracy.
   */
  id?: string | null | undefined;
  /**
   * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
   */
  type?: LeadsListResponseDataType | null | undefined;
  /**
   * The full address in a single string format, used when structured address data is not available. This field is essential for APIs that do not support detailed address components, allowing for a flexible representation of address information. It is particularly useful for quick data entry and display purposes.
   */
  string?: string | null | undefined;
  /**
   * A descriptive name for the address, often used to label or identify the address within the user's profile. This can include names like 'Headquarters', 'Main Office', or 'John's Apartment', providing a human-readable identifier that simplifies address management and selection within the CRM.
   */
  name?: string | null | undefined;
  /**
   * Line 1 of the address e.g. number, street, suite, apt #, etc.
   */
  line1?: string | null | undefined;
  /**
   * Line 2 of the address
   */
  line2?: string | null | undefined;
  /**
   * Line 3 of the address
   */
  line3?: string | null | undefined;
  /**
   * Line 4 of the address
   */
  line4?: string | null | undefined;
  /**
   * Street number
   */
  streetNumber?: string | null | undefined;
  /**
   * The name of the city associated with the user's address. This field is used to specify the city where the user resides or is located. It is important for geographical identification and can be used for location-based services or analytics. Ensure the city name is spelled correctly to maintain data accuracy and integrity within the CRM system.
   */
  city?: string | null | undefined;
  /**
   * The name of the state or region associated with the user's address. This field helps in identifying the specific administrative area within a country where the user is located. It is crucial for regional segmentation and can aid in compliance with local regulations. Ensure the state name is accurate to facilitate proper data management and reporting.
   */
  state?: string | null | undefined;
  /**
   * The postal code or equivalent for the user's address. This field is essential for precise location identification and is often used in mailing and shipping processes. It can also be used for demographic analysis and service eligibility checks. Ensure the postal code is valid and corresponds to the correct city and state to avoid errors in data processing.
   */
  postalCode?: string | null | undefined;
  /**
   * The country code for the user's address, following the ISO 3166-1 alpha-2 standard. This field is vital for internationalization and ensures that the user's location is correctly identified on a global scale. It supports cross-border operations and compliance with international standards. Ensure the country code is accurate to maintain consistency in global data management.
   */
  country?: string | null | undefined;
  /**
   * The latitude coordinate of the user's address. This field provides the geographical latitude, which is used in mapping and location-based services. It is important for applications that require precise geolocation, such as delivery services or geographic analysis. Ensure the latitude is accurate to enhance the reliability of location-dependent operations.
   */
  latitude?: string | null | undefined;
  /**
   * The longitude coordinate of the address, representing the east-west position on the Earth's surface. This value is crucial for geolocation services and mapping functionalities within the CRM, enabling precise location tracking and integration with geographic information systems. It should be a valid string representation of a decimal degree, typically ranging from -180.0 to 180.0.
   */
  longitude?: string | null | undefined;
  /**
   * This field captures the sublocality or county of the address, providing additional geographic context. It is particularly useful for regional segmentation and analysis, allowing for more granular data categorization and reporting. The county name should be accurately spelled to ensure consistency across records.
   */
  county?: string | null | undefined;
  /**
   * The full name of the primary contact person associated with the address. This information is vital for personalized communication and relationship management within the CRM. It should include both first and last names, and be kept up-to-date to reflect any changes in contact personnel.
   */
  contactName?: string | null | undefined;
  /**
   * The salutation or title used for the contact person at the address, such as Mr., Ms., Dr., etc. This field enhances formal communication and is important for maintaining professional etiquette in correspondence. It should be chosen based on the contact's preference and cultural norms.
   */
  salutation?: string | null | undefined;
  /**
   * The primary phone number associated with the address, used for direct communication with the contact person. This number should be formatted according to international standards to ensure it can be dialed from any location. It is essential for timely and effective communication, especially in customer service scenarios.
   */
  phoneNumber?: string | null | undefined;
  /**
   * The fax number associated with the user's address. This field allows for the inclusion of traditional communication methods, which may be necessary for certain business transactions or legal documentation. While not commonly used in modern digital communications, maintaining a fax number can be crucial for businesses that still rely on this method. Ensure the number is formatted correctly to avoid transmission errors.
   */
  fax?: string | null | undefined;
  /**
   * The email address linked to the user's address, serving as a primary mode of digital communication. This field is essential for sending notifications, updates, and other important information directly to the user. It should be a valid email format to ensure successful delivery and communication. Keeping this information up-to-date is vital for maintaining effective contact with the user.
   */
  email?: string | null | undefined;
  /**
   * The website URL associated with the user's address, providing a digital point of reference or contact. This can be used to direct users to a personal or business website, offering more information or services. Ensure the URL is complete and correctly formatted to facilitate seamless access. This field supports the user's digital presence and connectivity.
   */
  website?: string | null | undefined;
  /**
   * Additional notes related to the user's address, offering space for any extra information that might be relevant but does not fit into other predefined fields. This could include special delivery instructions, historical data, or personal preferences. These notes can be crucial for personalized service and ensuring all relevant details are captured.
   */
  notes?: string | null | undefined;
  /**
   * A binary value used to track changes to the user's address object, ensuring data integrity and preventing update conflicts. This field is automatically incremented with each update, allowing the system to detect concurrent modifications and manage them appropriately. It is crucial for maintaining accurate and consistent data across the CRM system, especially in environments with multiple users accessing the same records.
   */
  rowVersion?: string | null | undefined;
};

export type LeadsListResponseSocialLinks = {
  /**
   * A unique identifier for each social link entry within the array. This ID is used to distinguish between different social media profiles associated with the lead, ensuring that each link can be individually referenced and managed. It is essential for operations that involve updating or removing specific social links without affecting others.
   */
  id?: string | null | undefined;
  /**
   * The complete URL of the social media profile associated with the lead. This field is required and must be a valid URL format, such as 'https://www.twitter.com/apideck'. It provides direct access to the lead's social media presence, enabling CRM users to quickly view and interact with the lead's profiles. Accurate URLs are vital for maintaining effective communication and engagement strategies.
   */
  url: string;
  /**
   * Specifies the type of social media link associated with the lead, such as Twitter, LinkedIn, or Facebook. This field helps categorize and manage the lead's social media presence within the CRM, allowing for targeted communication strategies. It is optional but recommended for leads with active social media profiles to enhance engagement tracking.
   */
  type?: string | null | undefined;
};

/**
 * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
 */
export const LeadsListResponseDataPhoneNumbersType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Work: "work",
  Office: "office",
  Mobile: "mobile",
  Assistant: "assistant",
  Fax: "fax",
  DirectDialIn: "direct-dial-in",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
 */
export type LeadsListResponseDataPhoneNumbersType = ClosedEnum<
  typeof LeadsListResponseDataPhoneNumbersType
>;

export type LeadsListResponsePhoneNumbers = {
  /**
   * A unique identifier for each phone number entry within the user's phone numbers array. This ID is crucial for distinguishing between different phone numbers, especially when updating or deleting specific numbers. It ensures that operations are performed on the correct phone number entry, maintaining data integrity within the user's contact information.
   */
  id?: string | null | undefined;
  /**
   * The international dialing code associated with the phone number, such as '+1' for the United States. This field is essential for ensuring that phone numbers are formatted correctly for international dialing and can be used to validate the geographical origin of the number. It helps in standardizing phone numbers across different regions and is critical for applications that involve international communication.
   */
  countryCode?: string | null | undefined;
  /**
   * The regional area code that precedes the local phone number, such as '323' for parts of Los Angeles. This code is important for routing calls within specific geographic areas and is a key component of the full phone number. Including the area code ensures that the phone number is complete and can be dialed correctly from both local and international locations.
   */
  areaCode?: string | null | undefined;
  /**
   * The main part of the phone number, excluding the country and area codes. This field is required as it represents the actual number that will be dialed within the specified area and country codes. It is the core component of the user's contact information and must be accurate to ensure successful communication. This field is mandatory to ensure that there is a valid number associated with the user.
   */
  number: string;
  /**
   * The extension of the phone number, typically used in corporate environments to direct calls to specific departments or employees. This field is optional and should be used when the phone number is part of a larger system, such as a PBX, where extensions are necessary for routing calls internally. Including an extension ensures that calls reach the intended recipient without delay.
   */
  extension?: string | null | undefined;
  /**
   * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
   */
  type?: LeadsListResponseDataPhoneNumbersType | null | undefined;
};

/**
 * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
 */
export const LeadsListResponseDataEmailsType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
 */
export type LeadsListResponseDataEmailsType = ClosedEnum<
  typeof LeadsListResponseDataEmailsType
>;

export type LeadsListResponseEmails = {
  /**
   * A unique identifier for each email address within the user's email collection. This ID is used to distinguish between multiple email addresses associated with a single user, allowing for precise updates and management of contact information. It is optional but can be useful for operations that require specific email targeting.
   */
  id?: string | null | undefined;
  /**
   * The actual email address used for electronic communication with the user. This field is required and must be a valid email format to ensure successful delivery of messages. It serves as a primary contact method and is essential for user engagement and CRM operations.
   */
  email: string | null;
  /**
   * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
   */
  type?: LeadsListResponseDataEmailsType | null | undefined;
};

export type LeadsListResponseValue6 = {};

export type LeadsListResponseValue4 = {};

/**
 * The value assigned to a custom field within the opportunity record. Custom fields allow for additional, user-defined data to be stored, providing flexibility to tailor the CRM to specific business needs. This field is optional and can be used to capture unique attributes or metrics relevant to the opportunity that are not covered by standard fields.
 */
export type LeadsListResponseValue =
  | LeadsListResponseValue4
  | string
  | number
  | boolean
  | Array<string>
  | Array<LeadsListResponseValue6>;

export type LeadsListResponseCustomFields = {
  /**
   * Unique identifier for the custom field. This ID is essential for distinguishing each custom field within the opportunity's data structure. It ensures that each field can be individually accessed, updated, or removed as needed. The ID must be unique within the context of the opportunity to prevent data conflicts and maintain data integrity.
   */
  id: string | null;
  /**
   * Name of the custom field. This name serves as a label for the custom field, providing a human-readable identifier that describes the field's purpose or content. While not required, including a name can improve clarity and usability, especially when multiple custom fields are present. It should be concise yet descriptive enough to convey the field's role in the opportunity's data.
   */
  name?: string | null | undefined;
  /**
   * More information about the custom field. This description offers additional context or details about the custom field's intended use or significance. It can include guidelines on what type of data should be entered or how the field relates to the overall sales process. Providing a description is optional but can enhance understanding and proper utilization of the custom field by users.
   */
  description?: string | null | undefined;
  /**
   * The value assigned to a custom field within the opportunity record. Custom fields allow for additional, user-defined data to be stored, providing flexibility to tailor the CRM to specific business needs. This field is optional and can be used to capture unique attributes or metrics relevant to the opportunity that are not covered by standard fields.
   */
  value?:
    | LeadsListResponseValue4
    | string
    | number
    | boolean
    | Array<string>
    | Array<LeadsListResponseValue6>
    | null
    | undefined;
};

/**
 * This object contains the results of any custom mappings configured for the lead resource. Custom mappings allow for the alignment of CRM fields with external systems or specific business processes, ensuring that data is accurately transferred and interpreted across different platforms. This property is particularly useful when integrating with third-party services or when custom workflows are in place, providing a seamless data exchange experience.
 */
export type LeadsListResponseCustomMappings = {};

export type LeadsListResponseExtendPaths = {
  /**
   * A JSONPath string that specifies the exact location within the user record where the value should be applied. This is essential for making precise updates to nested fields, ensuring that changes are made only to the intended parts of the data structure. The path must be valid and correspond to an existing field within the user record.
   */
  path: string;
  /**
   * This property represents the specific value that you wish to assign to a designated path within the user record. It can be of any data type, such as a string, number, boolean, or object, depending on the field being updated. The flexibility of this property allows for a wide range of updates, from simple text changes to complex data structures. In the context of the `usersUpdate` operation, this property is crucial for specifying the exact data modification you intend to make, ensuring that only the targeted fields are altered without affecting other data. Proper validation should be applied to ensure the value is compatible with the field's expected data type and business rules. Common use cases include updating user contact information, preferences, or custom attributes specific to your CRM's schema.
   */
  value?: any | undefined;
};

export type LeadsListResponsePassThrough = {
  /**
   * The unique identifier for the specific service to which this pass_through should be applied. This is crucial for directing the update operation to the correct service within the CRM system, ensuring that the modifications are executed in the appropriate context. It must be a valid service ID that corresponds to an active service integration, and it is required for the operation to proceed.
   */
  serviceId: string;
  /**
   * An optional identifier for a specific workflow operation within the CRM system to which this pass_through should be applied. This is particularly useful for Unify calls that involve multiple downstream requests, allowing for precise targeting and execution of specific operations. If provided, it should match an existing operation ID to ensure correct processing.
   */
  operationId?: string | undefined;
  /**
   * A flexible object that allows for the inclusion of any additional properties needed for direct extension of the user record. This can be used to add custom fields or metadata that are not part of the standard user schema, providing a way to tailor the user data to specific business needs. The structure of this object should align with the CRM's data model to ensure compatibility.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects designed for structured data modifications via specified paths. This allows for precise updates to nested data structures within the user record, enabling complex modifications without altering unrelated data. Each object in the array should define a clear path and value to be applied, ensuring targeted updates.
   */
  extendPaths?: Array<LeadsListResponseExtendPaths> | undefined;
};

export type LeadsListResponseData = {
  /**
   * A unique identifier for the contact within the CRM system. This identifier is automatically generated by the system when a lead is created and is used to precisely target and update the correct lead record. Although not required for the update operation, providing this ensures that the correct lead is modified, especially in systems with large datasets where name collisions might occur. It is crucial for maintaining data integrity and avoiding accidental updates to the wrong record.
   */
  id?: string | undefined;
  /**
   * The full name of the lead, which serves as a primary identifier in the CRM system. This field is required to ensure that the lead can be easily recognized and managed within the CRM. It is essential for personalized communication and for linking the lead to other records, such as interactions and transactions. The name should be entered in a format that is consistent with other records to maintain uniformity across the system.
   */
  name: string;
  /**
   * The name of the company with which the lead is associated. This field is required to establish a clear connection between the lead and their business context, which is vital for B2B interactions. It helps in categorizing and segmenting leads based on their business affiliations, enabling targeted marketing and sales strategies. The company name should be accurate and reflect the official business name to ensure consistency across records.
   */
  companyName: string | null;
  /**
   * The unique identifier of the user or agent who owns or is responsible for managing the lead. This field, while not required, is important for assigning accountability and tracking the lead's progress through the sales pipeline. It allows for efficient delegation and follow-up actions by the responsible party. The owner ID should correspond to a valid user in the system to ensure proper assignment and management.
   */
  ownerId?: string | null | undefined;
  /**
   * The name of the individual who owns or is responsible for the lead. This field, although not required, provides a human-readable reference to the lead's owner, facilitating easier recognition and communication. It complements the owner ID by offering a more intuitive way to identify the responsible party, especially in reports and dashboards. The owner name should match the user's official name in the system for consistency.
   */
  ownerName?: string | null | undefined;
  /**
   * The unique identifier for the company that the lead is associated with. This ID links the lead to its parent company within the CRM, ensuring that all interactions and updates are correctly attributed to the right organization. It is essential for maintaining accurate records of which company the lead belongs to, especially in scenarios where leads are transferred between companies or when analyzing lead data by company. This field is optional but recommended for leads that are part of a larger corporate structure.
   */
  companyId?: string | null | undefined;
  /**
   * The unique identifier for the lead within the CRM system. This ID is crucial for distinguishing between different leads, especially when multiple leads have similar names or details. It serves as the primary key for updating the lead's information and must be used accurately to ensure that the correct lead record is modified. Although not required in the request body, it is typically used in conjunction with the path parameter to confirm the lead being updated.
   */
  leadId?: string | null | undefined;
  /**
   * The origin or method through which the lead was acquired, such as 'web', 'referral', or 'trade show'. Understanding the lead source is vital for tracking the effectiveness of marketing campaigns and sales strategies. This information helps in analyzing which channels are most successful in generating leads and can guide future marketing efforts. While optional, providing the lead source can enhance the quality of lead data analytics.
   */
  leadSource?: string | null | undefined;
  /**
   * The given name of the lead, used for personalization in communications and record-keeping. Including the first name is important for creating a personalized experience for the lead, which can improve engagement and conversion rates. This field should be filled with the lead's legal first name or preferred name for accurate identification and communication.
   */
  firstName?: string | null | undefined;
  /**
   * The surname or family name of the lead, essential for identification and formal communication. The last name is used in conjunction with the first name to uniquely identify a lead within the CRM, especially in cases where multiple leads share the same first name. It is important for maintaining professional correspondence and ensuring that records are complete and accurate.
   */
  lastName?: string | null | undefined;
  /**
   * A detailed narrative about the lead, capturing essential information that provides context and background. This field can include notes on the lead's interests, needs, and any previous interactions. It is valuable for sales and marketing teams to tailor their approach and communication strategies. While not mandatory, providing a comprehensive description can enhance the personalization of follow-up actions and improve lead engagement.
   */
  description?: string | null | undefined;
  /**
   * An optional field to specify the lead's prefix, such as Mr., Ms., Dr., etc. This is used to address the lead appropriately in communications and can contribute to a more personalized and respectful interaction. Although not required, including a prefix can enhance the professionalism of correspondence and is particularly useful in formal business environments.
   */
  prefix?: string | null | undefined;
  /**
   * The professional job title of the lead, such as 'Marketing Manager' or 'Sales Director'. This information helps in understanding the lead's role and level of decision-making authority within their organization. It is useful for segmenting leads and tailoring communication strategies based on their professional responsibilities. While optional, providing a job title can significantly aid in targeting the right message to the right person.
   */
  title?: string | null | undefined;
  /**
   * The preferred language of communication for the lead, represented by a two-letter ISO 639-1 code (e.g., 'EN' for English). This field is crucial for ensuring that all communications are conducted in a language the lead understands, thereby improving engagement and reducing misunderstandings. It supports internationalization and localization efforts, making it easier to manage leads from diverse linguistic backgrounds. Although optional, specifying the language can enhance the effectiveness of communication strategies.
   */
  language?: string | null | undefined;
  /**
   * The current status of the lead within the CRM system, such as 'New', 'Contacted', 'Qualified', etc. This field is instrumental in tracking the lead's journey through the sales pipeline and helps in prioritizing follow-up actions. It provides insights into the lead's engagement level and readiness to proceed to the next stage. While not mandatory, updating the status regularly can improve sales forecasting and resource allocation.
   */
  status?: string | null | undefined;
  /**
   * The total financial value associated with the lead, representing potential revenue. This field is crucial for forecasting and prioritizing leads based on their potential impact on sales. It should be a positive number, reflecting the expected deal size in the specified currency. Commonly used by sales teams to assess lead quality and allocate resources effectively.
   */
  monetaryAmount?: number | null | undefined;
  /**
   * Specifies the currency type for the monetary amount associated with the lead, following the ISO 4217 standard (e.g., USD for US Dollar, EUR for Euro). This ensures consistency in financial reporting and analysis across different regions and markets. It is essential for accurate financial calculations and comparisons, especially in multinational operations.
   */
  currency?: LeadsListResponseCurrency | null | undefined;
  /**
   * The contact fax number for the lead, which may be used for sending documents or formal communications. Although less common in digital communications, it remains relevant in industries where faxing is still a standard practice. The number should include the country code and area code for international consistency.
   */
  fax?: string | null | undefined;
  /**
   * A list of websites associated with the lead, providing additional context or resources related to the lead's business or personal interests. This can include corporate websites, personal blogs, or social media profiles. Useful for sales and marketing teams to gather more information about the lead's online presence and engagement.
   */
  websites?: Array<LeadsListResponseWebsites> | undefined;
  /**
   * An array of address objects associated with the lead. Each address provides location details that can be used for geographical analysis, regional marketing strategies, or logistical planning. This array can include multiple addresses, such as home, work, or billing addresses, offering a comprehensive view of the lead's physical locations.
   */
  addresses?: Array<LeadsListResponseAddresses> | undefined;
  /**
   * An array containing the social media links associated with the lead. Each entry in this array represents a different social media profile, allowing for a comprehensive view of the lead's online presence. This can be particularly useful for sales and marketing teams to understand the lead's interests and engagement across various platforms. The array can include multiple entries, each with its own unique identifier and URL.
   */
  socialLinks?: Array<LeadsListResponseSocialLinks> | undefined;
  /**
   * A collection of phone number objects associated with the lead. Each object within the array can contain details such as the phone number's unique identifier, country code, and area code. This array allows for storing multiple contact numbers, facilitating diverse communication channels with the lead. It is optional but useful for leads with multiple contact numbers.
   */
  phoneNumbers?: Array<LeadsListResponsePhoneNumbers> | undefined;
  /**
   * A collection of email addresses associated with the lead. This array can include multiple entries to accommodate different contact points, such as personal and work emails, enhancing the flexibility and reach of communication strategies.
   */
  emails?: Array<LeadsListResponseEmails> | undefined;
  /**
   * An array of custom fields that allow for additional, user-defined data to be associated with the lead. These fields enable customization and flexibility, accommodating unique business needs and enhancing lead profiles with specific information not covered by standard fields.
   */
  customFields?: Array<LeadsListResponseCustomFields> | undefined;
  /**
   * An array of tags associated with the lead, used to categorize or label the lead for easier identification and filtering within the CRM. Tags can represent various attributes or statuses, such as 'VIP', 'Prospect', or 'Follow-up', and help in organizing leads based on specific criteria. This property is optional but can significantly enhance lead management by enabling quick searches and segmentation.
   */
  tags?: Array<string> | null | undefined;
  /**
   * This object contains the results of any custom mappings configured for the lead resource. Custom mappings allow for the alignment of CRM fields with external systems or specific business processes, ensuring that data is accurately transferred and interpreted across different platforms. This property is particularly useful when integrating with third-party services or when custom workflows are in place, providing a seamless data exchange experience.
   */
  customMappings?: LeadsListResponseCustomMappings | null | undefined;
  /**
   * The 'updated_at' field represents the timestamp when the lead record was last modified, formatted in ISO 8601. This field is crucial for tracking changes and ensuring data consistency across systems. It is automatically updated by the system upon any modification to the lead record, providing a reliable audit trail for data updates. While not required in the request body, it is essential for applications that need to synchronize data changes or maintain historical records of lead modifications.
   */
  updatedAt?: string | null | undefined;
  /**
   * The 'created_at' field indicates the timestamp when the lead record was initially created, formatted in ISO 8601. This field is important for understanding the lifecycle of a lead and for reporting purposes, such as calculating the age of a lead or tracking lead generation trends over time. Although not required in the request body for updates, it provides context and historical data that can be valuable for analytics and auditing.
   */
  createdAt?: string | null | undefined;
  /**
   * The 'pass_through' property is an array that allows the inclusion of service-specific custom data or structured modifications within the request body when updating lead resources. This feature is particularly useful for integrating with third-party services that require additional parameters or configurations not covered by standard fields. It enables flexibility and extensibility in handling unique business requirements or workflows that involve multiple systems. Each entry in the array should adhere to the expected structure defined by the target service.
   */
  passThrough?: Array<LeadsListResponsePassThrough> | undefined;
};

/**
 * This property provides cursors that are used to navigate through paginated API responses, allowing clients to move to previous or next pages of data. It is included in the response when pagination is enabled, facilitating seamless data retrieval across multiple API calls. This ensures that applications can efficiently access large datasets without overwhelming the client or server.
 */
export type LeadsListResponseCursors = {
  /**
   * The 'previous' cursor is a string token used to retrieve the preceding set of results in a paginated API response. It is included in the response when there are more results available before the current set, allowing clients to navigate backward through the data. This cursor is particularly useful in scenarios where users need to review or analyze data from earlier pages.
   */
  previous?: string | null | undefined;
  /**
   * The 'current' cursor is a string token representing the current position in the paginated list of results. It is included in the response to indicate the current page's starting point, helping clients maintain their place in the data sequence during navigation. This is essential for tracking the current dataset being viewed or processed.
   */
  current?: string | null | undefined;
  /**
   * The 'next' cursor is a string token that facilitates navigation to the subsequent set of results in a paginated API response. It is included when additional data is available beyond the current page, enabling clients to continue retrieving more results seamlessly. This is crucial for applications that need to process large datasets incrementally.
   */
  next?: string | null | undefined;
};

/**
 * The 'meta' object contains metadata about the response, providing additional context and information about the data returned. This object is included to help clients understand the structure and status of the response, especially in cases involving pagination or filtering.
 */
export type LeadsListResponseMeta = {
  /**
   * This property indicates the number of items that are included in the 'data' section of the response. It is particularly useful for understanding the volume of data returned in a single API call, especially when pagination is in use. This property is included in the response to help clients manage data processing and display, ensuring that applications can handle the data efficiently.
   */
  itemsOnPage?: number | undefined;
  /**
   * This property provides cursors that are used to navigate through paginated API responses, allowing clients to move to previous or next pages of data. It is included in the response when pagination is enabled, facilitating seamless data retrieval across multiple API calls. This ensures that applications can efficiently access large datasets without overwhelming the client or server.
   */
  cursors?: LeadsListResponseCursors | undefined;
};

/**
 * The 'links' object contains navigational URLs that facilitate easy access to different pages of the API response. This object is included when pagination is applied, providing structured links to move between pages. It enhances user experience by offering direct links to the previous, current, and next pages, thus simplifying the process of data retrieval across multiple pages.
 */
export type LeadsListResponseLinks = {
  /**
   * The 'previous' link is a URL string that directs clients to the previous page of results in the API. It is included when there are earlier pages available, allowing users to easily navigate back to review or access prior data. This link is essential for applications that support backward navigation through paginated datasets.
   */
  previous?: string | null | undefined;
  /**
   * This property provides a URL link that directs to the current page of the user list in the API response. It is particularly useful for applications implementing pagination, allowing them to easily reload or refresh the current set of user data. This link is included in the response when pagination is in use, ensuring that users can maintain their current position within the dataset when navigating through multiple pages of results.
   */
  current?: string | undefined;
  /**
   * This property contains a URL link that directs to the next page of the user list in the API response. It is essential for applications that need to handle large datasets by breaking them into manageable pages. This link is included when there are additional pages of user data available beyond the current page, facilitating seamless navigation through the complete list of users without manually constructing URLs.
   */
  next?: string | null | undefined;
};

/**
 * Leads
 */
export type LeadsListResponse = {
  /**
   * The HTTP response status code returned by the server. This integer value indicates the result of the HTTP request made to the '/crm/leads' endpoint. A status code of 200 signifies a successful retrieval of lead data, while other codes may indicate various errors or issues with the request. This property is always included in the response to provide immediate feedback on the request's outcome.
   */
  statusCode: number;
  /**
   * The HTTP response status message accompanying the status code. This string provides a textual representation of the status code, offering a human-readable explanation of the request's result. For example, 'OK' typically accompanies a 200 status code, indicating success. This property is essential for understanding the context of the response and is always included.
   */
  status: string;
  /**
   * The Apideck ID of the service provider that processed the request. This string uniquely identifies the service within the Apideck ecosystem, allowing users to track which service handled the lead retrieval operation. It is crucial for debugging and auditing purposes, especially in environments with multiple integrated services. This property is always included in the response.
   */
  service: string;
  /**
   * The name of the unified API resource accessed during the operation. This string identifies the specific resource within the Apideck platform, in this case, 'leads', which was queried to retrieve lead data. It helps in understanding the context of the API call and is always included to clarify the resource involved in the operation.
   */
  resource: string;
  /**
   * The specific operation performed by the API request. This string describes the action taken, such as 'retrieve' for fetching lead data from the CRM. It provides clarity on what the API call was intended to do, aiding in tracking and logging API usage. This property is always included to ensure transparency in the operation performed.
   */
  operation: string;
  /**
   * An array containing the list of lead objects retrieved from the CRM. Each object in this array represents a single lead with its associated details. This property is always included in the response to provide the complete set of leads that match the query parameters specified in the request. It is essential for iterating over the leads data and accessing individual lead information.
   */
  data: Array<LeadsListResponseData>;
  /**
   * The 'meta' object contains metadata about the response, providing additional context and information about the data returned. This object is included to help clients understand the structure and status of the response, especially in cases involving pagination or filtering.
   */
  meta?: LeadsListResponseMeta | undefined;
  /**
   * The 'links' object contains navigational URLs that facilitate easy access to different pages of the API response. This object is included when pagination is applied, providing structured links to move between pages. It enhances user experience by offering direct links to the previous, current, and next pages, thus simplifying the process of data retrieval across multiple pages.
   */
  links?: LeadsListResponseLinks | undefined;
};

/** @internal */
export const LeadsListResponseCurrency$inboundSchema: z.ZodNativeEnum<
  typeof LeadsListResponseCurrency
> = z.nativeEnum(LeadsListResponseCurrency);

/** @internal */
export const LeadsListResponseCurrency$outboundSchema: z.ZodNativeEnum<
  typeof LeadsListResponseCurrency
> = LeadsListResponseCurrency$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseCurrency$ {
  /** @deprecated use `LeadsListResponseCurrency$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseCurrency$inboundSchema;
  /** @deprecated use `LeadsListResponseCurrency$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseCurrency$outboundSchema;
}

/** @internal */
export const LeadsListResponseType$inboundSchema: z.ZodNativeEnum<
  typeof LeadsListResponseType
> = z.nativeEnum(LeadsListResponseType);

/** @internal */
export const LeadsListResponseType$outboundSchema: z.ZodNativeEnum<
  typeof LeadsListResponseType
> = LeadsListResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseType$ {
  /** @deprecated use `LeadsListResponseType$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseType$inboundSchema;
  /** @deprecated use `LeadsListResponseType$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseType$outboundSchema;
}

/** @internal */
export const LeadsListResponseWebsites$inboundSchema: z.ZodType<
  LeadsListResponseWebsites,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(LeadsListResponseType$inboundSchema).optional(),
});

/** @internal */
export type LeadsListResponseWebsites$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const LeadsListResponseWebsites$outboundSchema: z.ZodType<
  LeadsListResponseWebsites$Outbound,
  z.ZodTypeDef,
  LeadsListResponseWebsites
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(LeadsListResponseType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseWebsites$ {
  /** @deprecated use `LeadsListResponseWebsites$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseWebsites$inboundSchema;
  /** @deprecated use `LeadsListResponseWebsites$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseWebsites$outboundSchema;
  /** @deprecated use `LeadsListResponseWebsites$Outbound` instead. */
  export type Outbound = LeadsListResponseWebsites$Outbound;
}

export function leadsListResponseWebsitesToJSON(
  leadsListResponseWebsites: LeadsListResponseWebsites,
): string {
  return JSON.stringify(
    LeadsListResponseWebsites$outboundSchema.parse(leadsListResponseWebsites),
  );
}

export function leadsListResponseWebsitesFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseWebsites, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseWebsites$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseWebsites' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseDataType$inboundSchema: z.ZodNativeEnum<
  typeof LeadsListResponseDataType
> = z.nativeEnum(LeadsListResponseDataType);

/** @internal */
export const LeadsListResponseDataType$outboundSchema: z.ZodNativeEnum<
  typeof LeadsListResponseDataType
> = LeadsListResponseDataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseDataType$ {
  /** @deprecated use `LeadsListResponseDataType$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseDataType$inboundSchema;
  /** @deprecated use `LeadsListResponseDataType$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseDataType$outboundSchema;
}

/** @internal */
export const LeadsListResponseAddresses$inboundSchema: z.ZodType<
  LeadsListResponseAddresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(LeadsListResponseDataType$inboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  street_number: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postal_code: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contact_name: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phone_number: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  row_version: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "street_number": "streetNumber",
    "postal_code": "postalCode",
    "contact_name": "contactName",
    "phone_number": "phoneNumber",
    "row_version": "rowVersion",
  });
});

/** @internal */
export type LeadsListResponseAddresses$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
  string?: string | null | undefined;
  name?: string | null | undefined;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  line3?: string | null | undefined;
  line4?: string | null | undefined;
  street_number?: string | null | undefined;
  city?: string | null | undefined;
  state?: string | null | undefined;
  postal_code?: string | null | undefined;
  country?: string | null | undefined;
  latitude?: string | null | undefined;
  longitude?: string | null | undefined;
  county?: string | null | undefined;
  contact_name?: string | null | undefined;
  salutation?: string | null | undefined;
  phone_number?: string | null | undefined;
  fax?: string | null | undefined;
  email?: string | null | undefined;
  website?: string | null | undefined;
  notes?: string | null | undefined;
  row_version?: string | null | undefined;
};

/** @internal */
export const LeadsListResponseAddresses$outboundSchema: z.ZodType<
  LeadsListResponseAddresses$Outbound,
  z.ZodTypeDef,
  LeadsListResponseAddresses
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(LeadsListResponseDataType$outboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  streetNumber: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contactName: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phoneNumber: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  rowVersion: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    streetNumber: "street_number",
    postalCode: "postal_code",
    contactName: "contact_name",
    phoneNumber: "phone_number",
    rowVersion: "row_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseAddresses$ {
  /** @deprecated use `LeadsListResponseAddresses$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseAddresses$inboundSchema;
  /** @deprecated use `LeadsListResponseAddresses$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseAddresses$outboundSchema;
  /** @deprecated use `LeadsListResponseAddresses$Outbound` instead. */
  export type Outbound = LeadsListResponseAddresses$Outbound;
}

export function leadsListResponseAddressesToJSON(
  leadsListResponseAddresses: LeadsListResponseAddresses,
): string {
  return JSON.stringify(
    LeadsListResponseAddresses$outboundSchema.parse(leadsListResponseAddresses),
  );
}

export function leadsListResponseAddressesFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseAddresses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseAddresses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseAddresses' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseSocialLinks$inboundSchema: z.ZodType<
  LeadsListResponseSocialLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/** @internal */
export type LeadsListResponseSocialLinks$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const LeadsListResponseSocialLinks$outboundSchema: z.ZodType<
  LeadsListResponseSocialLinks$Outbound,
  z.ZodTypeDef,
  LeadsListResponseSocialLinks
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseSocialLinks$ {
  /** @deprecated use `LeadsListResponseSocialLinks$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseSocialLinks$inboundSchema;
  /** @deprecated use `LeadsListResponseSocialLinks$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseSocialLinks$outboundSchema;
  /** @deprecated use `LeadsListResponseSocialLinks$Outbound` instead. */
  export type Outbound = LeadsListResponseSocialLinks$Outbound;
}

export function leadsListResponseSocialLinksToJSON(
  leadsListResponseSocialLinks: LeadsListResponseSocialLinks,
): string {
  return JSON.stringify(
    LeadsListResponseSocialLinks$outboundSchema.parse(
      leadsListResponseSocialLinks,
    ),
  );
}

export function leadsListResponseSocialLinksFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseSocialLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseSocialLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseSocialLinks' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseDataPhoneNumbersType$inboundSchema:
  z.ZodNativeEnum<typeof LeadsListResponseDataPhoneNumbersType> = z.nativeEnum(
    LeadsListResponseDataPhoneNumbersType,
  );

/** @internal */
export const LeadsListResponseDataPhoneNumbersType$outboundSchema:
  z.ZodNativeEnum<typeof LeadsListResponseDataPhoneNumbersType> =
    LeadsListResponseDataPhoneNumbersType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseDataPhoneNumbersType$ {
  /** @deprecated use `LeadsListResponseDataPhoneNumbersType$inboundSchema` instead. */
  export const inboundSchema =
    LeadsListResponseDataPhoneNumbersType$inboundSchema;
  /** @deprecated use `LeadsListResponseDataPhoneNumbersType$outboundSchema` instead. */
  export const outboundSchema =
    LeadsListResponseDataPhoneNumbersType$outboundSchema;
}

/** @internal */
export const LeadsListResponsePhoneNumbers$inboundSchema: z.ZodType<
  LeadsListResponsePhoneNumbers,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  country_code: z.nullable(z.string()).optional(),
  area_code: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(LeadsListResponseDataPhoneNumbersType$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "country_code": "countryCode",
    "area_code": "areaCode",
  });
});

/** @internal */
export type LeadsListResponsePhoneNumbers$Outbound = {
  id?: string | null | undefined;
  country_code?: string | null | undefined;
  area_code?: string | null | undefined;
  number: string;
  extension?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const LeadsListResponsePhoneNumbers$outboundSchema: z.ZodType<
  LeadsListResponsePhoneNumbers$Outbound,
  z.ZodTypeDef,
  LeadsListResponsePhoneNumbers
> = z.object({
  id: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  areaCode: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(LeadsListResponseDataPhoneNumbersType$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    countryCode: "country_code",
    areaCode: "area_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponsePhoneNumbers$ {
  /** @deprecated use `LeadsListResponsePhoneNumbers$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponsePhoneNumbers$inboundSchema;
  /** @deprecated use `LeadsListResponsePhoneNumbers$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponsePhoneNumbers$outboundSchema;
  /** @deprecated use `LeadsListResponsePhoneNumbers$Outbound` instead. */
  export type Outbound = LeadsListResponsePhoneNumbers$Outbound;
}

export function leadsListResponsePhoneNumbersToJSON(
  leadsListResponsePhoneNumbers: LeadsListResponsePhoneNumbers,
): string {
  return JSON.stringify(
    LeadsListResponsePhoneNumbers$outboundSchema.parse(
      leadsListResponsePhoneNumbers,
    ),
  );
}

export function leadsListResponsePhoneNumbersFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponsePhoneNumbers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponsePhoneNumbers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponsePhoneNumbers' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseDataEmailsType$inboundSchema: z.ZodNativeEnum<
  typeof LeadsListResponseDataEmailsType
> = z.nativeEnum(LeadsListResponseDataEmailsType);

/** @internal */
export const LeadsListResponseDataEmailsType$outboundSchema: z.ZodNativeEnum<
  typeof LeadsListResponseDataEmailsType
> = LeadsListResponseDataEmailsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseDataEmailsType$ {
  /** @deprecated use `LeadsListResponseDataEmailsType$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseDataEmailsType$inboundSchema;
  /** @deprecated use `LeadsListResponseDataEmailsType$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseDataEmailsType$outboundSchema;
}

/** @internal */
export const LeadsListResponseEmails$inboundSchema: z.ZodType<
  LeadsListResponseEmails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(LeadsListResponseDataEmailsType$inboundSchema).optional(),
});

/** @internal */
export type LeadsListResponseEmails$Outbound = {
  id?: string | null | undefined;
  email: string | null;
  type?: string | null | undefined;
};

/** @internal */
export const LeadsListResponseEmails$outboundSchema: z.ZodType<
  LeadsListResponseEmails$Outbound,
  z.ZodTypeDef,
  LeadsListResponseEmails
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(LeadsListResponseDataEmailsType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseEmails$ {
  /** @deprecated use `LeadsListResponseEmails$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseEmails$inboundSchema;
  /** @deprecated use `LeadsListResponseEmails$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseEmails$outboundSchema;
  /** @deprecated use `LeadsListResponseEmails$Outbound` instead. */
  export type Outbound = LeadsListResponseEmails$Outbound;
}

export function leadsListResponseEmailsToJSON(
  leadsListResponseEmails: LeadsListResponseEmails,
): string {
  return JSON.stringify(
    LeadsListResponseEmails$outboundSchema.parse(leadsListResponseEmails),
  );
}

export function leadsListResponseEmailsFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseEmails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseEmails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseEmails' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseValue6$inboundSchema: z.ZodType<
  LeadsListResponseValue6,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type LeadsListResponseValue6$Outbound = {};

/** @internal */
export const LeadsListResponseValue6$outboundSchema: z.ZodType<
  LeadsListResponseValue6$Outbound,
  z.ZodTypeDef,
  LeadsListResponseValue6
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseValue6$ {
  /** @deprecated use `LeadsListResponseValue6$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseValue6$inboundSchema;
  /** @deprecated use `LeadsListResponseValue6$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseValue6$outboundSchema;
  /** @deprecated use `LeadsListResponseValue6$Outbound` instead. */
  export type Outbound = LeadsListResponseValue6$Outbound;
}

export function leadsListResponseValue6ToJSON(
  leadsListResponseValue6: LeadsListResponseValue6,
): string {
  return JSON.stringify(
    LeadsListResponseValue6$outboundSchema.parse(leadsListResponseValue6),
  );
}

export function leadsListResponseValue6FromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseValue6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseValue6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseValue6' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseValue4$inboundSchema: z.ZodType<
  LeadsListResponseValue4,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type LeadsListResponseValue4$Outbound = {};

/** @internal */
export const LeadsListResponseValue4$outboundSchema: z.ZodType<
  LeadsListResponseValue4$Outbound,
  z.ZodTypeDef,
  LeadsListResponseValue4
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseValue4$ {
  /** @deprecated use `LeadsListResponseValue4$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseValue4$inboundSchema;
  /** @deprecated use `LeadsListResponseValue4$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseValue4$outboundSchema;
  /** @deprecated use `LeadsListResponseValue4$Outbound` instead. */
  export type Outbound = LeadsListResponseValue4$Outbound;
}

export function leadsListResponseValue4ToJSON(
  leadsListResponseValue4: LeadsListResponseValue4,
): string {
  return JSON.stringify(
    LeadsListResponseValue4$outboundSchema.parse(leadsListResponseValue4),
  );
}

export function leadsListResponseValue4FromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseValue4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseValue4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseValue4' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseValue$inboundSchema: z.ZodType<
  LeadsListResponseValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => LeadsListResponseValue4$inboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
  z.array(z.string()),
  z.array(z.lazy(() => LeadsListResponseValue6$inboundSchema)),
]);

/** @internal */
export type LeadsListResponseValue$Outbound =
  | LeadsListResponseValue4$Outbound
  | string
  | number
  | boolean
  | Array<string>
  | Array<LeadsListResponseValue6$Outbound>;

/** @internal */
export const LeadsListResponseValue$outboundSchema: z.ZodType<
  LeadsListResponseValue$Outbound,
  z.ZodTypeDef,
  LeadsListResponseValue
> = z.union([
  z.lazy(() => LeadsListResponseValue4$outboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
  z.array(z.string()),
  z.array(z.lazy(() => LeadsListResponseValue6$outboundSchema)),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseValue$ {
  /** @deprecated use `LeadsListResponseValue$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseValue$inboundSchema;
  /** @deprecated use `LeadsListResponseValue$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseValue$outboundSchema;
  /** @deprecated use `LeadsListResponseValue$Outbound` instead. */
  export type Outbound = LeadsListResponseValue$Outbound;
}

export function leadsListResponseValueToJSON(
  leadsListResponseValue: LeadsListResponseValue,
): string {
  return JSON.stringify(
    LeadsListResponseValue$outboundSchema.parse(leadsListResponseValue),
  );
}

export function leadsListResponseValueFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseValue' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseCustomFields$inboundSchema: z.ZodType<
  LeadsListResponseCustomFields,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => LeadsListResponseValue4$inboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => LeadsListResponseValue6$inboundSchema)),
    ]),
  ).optional(),
});

/** @internal */
export type LeadsListResponseCustomFields$Outbound = {
  id: string | null;
  name?: string | null | undefined;
  description?: string | null | undefined;
  value?:
    | LeadsListResponseValue4$Outbound
    | string
    | number
    | boolean
    | Array<string>
    | Array<LeadsListResponseValue6$Outbound>
    | null
    | undefined;
};

/** @internal */
export const LeadsListResponseCustomFields$outboundSchema: z.ZodType<
  LeadsListResponseCustomFields$Outbound,
  z.ZodTypeDef,
  LeadsListResponseCustomFields
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => LeadsListResponseValue4$outboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => LeadsListResponseValue6$outboundSchema)),
    ]),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseCustomFields$ {
  /** @deprecated use `LeadsListResponseCustomFields$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseCustomFields$inboundSchema;
  /** @deprecated use `LeadsListResponseCustomFields$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseCustomFields$outboundSchema;
  /** @deprecated use `LeadsListResponseCustomFields$Outbound` instead. */
  export type Outbound = LeadsListResponseCustomFields$Outbound;
}

export function leadsListResponseCustomFieldsToJSON(
  leadsListResponseCustomFields: LeadsListResponseCustomFields,
): string {
  return JSON.stringify(
    LeadsListResponseCustomFields$outboundSchema.parse(
      leadsListResponseCustomFields,
    ),
  );
}

export function leadsListResponseCustomFieldsFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseCustomFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseCustomFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseCustomFields' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseCustomMappings$inboundSchema: z.ZodType<
  LeadsListResponseCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type LeadsListResponseCustomMappings$Outbound = {};

/** @internal */
export const LeadsListResponseCustomMappings$outboundSchema: z.ZodType<
  LeadsListResponseCustomMappings$Outbound,
  z.ZodTypeDef,
  LeadsListResponseCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseCustomMappings$ {
  /** @deprecated use `LeadsListResponseCustomMappings$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseCustomMappings$inboundSchema;
  /** @deprecated use `LeadsListResponseCustomMappings$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseCustomMappings$outboundSchema;
  /** @deprecated use `LeadsListResponseCustomMappings$Outbound` instead. */
  export type Outbound = LeadsListResponseCustomMappings$Outbound;
}

export function leadsListResponseCustomMappingsToJSON(
  leadsListResponseCustomMappings: LeadsListResponseCustomMappings,
): string {
  return JSON.stringify(
    LeadsListResponseCustomMappings$outboundSchema.parse(
      leadsListResponseCustomMappings,
    ),
  );
}

export function leadsListResponseCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseCustomMappings' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseExtendPaths$inboundSchema: z.ZodType<
  LeadsListResponseExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type LeadsListResponseExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const LeadsListResponseExtendPaths$outboundSchema: z.ZodType<
  LeadsListResponseExtendPaths$Outbound,
  z.ZodTypeDef,
  LeadsListResponseExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseExtendPaths$ {
  /** @deprecated use `LeadsListResponseExtendPaths$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseExtendPaths$inboundSchema;
  /** @deprecated use `LeadsListResponseExtendPaths$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseExtendPaths$outboundSchema;
  /** @deprecated use `LeadsListResponseExtendPaths$Outbound` instead. */
  export type Outbound = LeadsListResponseExtendPaths$Outbound;
}

export function leadsListResponseExtendPathsToJSON(
  leadsListResponseExtendPaths: LeadsListResponseExtendPaths,
): string {
  return JSON.stringify(
    LeadsListResponseExtendPaths$outboundSchema.parse(
      leadsListResponseExtendPaths,
    ),
  );
}

export function leadsListResponseExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseExtendPaths' from JSON`,
  );
}

/** @internal */
export const LeadsListResponsePassThrough$inboundSchema: z.ZodType<
  LeadsListResponsePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => LeadsListResponseExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type LeadsListResponsePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<LeadsListResponseExtendPaths$Outbound> | undefined;
};

/** @internal */
export const LeadsListResponsePassThrough$outboundSchema: z.ZodType<
  LeadsListResponsePassThrough$Outbound,
  z.ZodTypeDef,
  LeadsListResponsePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => LeadsListResponseExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponsePassThrough$ {
  /** @deprecated use `LeadsListResponsePassThrough$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponsePassThrough$inboundSchema;
  /** @deprecated use `LeadsListResponsePassThrough$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponsePassThrough$outboundSchema;
  /** @deprecated use `LeadsListResponsePassThrough$Outbound` instead. */
  export type Outbound = LeadsListResponsePassThrough$Outbound;
}

export function leadsListResponsePassThroughToJSON(
  leadsListResponsePassThrough: LeadsListResponsePassThrough,
): string {
  return JSON.stringify(
    LeadsListResponsePassThrough$outboundSchema.parse(
      leadsListResponsePassThrough,
    ),
  );
}

export function leadsListResponsePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponsePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponsePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponsePassThrough' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseData$inboundSchema: z.ZodType<
  LeadsListResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  name: z.string(),
  company_name: z.nullable(z.string()),
  owner_id: z.nullable(z.string()).optional(),
  owner_name: z.nullable(z.string()).optional(),
  company_id: z.nullable(z.string()).optional(),
  lead_id: z.nullable(z.string()).optional(),
  lead_source: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  prefix: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  monetary_amount: z.nullable(z.number()).optional(),
  currency: z.nullable(LeadsListResponseCurrency$inboundSchema).optional(),
  fax: z.nullable(z.string()).optional(),
  websites: z.array(z.lazy(() => LeadsListResponseWebsites$inboundSchema))
    .optional(),
  addresses: z.array(z.lazy(() => LeadsListResponseAddresses$inboundSchema))
    .optional(),
  social_links: z.array(
    z.lazy(() => LeadsListResponseSocialLinks$inboundSchema),
  ).optional(),
  phone_numbers: z.array(
    z.lazy(() => LeadsListResponsePhoneNumbers$inboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => LeadsListResponseEmails$inboundSchema))
    .optional(),
  custom_fields: z.array(
    z.lazy(() => LeadsListResponseCustomFields$inboundSchema),
  ).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  custom_mappings: z.nullable(
    z.lazy(() => LeadsListResponseCustomMappings$inboundSchema),
  ).optional(),
  updated_at: z.nullable(z.string()).optional(),
  created_at: z.nullable(z.string()).optional(),
  pass_through: z.array(
    z.lazy(() => LeadsListResponsePassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "company_name": "companyName",
    "owner_id": "ownerId",
    "owner_name": "ownerName",
    "company_id": "companyId",
    "lead_id": "leadId",
    "lead_source": "leadSource",
    "first_name": "firstName",
    "last_name": "lastName",
    "monetary_amount": "monetaryAmount",
    "social_links": "socialLinks",
    "phone_numbers": "phoneNumbers",
    "custom_fields": "customFields",
    "custom_mappings": "customMappings",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type LeadsListResponseData$Outbound = {
  id?: string | undefined;
  name: string;
  company_name: string | null;
  owner_id?: string | null | undefined;
  owner_name?: string | null | undefined;
  company_id?: string | null | undefined;
  lead_id?: string | null | undefined;
  lead_source?: string | null | undefined;
  first_name?: string | null | undefined;
  last_name?: string | null | undefined;
  description?: string | null | undefined;
  prefix?: string | null | undefined;
  title?: string | null | undefined;
  language?: string | null | undefined;
  status?: string | null | undefined;
  monetary_amount?: number | null | undefined;
  currency?: string | null | undefined;
  fax?: string | null | undefined;
  websites?: Array<LeadsListResponseWebsites$Outbound> | undefined;
  addresses?: Array<LeadsListResponseAddresses$Outbound> | undefined;
  social_links?: Array<LeadsListResponseSocialLinks$Outbound> | undefined;
  phone_numbers?: Array<LeadsListResponsePhoneNumbers$Outbound> | undefined;
  emails?: Array<LeadsListResponseEmails$Outbound> | undefined;
  custom_fields?: Array<LeadsListResponseCustomFields$Outbound> | undefined;
  tags?: Array<string> | null | undefined;
  custom_mappings?: LeadsListResponseCustomMappings$Outbound | null | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  pass_through?: Array<LeadsListResponsePassThrough$Outbound> | undefined;
};

/** @internal */
export const LeadsListResponseData$outboundSchema: z.ZodType<
  LeadsListResponseData$Outbound,
  z.ZodTypeDef,
  LeadsListResponseData
> = z.object({
  id: z.string().optional(),
  name: z.string(),
  companyName: z.nullable(z.string()),
  ownerId: z.nullable(z.string()).optional(),
  ownerName: z.nullable(z.string()).optional(),
  companyId: z.nullable(z.string()).optional(),
  leadId: z.nullable(z.string()).optional(),
  leadSource: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  prefix: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  monetaryAmount: z.nullable(z.number()).optional(),
  currency: z.nullable(LeadsListResponseCurrency$outboundSchema).optional(),
  fax: z.nullable(z.string()).optional(),
  websites: z.array(z.lazy(() => LeadsListResponseWebsites$outboundSchema))
    .optional(),
  addresses: z.array(z.lazy(() => LeadsListResponseAddresses$outboundSchema))
    .optional(),
  socialLinks: z.array(
    z.lazy(() => LeadsListResponseSocialLinks$outboundSchema),
  ).optional(),
  phoneNumbers: z.array(
    z.lazy(() => LeadsListResponsePhoneNumbers$outboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => LeadsListResponseEmails$outboundSchema))
    .optional(),
  customFields: z.array(
    z.lazy(() => LeadsListResponseCustomFields$outboundSchema),
  ).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  customMappings: z.nullable(
    z.lazy(() => LeadsListResponseCustomMappings$outboundSchema),
  ).optional(),
  updatedAt: z.nullable(z.string()).optional(),
  createdAt: z.nullable(z.string()).optional(),
  passThrough: z.array(
    z.lazy(() => LeadsListResponsePassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    companyName: "company_name",
    ownerId: "owner_id",
    ownerName: "owner_name",
    companyId: "company_id",
    leadId: "lead_id",
    leadSource: "lead_source",
    firstName: "first_name",
    lastName: "last_name",
    monetaryAmount: "monetary_amount",
    socialLinks: "social_links",
    phoneNumbers: "phone_numbers",
    customFields: "custom_fields",
    customMappings: "custom_mappings",
    updatedAt: "updated_at",
    createdAt: "created_at",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseData$ {
  /** @deprecated use `LeadsListResponseData$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseData$inboundSchema;
  /** @deprecated use `LeadsListResponseData$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseData$outboundSchema;
  /** @deprecated use `LeadsListResponseData$Outbound` instead. */
  export type Outbound = LeadsListResponseData$Outbound;
}

export function leadsListResponseDataToJSON(
  leadsListResponseData: LeadsListResponseData,
): string {
  return JSON.stringify(
    LeadsListResponseData$outboundSchema.parse(leadsListResponseData),
  );
}

export function leadsListResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseData' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseCursors$inboundSchema: z.ZodType<
  LeadsListResponseCursors,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type LeadsListResponseCursors$Outbound = {
  previous?: string | null | undefined;
  current?: string | null | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const LeadsListResponseCursors$outboundSchema: z.ZodType<
  LeadsListResponseCursors$Outbound,
  z.ZodTypeDef,
  LeadsListResponseCursors
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseCursors$ {
  /** @deprecated use `LeadsListResponseCursors$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseCursors$inboundSchema;
  /** @deprecated use `LeadsListResponseCursors$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseCursors$outboundSchema;
  /** @deprecated use `LeadsListResponseCursors$Outbound` instead. */
  export type Outbound = LeadsListResponseCursors$Outbound;
}

export function leadsListResponseCursorsToJSON(
  leadsListResponseCursors: LeadsListResponseCursors,
): string {
  return JSON.stringify(
    LeadsListResponseCursors$outboundSchema.parse(leadsListResponseCursors),
  );
}

export function leadsListResponseCursorsFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseCursors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseCursors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseCursors' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseMeta$inboundSchema: z.ZodType<
  LeadsListResponseMeta,
  z.ZodTypeDef,
  unknown
> = z.object({
  items_on_page: z.number().int().optional(),
  cursors: z.lazy(() => LeadsListResponseCursors$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "items_on_page": "itemsOnPage",
  });
});

/** @internal */
export type LeadsListResponseMeta$Outbound = {
  items_on_page?: number | undefined;
  cursors?: LeadsListResponseCursors$Outbound | undefined;
};

/** @internal */
export const LeadsListResponseMeta$outboundSchema: z.ZodType<
  LeadsListResponseMeta$Outbound,
  z.ZodTypeDef,
  LeadsListResponseMeta
> = z.object({
  itemsOnPage: z.number().int().optional(),
  cursors: z.lazy(() => LeadsListResponseCursors$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    itemsOnPage: "items_on_page",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseMeta$ {
  /** @deprecated use `LeadsListResponseMeta$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseMeta$inboundSchema;
  /** @deprecated use `LeadsListResponseMeta$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseMeta$outboundSchema;
  /** @deprecated use `LeadsListResponseMeta$Outbound` instead. */
  export type Outbound = LeadsListResponseMeta$Outbound;
}

export function leadsListResponseMetaToJSON(
  leadsListResponseMeta: LeadsListResponseMeta,
): string {
  return JSON.stringify(
    LeadsListResponseMeta$outboundSchema.parse(leadsListResponseMeta),
  );
}

export function leadsListResponseMetaFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseMeta, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseMeta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseMeta' from JSON`,
  );
}

/** @internal */
export const LeadsListResponseLinks$inboundSchema: z.ZodType<
  LeadsListResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type LeadsListResponseLinks$Outbound = {
  previous?: string | null | undefined;
  current?: string | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const LeadsListResponseLinks$outboundSchema: z.ZodType<
  LeadsListResponseLinks$Outbound,
  z.ZodTypeDef,
  LeadsListResponseLinks
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponseLinks$ {
  /** @deprecated use `LeadsListResponseLinks$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponseLinks$inboundSchema;
  /** @deprecated use `LeadsListResponseLinks$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponseLinks$outboundSchema;
  /** @deprecated use `LeadsListResponseLinks$Outbound` instead. */
  export type Outbound = LeadsListResponseLinks$Outbound;
}

export function leadsListResponseLinksToJSON(
  leadsListResponseLinks: LeadsListResponseLinks,
): string {
  return JSON.stringify(
    LeadsListResponseLinks$outboundSchema.parse(leadsListResponseLinks),
  );
}

export function leadsListResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponseLinks' from JSON`,
  );
}

/** @internal */
export const LeadsListResponse$inboundSchema: z.ZodType<
  LeadsListResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => LeadsListResponseData$inboundSchema)),
  meta: z.lazy(() => LeadsListResponseMeta$inboundSchema).optional(),
  links: z.lazy(() => LeadsListResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type LeadsListResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: Array<LeadsListResponseData$Outbound>;
  meta?: LeadsListResponseMeta$Outbound | undefined;
  links?: LeadsListResponseLinks$Outbound | undefined;
};

/** @internal */
export const LeadsListResponse$outboundSchema: z.ZodType<
  LeadsListResponse$Outbound,
  z.ZodTypeDef,
  LeadsListResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => LeadsListResponseData$outboundSchema)),
  meta: z.lazy(() => LeadsListResponseMeta$outboundSchema).optional(),
  links: z.lazy(() => LeadsListResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadsListResponse$ {
  /** @deprecated use `LeadsListResponse$inboundSchema` instead. */
  export const inboundSchema = LeadsListResponse$inboundSchema;
  /** @deprecated use `LeadsListResponse$outboundSchema` instead. */
  export const outboundSchema = LeadsListResponse$outboundSchema;
  /** @deprecated use `LeadsListResponse$Outbound` instead. */
  export type Outbound = LeadsListResponse$Outbound;
}

export function leadsListResponseToJSON(
  leadsListResponse: LeadsListResponse,
): string {
  return JSON.stringify(
    LeadsListResponse$outboundSchema.parse(leadsListResponse),
  );
}

export function leadsListResponseFromJSON(
  jsonString: string,
): SafeParseResult<LeadsListResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadsListResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadsListResponse' from JSON`,
  );
}

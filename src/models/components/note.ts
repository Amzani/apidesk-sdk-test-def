/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Contains any custom mappings configured for the note resource. This object provides additional metadata or configuration details specific to the note, enhancing its integration with other systems or processes.
 */
export type NoteCustomMappings = {};

export type NoteExtendPaths = {
  /**
   * This property contains a JSONPath string that specifies the exact location within the note's data structure where a particular value should be applied. It is crucial for pinpointing the precise path in the JSON object, ensuring that the correct data is retrieved or manipulated. The format follows standard JSONPath syntax, which allows for complex querying and navigation of JSON data.
   */
  path: string;
  /**
   * This property holds the value that is to be set at the specified JSONPath within the note's data structure. The value can be of any data type, such as string, number, or object, depending on what is appropriate for the specified path. It is essential for updating or retrieving specific data points within the note, ensuring that the correct information is accessed or modified.
   */
  value?: any | undefined;
};

export type NotePassThrough = {
  /**
   * A string that uniquely identifies the service to which the pass_through data should be applied. This ensures that the custom data is directed to the correct service integration when retrieving a note.
   */
  serviceId: string;
  /**
   * An optional string identifier for a specific workflow operation. This is particularly useful when the note retrieval involves multiple downstream requests, allowing developers to track or modify specific operations within the workflow.
   */
  operationId?: string | undefined;
  /**
   * An object that allows for direct extension with any properties. This provides flexibility for developers to include additional fields or data structures that may be necessary for the note retrieval process.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects used for structured data modifications via paths. This allows developers to specify precise modifications or extensions to the note data, enhancing the customization of the response.
   */
  extendPaths?: Array<NoteExtendPaths> | undefined;
};

/**
 * This object contains all the details of the specific note retrieved from the CRM system. It serves as the main container for the note's information, including its unique identifier, title, content, and owner details. The structure of this object is crucial for accessing the individual properties of the note.
 */
export type Note = {
  /**
   * The unique identifier of the note within the CRM system. This ID is used to reference the note in future operations, such as updates or deletions, and is essential for distinguishing this note from others.
   */
  id?: string | undefined;
  /**
   * The title of the note, providing a brief summary or headline for the content. This field helps users quickly identify the note's subject or main topic within the CRM system.
   */
  title?: string | null | undefined;
  /**
   * The main body of the note, containing detailed information or comments. This content is typically formatted as plain text and is the primary focus of the note, offering insights or records pertinent to CRM activities.
   */
  content?: string | null | undefined;
  /**
   * The identifier of the user who owns or created the note. This field links the note to its creator, allowing for tracking of authorship and responsibility within the CRM system.
   */
  ownerId?: string | null | undefined;
  /**
   * The unique identifier of the contact associated with this note. This ID allows developers to link the note to a specific contact within the CRM system, facilitating easy retrieval and management of related contact information. The format is a string, typically a UUID or similar unique string identifier.
   */
  contactId?: string | null | undefined;
  /**
   * The unique identifier of the company associated with this note. This property helps in linking the note to a particular company, enabling developers to manage and access company-related notes efficiently. The value is a string, usually formatted as a UUID or another unique string identifier.
   */
  companyId?: string | null | undefined;
  /**
   * The unique identifier for the opportunity related to this note. This ID is crucial for associating the note with a specific sales opportunity, allowing for streamlined tracking and management of opportunity-related communications. The format is a string, often a UUID or similar unique identifier.
   */
  opportunityId?: string | null | undefined;
  /**
   * The unique identifier of the lead associated with this note. This property enables developers to connect the note to a specific lead, facilitating the organization and retrieval of lead-related notes. The format is a string, typically a UUID or another unique string identifier.
   */
  leadId?: string | null | undefined;
  /**
   * Indicates whether the note is currently active. This boolean value helps developers determine if the note is in use or has been archived, affecting how the note is displayed and interacted with in the CRM system. A value of 'true' means the note is active, while 'false' indicates it is inactive.
   */
  active?: boolean | null | undefined;
  /**
   * Contains any custom mappings configured for the note resource. This object provides additional metadata or configuration details specific to the note, enhancing its integration with other systems or processes.
   */
  customMappings?: NoteCustomMappings | null | undefined;
  /**
   * The identifier of the user who last modified the note. This string helps track changes and maintain an audit trail of who has interacted with the note.
   */
  updatedBy?: string | null | undefined;
  /**
   * The identifier of the user who originally created the note. This information is useful for understanding the origin of the note and attributing its creation to a specific user.
   */
  createdBy?: string | null | undefined;
  /**
   * The ISO 8601 formatted timestamp indicating when the note was last updated. This timestamp is crucial for synchronization and ensuring the note's data is current.
   */
  updatedAt?: string | null | undefined;
  /**
   * The ISO 8601 formatted timestamp indicating when the note was initially created. This provides a historical context for the note, allowing users to see when it was first added to the system.
   */
  createdAt?: string | null | undefined;
  /**
   * An array containing service-specific custom data or structured modifications. This property allows developers to pass additional data when retrieving a note, which can be used to customize or extend the response based on specific service requirements.
   */
  passThrough?: Array<NotePassThrough> | undefined;
};

/** @internal */
export const NoteCustomMappings$inboundSchema: z.ZodType<
  NoteCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type NoteCustomMappings$Outbound = {};

/** @internal */
export const NoteCustomMappings$outboundSchema: z.ZodType<
  NoteCustomMappings$Outbound,
  z.ZodTypeDef,
  NoteCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteCustomMappings$ {
  /** @deprecated use `NoteCustomMappings$inboundSchema` instead. */
  export const inboundSchema = NoteCustomMappings$inboundSchema;
  /** @deprecated use `NoteCustomMappings$outboundSchema` instead. */
  export const outboundSchema = NoteCustomMappings$outboundSchema;
  /** @deprecated use `NoteCustomMappings$Outbound` instead. */
  export type Outbound = NoteCustomMappings$Outbound;
}

export function noteCustomMappingsToJSON(
  noteCustomMappings: NoteCustomMappings,
): string {
  return JSON.stringify(
    NoteCustomMappings$outboundSchema.parse(noteCustomMappings),
  );
}

export function noteCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<NoteCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteCustomMappings' from JSON`,
  );
}

/** @internal */
export const NoteExtendPaths$inboundSchema: z.ZodType<
  NoteExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type NoteExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const NoteExtendPaths$outboundSchema: z.ZodType<
  NoteExtendPaths$Outbound,
  z.ZodTypeDef,
  NoteExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteExtendPaths$ {
  /** @deprecated use `NoteExtendPaths$inboundSchema` instead. */
  export const inboundSchema = NoteExtendPaths$inboundSchema;
  /** @deprecated use `NoteExtendPaths$outboundSchema` instead. */
  export const outboundSchema = NoteExtendPaths$outboundSchema;
  /** @deprecated use `NoteExtendPaths$Outbound` instead. */
  export type Outbound = NoteExtendPaths$Outbound;
}

export function noteExtendPathsToJSON(
  noteExtendPaths: NoteExtendPaths,
): string {
  return JSON.stringify(NoteExtendPaths$outboundSchema.parse(noteExtendPaths));
}

export function noteExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<NoteExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteExtendPaths' from JSON`,
  );
}

/** @internal */
export const NotePassThrough$inboundSchema: z.ZodType<
  NotePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(z.lazy(() => NoteExtendPaths$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type NotePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<NoteExtendPaths$Outbound> | undefined;
};

/** @internal */
export const NotePassThrough$outboundSchema: z.ZodType<
  NotePassThrough$Outbound,
  z.ZodTypeDef,
  NotePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(z.lazy(() => NoteExtendPaths$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotePassThrough$ {
  /** @deprecated use `NotePassThrough$inboundSchema` instead. */
  export const inboundSchema = NotePassThrough$inboundSchema;
  /** @deprecated use `NotePassThrough$outboundSchema` instead. */
  export const outboundSchema = NotePassThrough$outboundSchema;
  /** @deprecated use `NotePassThrough$Outbound` instead. */
  export type Outbound = NotePassThrough$Outbound;
}

export function notePassThroughToJSON(
  notePassThrough: NotePassThrough,
): string {
  return JSON.stringify(NotePassThrough$outboundSchema.parse(notePassThrough));
}

export function notePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<NotePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotePassThrough' from JSON`,
  );
}

/** @internal */
export const Note$inboundSchema: z.ZodType<Note, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string().optional(),
    title: z.nullable(z.string()).optional(),
    content: z.nullable(z.string()).optional(),
    owner_id: z.nullable(z.string()).optional(),
    contact_id: z.nullable(z.string()).optional(),
    company_id: z.nullable(z.string()).optional(),
    opportunity_id: z.nullable(z.string()).optional(),
    lead_id: z.nullable(z.string()).optional(),
    active: z.nullable(z.boolean()).optional(),
    custom_mappings: z.nullable(z.lazy(() => NoteCustomMappings$inboundSchema))
      .optional(),
    updated_by: z.nullable(z.string()).optional(),
    created_by: z.nullable(z.string()).optional(),
    updated_at: z.nullable(z.string()).optional(),
    created_at: z.nullable(z.string()).optional(),
    pass_through: z.array(z.lazy(() => NotePassThrough$inboundSchema))
      .optional(),
  }).transform((v) => {
    return remap$(v, {
      "owner_id": "ownerId",
      "contact_id": "contactId",
      "company_id": "companyId",
      "opportunity_id": "opportunityId",
      "lead_id": "leadId",
      "custom_mappings": "customMappings",
      "updated_by": "updatedBy",
      "created_by": "createdBy",
      "updated_at": "updatedAt",
      "created_at": "createdAt",
      "pass_through": "passThrough",
    });
  });

/** @internal */
export type Note$Outbound = {
  id?: string | undefined;
  title?: string | null | undefined;
  content?: string | null | undefined;
  owner_id?: string | null | undefined;
  contact_id?: string | null | undefined;
  company_id?: string | null | undefined;
  opportunity_id?: string | null | undefined;
  lead_id?: string | null | undefined;
  active?: boolean | null | undefined;
  custom_mappings?: NoteCustomMappings$Outbound | null | undefined;
  updated_by?: string | null | undefined;
  created_by?: string | null | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  pass_through?: Array<NotePassThrough$Outbound> | undefined;
};

/** @internal */
export const Note$outboundSchema: z.ZodType<Note$Outbound, z.ZodTypeDef, Note> =
  z.object({
    id: z.string().optional(),
    title: z.nullable(z.string()).optional(),
    content: z.nullable(z.string()).optional(),
    ownerId: z.nullable(z.string()).optional(),
    contactId: z.nullable(z.string()).optional(),
    companyId: z.nullable(z.string()).optional(),
    opportunityId: z.nullable(z.string()).optional(),
    leadId: z.nullable(z.string()).optional(),
    active: z.nullable(z.boolean()).optional(),
    customMappings: z.nullable(z.lazy(() => NoteCustomMappings$outboundSchema))
      .optional(),
    updatedBy: z.nullable(z.string()).optional(),
    createdBy: z.nullable(z.string()).optional(),
    updatedAt: z.nullable(z.string()).optional(),
    createdAt: z.nullable(z.string()).optional(),
    passThrough: z.array(z.lazy(() => NotePassThrough$outboundSchema))
      .optional(),
  }).transform((v) => {
    return remap$(v, {
      ownerId: "owner_id",
      contactId: "contact_id",
      companyId: "company_id",
      opportunityId: "opportunity_id",
      leadId: "lead_id",
      customMappings: "custom_mappings",
      updatedBy: "updated_by",
      createdBy: "created_by",
      updatedAt: "updated_at",
      createdAt: "created_at",
      passThrough: "pass_through",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Note$ {
  /** @deprecated use `Note$inboundSchema` instead. */
  export const inboundSchema = Note$inboundSchema;
  /** @deprecated use `Note$outboundSchema` instead. */
  export const outboundSchema = Note$outboundSchema;
  /** @deprecated use `Note$Outbound` instead. */
  export type Outbound = Note$Outbound;
}

export function noteToJSON(note: Note): string {
  return JSON.stringify(Note$outboundSchema.parse(note));
}

export function noteFromJSON(
  jsonString: string,
): SafeParseResult<Note, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Note$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Note' from JSON`,
  );
}

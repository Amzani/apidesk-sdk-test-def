/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The classification or category of the contact, such as 'customer', 'supplier', or 'partner'. This optional field helps in segmenting contacts for targeted communication and reporting. Understanding the type of contact can influence how interactions are prioritized and managed within the CRM system.
 */
export const ContactGetResponseType = {
  Customer: "customer",
  Supplier: "supplier",
  Employee: "employee",
  Personal: "personal",
} as const;
/**
 * The classification or category of the contact, such as 'customer', 'supplier', or 'partner'. This optional field helps in segmenting contacts for targeted communication and reporting. Understanding the type of contact can influence how interactions are prioritized and managed within the CRM system.
 */
export type ContactGetResponseType = ClosedEnum<typeof ContactGetResponseType>;

/**
 * Specifies the gender of the contact, which can be used for personalized communication and marketing strategies. Acceptable values typically include 'male', 'female', 'non-binary', or 'other'. This field is optional and should be used in accordance with privacy regulations and the contact's preferences.
 */
export const ContactGetResponseGender = {
  Male: "male",
  Female: "female",
  Unisex: "unisex",
} as const;
/**
 * Specifies the gender of the contact, which can be used for personalized communication and marketing strategies. Acceptable values typically include 'male', 'female', 'non-binary', or 'other'. This field is optional and should be used in accordance with privacy regulations and the contact's preferences.
 */
export type ContactGetResponseGender = ClosedEnum<
  typeof ContactGetResponseGender
>;

/**
 * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
 */
export const ContactGetResponseDataType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
 */
export type ContactGetResponseDataType = ClosedEnum<
  typeof ContactGetResponseDataType
>;

export type ContactGetResponseWebsites = {
  /**
   * A unique identifier for each website entry associated with the lead, ensuring that each website can be distinctly referenced and managed within the CRM system. This ID is crucial for operations that involve updating or removing specific websites from the lead's profile, maintaining data integrity and consistency.
   */
  id?: string | null | undefined;
  /**
   * The website URL for the lead's business or personal site. This URL serves as a digital point of contact and is essential for verifying the lead's online presence. It must be a valid URL format, starting with http:// or https://, and is crucial for CRM users to access further information about the lead's activities or offerings. This field is required to ensure that the lead's digital footprint is accurately captured and easily accessible.
   */
  url: string;
  /**
   * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
   */
  type?: ContactGetResponseDataType | null | undefined;
};

/**
 * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
 */
export const ContactGetResponseDataAddressesType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Office: "office",
  Shipping: "shipping",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
 */
export type ContactGetResponseDataAddressesType = ClosedEnum<
  typeof ContactGetResponseDataAddressesType
>;

export type ContactGetResponseAddresses = {
  /**
   * A unique identifier for each address within the user's address array. This ID is crucial for distinguishing between different address records, especially when updating or deleting specific addresses. It ensures that each address can be individually referenced and managed within the CRM system, maintaining data integrity and accuracy.
   */
  id?: string | null | undefined;
  /**
   * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
   */
  type?: ContactGetResponseDataAddressesType | null | undefined;
  /**
   * The full address in a single string format, used when structured address data is not available. This field is essential for APIs that do not support detailed address components, allowing for a flexible representation of address information. It is particularly useful for quick data entry and display purposes.
   */
  string?: string | null | undefined;
  /**
   * A descriptive name for the address, often used to label or identify the address within the user's profile. This can include names like 'Headquarters', 'Main Office', or 'John's Apartment', providing a human-readable identifier that simplifies address management and selection within the CRM.
   */
  name?: string | null | undefined;
  /**
   * Line 1 of the address e.g. number, street, suite, apt #, etc.
   */
  line1?: string | null | undefined;
  /**
   * Line 2 of the address
   */
  line2?: string | null | undefined;
  /**
   * Line 3 of the address
   */
  line3?: string | null | undefined;
  /**
   * Line 4 of the address
   */
  line4?: string | null | undefined;
  /**
   * Street number
   */
  streetNumber?: string | null | undefined;
  /**
   * The name of the city associated with the user's address. This field is used to specify the city where the user resides or is located. It is important for geographical identification and can be used for location-based services or analytics. Ensure the city name is spelled correctly to maintain data accuracy and integrity within the CRM system.
   */
  city?: string | null | undefined;
  /**
   * The name of the state or region associated with the user's address. This field helps in identifying the specific administrative area within a country where the user is located. It is crucial for regional segmentation and can aid in compliance with local regulations. Ensure the state name is accurate to facilitate proper data management and reporting.
   */
  state?: string | null | undefined;
  /**
   * The postal code or equivalent for the user's address. This field is essential for precise location identification and is often used in mailing and shipping processes. It can also be used for demographic analysis and service eligibility checks. Ensure the postal code is valid and corresponds to the correct city and state to avoid errors in data processing.
   */
  postalCode?: string | null | undefined;
  /**
   * The country code for the user's address, following the ISO 3166-1 alpha-2 standard. This field is vital for internationalization and ensures that the user's location is correctly identified on a global scale. It supports cross-border operations and compliance with international standards. Ensure the country code is accurate to maintain consistency in global data management.
   */
  country?: string | null | undefined;
  /**
   * The latitude coordinate of the user's address. This field provides the geographical latitude, which is used in mapping and location-based services. It is important for applications that require precise geolocation, such as delivery services or geographic analysis. Ensure the latitude is accurate to enhance the reliability of location-dependent operations.
   */
  latitude?: string | null | undefined;
  /**
   * The longitude coordinate of the address, representing the east-west position on the Earth's surface. This value is crucial for geolocation services and mapping functionalities within the CRM, enabling precise location tracking and integration with geographic information systems. It should be a valid string representation of a decimal degree, typically ranging from -180.0 to 180.0.
   */
  longitude?: string | null | undefined;
  /**
   * This field captures the sublocality or county of the address, providing additional geographic context. It is particularly useful for regional segmentation and analysis, allowing for more granular data categorization and reporting. The county name should be accurately spelled to ensure consistency across records.
   */
  county?: string | null | undefined;
  /**
   * The full name of the primary contact person associated with the address. This information is vital for personalized communication and relationship management within the CRM. It should include both first and last names, and be kept up-to-date to reflect any changes in contact personnel.
   */
  contactName?: string | null | undefined;
  /**
   * The salutation or title used for the contact person at the address, such as Mr., Ms., Dr., etc. This field enhances formal communication and is important for maintaining professional etiquette in correspondence. It should be chosen based on the contact's preference and cultural norms.
   */
  salutation?: string | null | undefined;
  /**
   * The primary phone number associated with the address, used for direct communication with the contact person. This number should be formatted according to international standards to ensure it can be dialed from any location. It is essential for timely and effective communication, especially in customer service scenarios.
   */
  phoneNumber?: string | null | undefined;
  /**
   * The fax number associated with the user's address. This field allows for the inclusion of traditional communication methods, which may be necessary for certain business transactions or legal documentation. While not commonly used in modern digital communications, maintaining a fax number can be crucial for businesses that still rely on this method. Ensure the number is formatted correctly to avoid transmission errors.
   */
  fax?: string | null | undefined;
  /**
   * The email address linked to the user's address, serving as a primary mode of digital communication. This field is essential for sending notifications, updates, and other important information directly to the user. It should be a valid email format to ensure successful delivery and communication. Keeping this information up-to-date is vital for maintaining effective contact with the user.
   */
  email?: string | null | undefined;
  /**
   * The website URL associated with the user's address, providing a digital point of reference or contact. This can be used to direct users to a personal or business website, offering more information or services. Ensure the URL is complete and correctly formatted to facilitate seamless access. This field supports the user's digital presence and connectivity.
   */
  website?: string | null | undefined;
  /**
   * Additional notes related to the user's address, offering space for any extra information that might be relevant but does not fit into other predefined fields. This could include special delivery instructions, historical data, or personal preferences. These notes can be crucial for personalized service and ensuring all relevant details are captured.
   */
  notes?: string | null | undefined;
  /**
   * A binary value used to track changes to the user's address object, ensuring data integrity and preventing update conflicts. This field is automatically incremented with each update, allowing the system to detect concurrent modifications and manage them appropriately. It is crucial for maintaining accurate and consistent data across the CRM system, especially in environments with multiple users accessing the same records.
   */
  rowVersion?: string | null | undefined;
};

export type ContactGetResponseSocialLinks = {
  /**
   * A unique identifier for each social link entry within the array. This ID is used to distinguish between different social media profiles associated with the lead, ensuring that each link can be individually referenced and managed. It is essential for operations that involve updating or removing specific social links without affecting others.
   */
  id?: string | null | undefined;
  /**
   * The complete URL of the social media profile associated with the lead. This field is required and must be a valid URL format, such as 'https://www.twitter.com/apideck'. It provides direct access to the lead's social media presence, enabling CRM users to quickly view and interact with the lead's profiles. Accurate URLs are vital for maintaining effective communication and engagement strategies.
   */
  url: string;
  /**
   * Specifies the type of social media link associated with the lead, such as Twitter, LinkedIn, or Facebook. This field helps categorize and manage the lead's social media presence within the CRM, allowing for targeted communication strategies. It is optional but recommended for leads with active social media profiles to enhance engagement tracking.
   */
  type?: string | null | undefined;
};

/**
 * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
 */
export const ContactGetResponseDataPhoneNumbersType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Work: "work",
  Office: "office",
  Mobile: "mobile",
  Assistant: "assistant",
  Fax: "fax",
  DirectDialIn: "direct-dial-in",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
 */
export type ContactGetResponseDataPhoneNumbersType = ClosedEnum<
  typeof ContactGetResponseDataPhoneNumbersType
>;

export type ContactGetResponsePhoneNumbers = {
  /**
   * A unique identifier for each phone number entry within the user's phone numbers array. This ID is crucial for distinguishing between different phone numbers, especially when updating or deleting specific numbers. It ensures that operations are performed on the correct phone number entry, maintaining data integrity within the user's contact information.
   */
  id?: string | null | undefined;
  /**
   * The international dialing code associated with the phone number, such as '+1' for the United States. This field is essential for ensuring that phone numbers are formatted correctly for international dialing and can be used to validate the geographical origin of the number. It helps in standardizing phone numbers across different regions and is critical for applications that involve international communication.
   */
  countryCode?: string | null | undefined;
  /**
   * The regional area code that precedes the local phone number, such as '323' for parts of Los Angeles. This code is important for routing calls within specific geographic areas and is a key component of the full phone number. Including the area code ensures that the phone number is complete and can be dialed correctly from both local and international locations.
   */
  areaCode?: string | null | undefined;
  /**
   * The main part of the phone number, excluding the country and area codes. This field is required as it represents the actual number that will be dialed within the specified area and country codes. It is the core component of the user's contact information and must be accurate to ensure successful communication. This field is mandatory to ensure that there is a valid number associated with the user.
   */
  number: string;
  /**
   * The extension of the phone number, typically used in corporate environments to direct calls to specific departments or employees. This field is optional and should be used when the phone number is part of a larger system, such as a PBX, where extensions are necessary for routing calls internally. Including an extension ensures that calls reach the intended recipient without delay.
   */
  extension?: string | null | undefined;
  /**
   * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
   */
  type?: ContactGetResponseDataPhoneNumbersType | null | undefined;
};

/**
 * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
 */
export const ContactGetResponseDataEmailsType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
 */
export type ContactGetResponseDataEmailsType = ClosedEnum<
  typeof ContactGetResponseDataEmailsType
>;

export type ContactGetResponseEmails = {
  /**
   * A unique identifier for each email address within the user's email collection. This ID is used to distinguish between multiple email addresses associated with a single user, allowing for precise updates and management of contact information. It is optional but can be useful for operations that require specific email targeting.
   */
  id?: string | null | undefined;
  /**
   * The actual email address used for electronic communication with the user. This field is required and must be a valid email format to ensure successful delivery of messages. It serves as a primary contact method and is essential for user engagement and CRM operations.
   */
  email: string | null;
  /**
   * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
   */
  type?: ContactGetResponseDataEmailsType | null | undefined;
};

export type ContactGetResponseValue6 = {};

export type ContactGetResponseValue4 = {};

/**
 * The value assigned to a custom field within the opportunity record. Custom fields allow for additional, user-defined data to be stored, providing flexibility to tailor the CRM to specific business needs. This field is optional and can be used to capture unique attributes or metrics relevant to the opportunity that are not covered by standard fields.
 */
export type ContactGetResponseValue =
  | ContactGetResponseValue4
  | string
  | number
  | boolean
  | Array<string>
  | Array<ContactGetResponseValue6>;

export type ContactGetResponseCustomFields = {
  /**
   * Unique identifier for the custom field. This ID is essential for distinguishing each custom field within the opportunity's data structure. It ensures that each field can be individually accessed, updated, or removed as needed. The ID must be unique within the context of the opportunity to prevent data conflicts and maintain data integrity.
   */
  id: string | null;
  /**
   * Name of the custom field. This name serves as a label for the custom field, providing a human-readable identifier that describes the field's purpose or content. While not required, including a name can improve clarity and usability, especially when multiple custom fields are present. It should be concise yet descriptive enough to convey the field's role in the opportunity's data.
   */
  name?: string | null | undefined;
  /**
   * More information about the custom field. This description offers additional context or details about the custom field's intended use or significance. It can include guidelines on what type of data should be entered or how the field relates to the overall sales process. Providing a description is optional but can enhance understanding and proper utilization of the custom field by users.
   */
  description?: string | null | undefined;
  /**
   * The value assigned to a custom field within the opportunity record. Custom fields allow for additional, user-defined data to be stored, providing flexibility to tailor the CRM to specific business needs. This field is optional and can be used to capture unique attributes or metrics relevant to the opportunity that are not covered by standard fields.
   */
  value?:
    | ContactGetResponseValue4
    | string
    | number
    | boolean
    | Array<string>
    | Array<ContactGetResponseValue6>
    | null
    | undefined;
};

/**
 * This object contains any custom mappings that have been configured for the contact resource. Custom mappings allow for the adaptation of the contact data to fit specific business needs or third-party integrations. They are particularly useful when integrating with multiple CRM systems or when specific fields need to be aligned with external data structures. This property is optional and will only be included if custom mappings are set up for the contact.
 */
export type ContactGetResponseCustomMappings = {};

export type ContactGetResponseExtendPaths = {
  /**
   * A JSONPath string that specifies the exact location within the user record where the value should be applied. This is essential for making precise updates to nested fields, ensuring that changes are made only to the intended parts of the data structure. The path must be valid and correspond to an existing field within the user record.
   */
  path: string;
  /**
   * This property represents the specific value that you wish to assign to a designated path within the user record. It can be of any data type, such as a string, number, boolean, or object, depending on the field being updated. The flexibility of this property allows for a wide range of updates, from simple text changes to complex data structures. In the context of the `usersUpdate` operation, this property is crucial for specifying the exact data modification you intend to make, ensuring that only the targeted fields are altered without affecting other data. Proper validation should be applied to ensure the value is compatible with the field's expected data type and business rules. Common use cases include updating user contact information, preferences, or custom attributes specific to your CRM's schema.
   */
  value?: any | undefined;
};

export type ContactGetResponsePassThrough = {
  /**
   * The unique identifier for the specific service to which this pass_through should be applied. This is crucial for directing the update operation to the correct service within the CRM system, ensuring that the modifications are executed in the appropriate context. It must be a valid service ID that corresponds to an active service integration, and it is required for the operation to proceed.
   */
  serviceId: string;
  /**
   * An optional identifier for a specific workflow operation within the CRM system to which this pass_through should be applied. This is particularly useful for Unify calls that involve multiple downstream requests, allowing for precise targeting and execution of specific operations. If provided, it should match an existing operation ID to ensure correct processing.
   */
  operationId?: string | undefined;
  /**
   * A flexible object that allows for the inclusion of any additional properties needed for direct extension of the user record. This can be used to add custom fields or metadata that are not part of the standard user schema, providing a way to tailor the user data to specific business needs. The structure of this object should align with the CRM's data model to ensure compatibility.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects designed for structured data modifications via specified paths. This allows for precise updates to nested data structures within the user record, enabling complex modifications without altering unrelated data. Each object in the array should define a clear path and value to be applied, ensuring targeted updates.
   */
  extendPaths?: Array<ContactGetResponseExtendPaths> | undefined;
};

/**
 * The main container object for all contact details retrieved from the CRM system. This object encapsulates all relevant information about the contact, including identifiers, names, and ownership details. It is always included in the response to provide a structured format for accessing contact-specific data.
 */
export type ContactGetResponseData = {
  /**
   * The unique identifier for the contact within the CRM system. This ID is automatically generated when a contact is created and is used to precisely locate and update the contact record. While not required for the update operation, providing it ensures that the correct contact is modified, especially in systems with large datasets. It is crucial for maintaining data integrity and avoiding accidental updates to the wrong contact.
   */
  id?: string | undefined;
  /**
   * The full name of the contact, which serves as a primary identifier within the CRM. This field is required for updates to ensure that the contact's identity is clear and unambiguous. It is used in various CRM functionalities, such as search and display, and should reflect the contact's preferred name format. Accurate naming helps in personalizing communication and maintaining professional relationships.
   */
  name: string | null;
  /**
   * The identifier for the user or entity that owns or manages the contact within the CRM. This field is optional but can be critical for assigning responsibility and tracking interactions with the contact. It helps in organizing contacts by ownership, which is useful for sales teams and account managers to manage their client portfolios effectively.
   */
  ownerId?: string | null | undefined;
  /**
   * The classification or category of the contact, such as 'customer', 'supplier', or 'partner'. This optional field helps in segmenting contacts for targeted communication and reporting. Understanding the type of contact can influence how interactions are prioritized and managed within the CRM system.
   */
  type?: ContactGetResponseType | null | undefined;
  /**
   * The unique identifier for the company with which the contact is associated. This optional field links the contact to a specific company record within the CRM, facilitating a comprehensive view of business relationships. It is particularly useful in B2B contexts where contacts are often tied to organizational accounts, aiding in the management of corporate interactions and history.
   */
  companyId?: string | null | undefined;
  /**
   * The name of the company the contact is associated with. This field is used to link the contact to their respective organization within the CRM. It is essential for organizing contacts under their business entities, facilitating better management and retrieval of contact information. While not mandatory, providing the company name enhances the context and relevance of the contact record, especially in business-to-business interactions.
   */
  companyName?: string | null | undefined;
  /**
   * The lead the contact is associated with. This identifier connects the contact to a specific lead record within the CRM, which is crucial for tracking the contact's journey from a potential lead to a customer. It helps in maintaining a seamless flow of information and ensures that all interactions with the contact are aligned with their lead status. Although optional, associating a contact with a lead can provide valuable insights into sales processes and customer engagement strategies.
   */
  leadId?: string | null | undefined;
  /**
   * The first name of the contact. This field is used to personalize communications and is a key component of the contact's identity within the CRM. It is important for ensuring accurate and respectful interactions, as well as for searching and filtering contacts. While not required, including the first name enhances the quality of customer relationship management by allowing for more personalized and effective communication.
   */
  firstName?: string | null | undefined;
  /**
   * The middle name of the contact. This optional field can be used to store additional name information that may be relevant for distinguishing between contacts with similar names or for formal documentation purposes. Including a middle name can enhance the accuracy of contact identification and is particularly useful in regions or cultures where middle names are commonly used.
   */
  middleName?: string | null | undefined;
  /**
   * The last name of the contact. This field is critical for identifying and organizing contacts within the CRM. It is often used in conjunction with the first name to ensure precise identification and is essential for sorting and searching contact records. While not mandatory, providing the last name significantly improves the system's ability to manage and retrieve contact information efficiently.
   */
  lastName?: string | null | undefined;
  /**
   * The prefix of the contact, such as Mr., Ms., Dr., etc. This field is used to address the contact formally and can enhance personalization in communications. It is optional and should be chosen based on the contact's preference or cultural norms.
   */
  prefix?: string | null | undefined;
  /**
   * The suffix of the contact, such as Jr., Sr., III, etc. This field helps in distinguishing between individuals with similar names within the CRM. It is optional and should be used when applicable to maintain accurate records.
   */
  suffix?: string | null | undefined;
  /**
   * The job title of the contact within their organization. This information is crucial for understanding the contact's role and responsibilities, aiding in targeted communication and relationship management. It is optional but recommended for business context.
   */
  title?: string | null | undefined;
  /**
   * The department within the organization where the contact works. This field helps in segmenting contacts based on their organizational role, facilitating more effective communication strategies. It is optional but useful for targeted outreach.
   */
  department?: string | null | undefined;
  /**
   * The preferred language of communication for the contact, specified using the ISO 639-1 code (e.g., 'EN' for English). This field ensures that communications are delivered in a language the contact understands, enhancing engagement and reducing misunderstandings. It is optional but highly recommended for international contacts.
   */
  language?: string | null | undefined;
  /**
   * Specifies the gender of the contact, which can be used for personalized communication and marketing strategies. Acceptable values typically include 'male', 'female', 'non-binary', or 'other'. This field is optional and should be used in accordance with privacy regulations and the contact's preferences.
   */
  gender?: ContactGetResponseGender | null | undefined;
  /**
   * The birth date of the contact, formatted as a string (e.g., 'YYYY-MM-DD'). This information can be utilized for sending personalized birthday messages or offers, enhancing customer engagement. Ensure the date is accurate to avoid miscommunication.
   */
  birthday?: string | null | undefined;
  /**
   * A string representing the image data or a reference to the contact's image. This field can be used to visually identify contacts within the CRM system, aiding in quick recognition and personalization. Ensure the image is appropriately formatted and stored securely.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  image?: string | null | undefined;
  /**
   * The URL linking to the contact's photo, which can be displayed in the CRM interface to help users quickly identify the contact. This should be a valid URL pointing to an accessible image file. It's important to ensure the URL remains up-to-date and the image is stored in a secure location.
   */
  photoUrl?: string | null | undefined;
  /**
   * Indicates the origin of the contact, such as 'web', 'referral', or 'advertisement'. Understanding the lead source helps in analyzing the effectiveness of different marketing channels and strategies. This field is optional but valuable for marketing analytics and strategy refinement.
   */
  leadSource?: string | null | undefined;
  /**
   * The fax number associated with the contact, used for sending and receiving documents via fax. This field is optional and should be formatted according to international dialing standards if applicable. Including a fax number can be beneficial for businesses that still rely on fax communication for official documentation or contracts.
   */
  fax?: string | null | undefined;
  /**
   * A detailed narrative or note about the contact, providing context or additional information that may be relevant for CRM users. This could include personal preferences, historical interactions, or any other pertinent details that help in personalizing communication or understanding the contact's background. This field is optional but can enhance the quality of customer relationship management by offering insights that are not captured by structured data fields.
   */
  description?: string | null | undefined;
  /**
   * The current financial balance associated with the contact, reflecting any outstanding amounts owed or credits available. This numeric field is crucial for financial tracking and management within the CRM, especially for contacts who are clients or vendors. It should be updated regularly to ensure accurate financial records and can be used to trigger alerts or actions if certain thresholds are met. This field is optional and should be formatted as a decimal number.
   */
  currentBalance?: number | null | undefined;
  /**
   * The current status of the contact within the CRM system, indicating their relationship or engagement level with the organization. Common statuses might include 'active', 'inactive', 'prospect', or 'customer'. This field helps in segmenting contacts for targeted marketing or follow-up actions and should be updated to reflect any changes in the contact's lifecycle. This field is optional but highly recommended for effective contact management.
   */
  status?: string | null | undefined;
  /**
   * A boolean flag indicating whether the contact is currently active within the CRM system. An active status typically means the contact is engaged or available for communication and transactions. This field is crucial for filtering contacts in reports and ensuring that communications are directed only to those who are currently relevant. Setting this field to 'false' can help in cleaning up the database by deactivating contacts that are no longer needed. This field is optional but important for maintaining an organized and efficient CRM.
   */
  active?: boolean | null | undefined;
  /**
   * A collection of website entries associated with the contact. This array can include multiple websites, each represented as an object with specific attributes such as URL and type. Useful for storing all relevant online presences of the contact, enhancing the contact's profile with comprehensive digital footprint information.
   */
  websites?: Array<ContactGetResponseWebsites> | undefined;
  /**
   * An array containing address entries related to the contact. Each entry can include details such as street, city, and postal code. This array allows for the inclusion of multiple addresses, supporting scenarios where a contact may have several locations, such as home and work addresses. It enriches the contact's profile by providing geographical context.
   */
  addresses?: Array<ContactGetResponseAddresses> | undefined;
  /**
   * An array of social media links associated with the contact. This field allows for the inclusion of various social media profiles, such as LinkedIn, Twitter, or Facebook, providing a comprehensive view of the contact's online presence. While optional, these links can be valuable for networking and understanding the contact's professional and personal interests, enhancing engagement strategies.
   */
  socialLinks?: Array<ContactGetResponseSocialLinks> | undefined;
  /**
   * An array containing one or more phone number objects associated with the contact. Each object within the array can hold detailed information about a specific phone number, such as type and ID. This structure allows for the inclusion of multiple contact numbers, facilitating comprehensive communication options for the contact.
   */
  phoneNumbers?: Array<ContactGetResponsePhoneNumbers> | undefined;
  /**
   * An array of email objects associated with the contact. Each object within this array represents a distinct email address linked to the contact, allowing for multiple email addresses to be stored and managed. This is particularly useful for contacts who use different emails for various purposes, such as personal and professional communication. The array can be updated to add, remove, or modify email addresses as needed, ensuring the contact's email information is current and comprehensive.
   */
  emails?: Array<ContactGetResponseEmails> | undefined;
  /**
   * The domain part of the contact's primary email address, extracted for analytical or organizational purposes. This field can be used to group contacts by their email domains, which is useful for domain-specific marketing campaigns or understanding the distribution of contacts across different email providers. It is not required but can provide additional insights into the contact's email usage.
   */
  emailDomain?: string | null | undefined;
  /**
   * An array of custom fields associated with the contact record. Each entry in this array represents a specific custom field that can be used to store additional information not covered by standard fields. This allows for greater flexibility and customization of contact records to meet specific business needs. Custom fields can include data such as preferences, additional contact methods, or any other relevant information that enhances the contact profile.
   */
  customFields?: Array<ContactGetResponseCustomFields> | undefined;
  /**
   * An array of tags associated with the contact, used to categorize and filter contacts within the CRM system. Tags can represent various attributes or statuses, such as 'VIP', 'Lead', or 'Prospect', and help in organizing contacts for targeted marketing or communication strategies. This field is optional and can be updated to reflect changes in the contact's status or classification.
   */
  tags?: Array<string> | null | undefined;
  /**
   * The date and time when the first call was made to or received from the contact, formatted as an ISO 8601 string. This information is crucial for tracking the initial point of voice communication with the contact, providing insights into the contact's engagement history. It helps in understanding the timeline of interactions and planning follow-up activities.
   */
  firstCallAt?: Date | null | undefined;
  /**
   * The date and time when the first email was sent to or received from the contact, formatted as an ISO 8601 string. This field is important for documenting the initial email interaction, which can be pivotal in establishing communication history and assessing the contact's responsiveness. It aids in strategizing future email campaigns and follow-ups.
   */
  firstEmailAt?: Date | null | undefined;
  /**
   * The date and time of the most recent interaction with the contact, formatted as an ISO 8601 string. This field is essential for monitoring ongoing engagement and determining the recency of contact activities. It helps in prioritizing contacts for follow-up actions and maintaining up-to-date records of contact interactions.
   */
  lastActivityAt?: Date | null | undefined;
  /**
   * This object contains any custom mappings that have been configured for the contact resource. Custom mappings allow for the adaptation of the contact data to fit specific business needs or third-party integrations. They are particularly useful when integrating with multiple CRM systems or when specific fields need to be aligned with external data structures. This property is optional and will only be included if custom mappings are set up for the contact.
   */
  customMappings?: ContactGetResponseCustomMappings | null | undefined;
  /**
   * A timestamp indicating the last time the contact record was updated. This field is crucial for tracking changes and ensuring data consistency across systems. It follows the ISO 8601 format (e.g., '2023-10-01T12:00:00Z') and is automatically managed by the system. This property is optional but provides valuable information for audit trails and synchronization processes.
   */
  updatedAt?: Date | null | undefined;
  /**
   * A timestamp representing when the contact record was initially created in the CRM. This field is important for historical data analysis and understanding the lifecycle of a contact. It uses the ISO 8601 format (e.g., '2023-10-01T12:00:00Z') and is set automatically at the time of creation. While optional, it is essential for maintaining accurate records of contact inception dates.
   */
  createdAt?: Date | null | undefined;
  /**
   * An array containing the unique identifiers of opportunities associated with the contact. This linkage is vital for understanding the contact's involvement in various sales or business opportunities. Each ID in the array corresponds to a specific opportunity record in the CRM. This property is optional but can be used to enhance the contact's profile with related business engagements.
   */
  opportunityIds?: Array<string> | undefined;
  /**
   * The `pass_through` property is an array that allows you to include service-specific custom data or structured modifications directly within the request body when updating contact resources. This feature is particularly useful for integrating unique business logic or additional data fields that are not natively supported by the CRM system. By leveraging `pass_through`, you can ensure that all necessary information is transmitted to the appropriate service, enhancing the flexibility and adaptability of the update operation. It is important to structure this data correctly to align with the service's requirements, ensuring seamless integration and operation.
   */
  passThrough?: Array<ContactGetResponsePassThrough> | undefined;
};

/**
 * Contact
 */
export type ContactGetResponse = {
  /**
   * The HTTP response status code indicating the result of the API request. This integer value provides insight into whether the request was successful (e.g., 200 for success) or if there was an error (e.g., 404 for not found). It is always included in the response to help developers understand the outcome of their API call.
   */
  statusCode: number;
  /**
   * A textual representation of the HTTP response status. This string provides a human-readable explanation of the status code, such as 'OK' for a successful request or 'Not Found' for a failed one. It complements the status code by offering a more descriptive context and is always included in the response.
   */
  status: string;
  /**
   * The Apideck ID of the service provider that processed the request. This string identifies which service within the Apideck ecosystem handled the API call, such as 'pipedrive' or another integrated service. It is crucial for understanding the source of the data and is always included in the response.
   */
  service: string;
  /**
   * The name of the Unified API resource that was accessed. This string indicates the specific resource type, such as 'contact', that the operation was performed on. It helps in identifying the context of the data retrieved and is always included in the response.
   */
  resource: string;
  /**
   * The specific operation that was performed during the API request. This string describes the action taken, such as 'retrieve' or 'update', and provides clarity on what the API call was intended to do. It is always included to ensure transparency about the operation executed.
   */
  operation: string;
  /**
   * The main container object for all contact details retrieved from the CRM system. This object encapsulates all relevant information about the contact, including identifiers, names, and ownership details. It is always included in the response to provide a structured format for accessing contact-specific data.
   */
  data: ContactGetResponseData;
};

/** @internal */
export const ContactGetResponseType$inboundSchema: z.ZodNativeEnum<
  typeof ContactGetResponseType
> = z.nativeEnum(ContactGetResponseType);

/** @internal */
export const ContactGetResponseType$outboundSchema: z.ZodNativeEnum<
  typeof ContactGetResponseType
> = ContactGetResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseType$ {
  /** @deprecated use `ContactGetResponseType$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseType$inboundSchema;
  /** @deprecated use `ContactGetResponseType$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseType$outboundSchema;
}

/** @internal */
export const ContactGetResponseGender$inboundSchema: z.ZodNativeEnum<
  typeof ContactGetResponseGender
> = z.nativeEnum(ContactGetResponseGender);

/** @internal */
export const ContactGetResponseGender$outboundSchema: z.ZodNativeEnum<
  typeof ContactGetResponseGender
> = ContactGetResponseGender$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseGender$ {
  /** @deprecated use `ContactGetResponseGender$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseGender$inboundSchema;
  /** @deprecated use `ContactGetResponseGender$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseGender$outboundSchema;
}

/** @internal */
export const ContactGetResponseDataType$inboundSchema: z.ZodNativeEnum<
  typeof ContactGetResponseDataType
> = z.nativeEnum(ContactGetResponseDataType);

/** @internal */
export const ContactGetResponseDataType$outboundSchema: z.ZodNativeEnum<
  typeof ContactGetResponseDataType
> = ContactGetResponseDataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseDataType$ {
  /** @deprecated use `ContactGetResponseDataType$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseDataType$inboundSchema;
  /** @deprecated use `ContactGetResponseDataType$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseDataType$outboundSchema;
}

/** @internal */
export const ContactGetResponseWebsites$inboundSchema: z.ZodType<
  ContactGetResponseWebsites,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(ContactGetResponseDataType$inboundSchema).optional(),
});

/** @internal */
export type ContactGetResponseWebsites$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const ContactGetResponseWebsites$outboundSchema: z.ZodType<
  ContactGetResponseWebsites$Outbound,
  z.ZodTypeDef,
  ContactGetResponseWebsites
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(ContactGetResponseDataType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseWebsites$ {
  /** @deprecated use `ContactGetResponseWebsites$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseWebsites$inboundSchema;
  /** @deprecated use `ContactGetResponseWebsites$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseWebsites$outboundSchema;
  /** @deprecated use `ContactGetResponseWebsites$Outbound` instead. */
  export type Outbound = ContactGetResponseWebsites$Outbound;
}

export function contactGetResponseWebsitesToJSON(
  contactGetResponseWebsites: ContactGetResponseWebsites,
): string {
  return JSON.stringify(
    ContactGetResponseWebsites$outboundSchema.parse(contactGetResponseWebsites),
  );
}

export function contactGetResponseWebsitesFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseWebsites, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseWebsites$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseWebsites' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseDataAddressesType$inboundSchema: z.ZodNativeEnum<
  typeof ContactGetResponseDataAddressesType
> = z.nativeEnum(ContactGetResponseDataAddressesType);

/** @internal */
export const ContactGetResponseDataAddressesType$outboundSchema:
  z.ZodNativeEnum<typeof ContactGetResponseDataAddressesType> =
    ContactGetResponseDataAddressesType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseDataAddressesType$ {
  /** @deprecated use `ContactGetResponseDataAddressesType$inboundSchema` instead. */
  export const inboundSchema =
    ContactGetResponseDataAddressesType$inboundSchema;
  /** @deprecated use `ContactGetResponseDataAddressesType$outboundSchema` instead. */
  export const outboundSchema =
    ContactGetResponseDataAddressesType$outboundSchema;
}

/** @internal */
export const ContactGetResponseAddresses$inboundSchema: z.ZodType<
  ContactGetResponseAddresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(ContactGetResponseDataAddressesType$inboundSchema)
    .optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  street_number: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postal_code: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contact_name: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phone_number: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  row_version: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "street_number": "streetNumber",
    "postal_code": "postalCode",
    "contact_name": "contactName",
    "phone_number": "phoneNumber",
    "row_version": "rowVersion",
  });
});

/** @internal */
export type ContactGetResponseAddresses$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
  string?: string | null | undefined;
  name?: string | null | undefined;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  line3?: string | null | undefined;
  line4?: string | null | undefined;
  street_number?: string | null | undefined;
  city?: string | null | undefined;
  state?: string | null | undefined;
  postal_code?: string | null | undefined;
  country?: string | null | undefined;
  latitude?: string | null | undefined;
  longitude?: string | null | undefined;
  county?: string | null | undefined;
  contact_name?: string | null | undefined;
  salutation?: string | null | undefined;
  phone_number?: string | null | undefined;
  fax?: string | null | undefined;
  email?: string | null | undefined;
  website?: string | null | undefined;
  notes?: string | null | undefined;
  row_version?: string | null | undefined;
};

/** @internal */
export const ContactGetResponseAddresses$outboundSchema: z.ZodType<
  ContactGetResponseAddresses$Outbound,
  z.ZodTypeDef,
  ContactGetResponseAddresses
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(ContactGetResponseDataAddressesType$outboundSchema)
    .optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  streetNumber: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contactName: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phoneNumber: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  rowVersion: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    streetNumber: "street_number",
    postalCode: "postal_code",
    contactName: "contact_name",
    phoneNumber: "phone_number",
    rowVersion: "row_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseAddresses$ {
  /** @deprecated use `ContactGetResponseAddresses$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseAddresses$inboundSchema;
  /** @deprecated use `ContactGetResponseAddresses$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseAddresses$outboundSchema;
  /** @deprecated use `ContactGetResponseAddresses$Outbound` instead. */
  export type Outbound = ContactGetResponseAddresses$Outbound;
}

export function contactGetResponseAddressesToJSON(
  contactGetResponseAddresses: ContactGetResponseAddresses,
): string {
  return JSON.stringify(
    ContactGetResponseAddresses$outboundSchema.parse(
      contactGetResponseAddresses,
    ),
  );
}

export function contactGetResponseAddressesFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseAddresses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseAddresses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseAddresses' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseSocialLinks$inboundSchema: z.ZodType<
  ContactGetResponseSocialLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/** @internal */
export type ContactGetResponseSocialLinks$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const ContactGetResponseSocialLinks$outboundSchema: z.ZodType<
  ContactGetResponseSocialLinks$Outbound,
  z.ZodTypeDef,
  ContactGetResponseSocialLinks
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseSocialLinks$ {
  /** @deprecated use `ContactGetResponseSocialLinks$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseSocialLinks$inboundSchema;
  /** @deprecated use `ContactGetResponseSocialLinks$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseSocialLinks$outboundSchema;
  /** @deprecated use `ContactGetResponseSocialLinks$Outbound` instead. */
  export type Outbound = ContactGetResponseSocialLinks$Outbound;
}

export function contactGetResponseSocialLinksToJSON(
  contactGetResponseSocialLinks: ContactGetResponseSocialLinks,
): string {
  return JSON.stringify(
    ContactGetResponseSocialLinks$outboundSchema.parse(
      contactGetResponseSocialLinks,
    ),
  );
}

export function contactGetResponseSocialLinksFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseSocialLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseSocialLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseSocialLinks' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseDataPhoneNumbersType$inboundSchema:
  z.ZodNativeEnum<typeof ContactGetResponseDataPhoneNumbersType> = z.nativeEnum(
    ContactGetResponseDataPhoneNumbersType,
  );

/** @internal */
export const ContactGetResponseDataPhoneNumbersType$outboundSchema:
  z.ZodNativeEnum<typeof ContactGetResponseDataPhoneNumbersType> =
    ContactGetResponseDataPhoneNumbersType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseDataPhoneNumbersType$ {
  /** @deprecated use `ContactGetResponseDataPhoneNumbersType$inboundSchema` instead. */
  export const inboundSchema =
    ContactGetResponseDataPhoneNumbersType$inboundSchema;
  /** @deprecated use `ContactGetResponseDataPhoneNumbersType$outboundSchema` instead. */
  export const outboundSchema =
    ContactGetResponseDataPhoneNumbersType$outboundSchema;
}

/** @internal */
export const ContactGetResponsePhoneNumbers$inboundSchema: z.ZodType<
  ContactGetResponsePhoneNumbers,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  country_code: z.nullable(z.string()).optional(),
  area_code: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(ContactGetResponseDataPhoneNumbersType$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "country_code": "countryCode",
    "area_code": "areaCode",
  });
});

/** @internal */
export type ContactGetResponsePhoneNumbers$Outbound = {
  id?: string | null | undefined;
  country_code?: string | null | undefined;
  area_code?: string | null | undefined;
  number: string;
  extension?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const ContactGetResponsePhoneNumbers$outboundSchema: z.ZodType<
  ContactGetResponsePhoneNumbers$Outbound,
  z.ZodTypeDef,
  ContactGetResponsePhoneNumbers
> = z.object({
  id: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  areaCode: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(ContactGetResponseDataPhoneNumbersType$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    countryCode: "country_code",
    areaCode: "area_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponsePhoneNumbers$ {
  /** @deprecated use `ContactGetResponsePhoneNumbers$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponsePhoneNumbers$inboundSchema;
  /** @deprecated use `ContactGetResponsePhoneNumbers$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponsePhoneNumbers$outboundSchema;
  /** @deprecated use `ContactGetResponsePhoneNumbers$Outbound` instead. */
  export type Outbound = ContactGetResponsePhoneNumbers$Outbound;
}

export function contactGetResponsePhoneNumbersToJSON(
  contactGetResponsePhoneNumbers: ContactGetResponsePhoneNumbers,
): string {
  return JSON.stringify(
    ContactGetResponsePhoneNumbers$outboundSchema.parse(
      contactGetResponsePhoneNumbers,
    ),
  );
}

export function contactGetResponsePhoneNumbersFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponsePhoneNumbers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponsePhoneNumbers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponsePhoneNumbers' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseDataEmailsType$inboundSchema: z.ZodNativeEnum<
  typeof ContactGetResponseDataEmailsType
> = z.nativeEnum(ContactGetResponseDataEmailsType);

/** @internal */
export const ContactGetResponseDataEmailsType$outboundSchema: z.ZodNativeEnum<
  typeof ContactGetResponseDataEmailsType
> = ContactGetResponseDataEmailsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseDataEmailsType$ {
  /** @deprecated use `ContactGetResponseDataEmailsType$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseDataEmailsType$inboundSchema;
  /** @deprecated use `ContactGetResponseDataEmailsType$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseDataEmailsType$outboundSchema;
}

/** @internal */
export const ContactGetResponseEmails$inboundSchema: z.ZodType<
  ContactGetResponseEmails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(ContactGetResponseDataEmailsType$inboundSchema).optional(),
});

/** @internal */
export type ContactGetResponseEmails$Outbound = {
  id?: string | null | undefined;
  email: string | null;
  type?: string | null | undefined;
};

/** @internal */
export const ContactGetResponseEmails$outboundSchema: z.ZodType<
  ContactGetResponseEmails$Outbound,
  z.ZodTypeDef,
  ContactGetResponseEmails
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(ContactGetResponseDataEmailsType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseEmails$ {
  /** @deprecated use `ContactGetResponseEmails$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseEmails$inboundSchema;
  /** @deprecated use `ContactGetResponseEmails$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseEmails$outboundSchema;
  /** @deprecated use `ContactGetResponseEmails$Outbound` instead. */
  export type Outbound = ContactGetResponseEmails$Outbound;
}

export function contactGetResponseEmailsToJSON(
  contactGetResponseEmails: ContactGetResponseEmails,
): string {
  return JSON.stringify(
    ContactGetResponseEmails$outboundSchema.parse(contactGetResponseEmails),
  );
}

export function contactGetResponseEmailsFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseEmails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseEmails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseEmails' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseValue6$inboundSchema: z.ZodType<
  ContactGetResponseValue6,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ContactGetResponseValue6$Outbound = {};

/** @internal */
export const ContactGetResponseValue6$outboundSchema: z.ZodType<
  ContactGetResponseValue6$Outbound,
  z.ZodTypeDef,
  ContactGetResponseValue6
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseValue6$ {
  /** @deprecated use `ContactGetResponseValue6$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseValue6$inboundSchema;
  /** @deprecated use `ContactGetResponseValue6$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseValue6$outboundSchema;
  /** @deprecated use `ContactGetResponseValue6$Outbound` instead. */
  export type Outbound = ContactGetResponseValue6$Outbound;
}

export function contactGetResponseValue6ToJSON(
  contactGetResponseValue6: ContactGetResponseValue6,
): string {
  return JSON.stringify(
    ContactGetResponseValue6$outboundSchema.parse(contactGetResponseValue6),
  );
}

export function contactGetResponseValue6FromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseValue6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseValue6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseValue6' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseValue4$inboundSchema: z.ZodType<
  ContactGetResponseValue4,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ContactGetResponseValue4$Outbound = {};

/** @internal */
export const ContactGetResponseValue4$outboundSchema: z.ZodType<
  ContactGetResponseValue4$Outbound,
  z.ZodTypeDef,
  ContactGetResponseValue4
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseValue4$ {
  /** @deprecated use `ContactGetResponseValue4$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseValue4$inboundSchema;
  /** @deprecated use `ContactGetResponseValue4$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseValue4$outboundSchema;
  /** @deprecated use `ContactGetResponseValue4$Outbound` instead. */
  export type Outbound = ContactGetResponseValue4$Outbound;
}

export function contactGetResponseValue4ToJSON(
  contactGetResponseValue4: ContactGetResponseValue4,
): string {
  return JSON.stringify(
    ContactGetResponseValue4$outboundSchema.parse(contactGetResponseValue4),
  );
}

export function contactGetResponseValue4FromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseValue4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseValue4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseValue4' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseValue$inboundSchema: z.ZodType<
  ContactGetResponseValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ContactGetResponseValue4$inboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
  z.array(z.string()),
  z.array(z.lazy(() => ContactGetResponseValue6$inboundSchema)),
]);

/** @internal */
export type ContactGetResponseValue$Outbound =
  | ContactGetResponseValue4$Outbound
  | string
  | number
  | boolean
  | Array<string>
  | Array<ContactGetResponseValue6$Outbound>;

/** @internal */
export const ContactGetResponseValue$outboundSchema: z.ZodType<
  ContactGetResponseValue$Outbound,
  z.ZodTypeDef,
  ContactGetResponseValue
> = z.union([
  z.lazy(() => ContactGetResponseValue4$outboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
  z.array(z.string()),
  z.array(z.lazy(() => ContactGetResponseValue6$outboundSchema)),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseValue$ {
  /** @deprecated use `ContactGetResponseValue$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseValue$inboundSchema;
  /** @deprecated use `ContactGetResponseValue$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseValue$outboundSchema;
  /** @deprecated use `ContactGetResponseValue$Outbound` instead. */
  export type Outbound = ContactGetResponseValue$Outbound;
}

export function contactGetResponseValueToJSON(
  contactGetResponseValue: ContactGetResponseValue,
): string {
  return JSON.stringify(
    ContactGetResponseValue$outboundSchema.parse(contactGetResponseValue),
  );
}

export function contactGetResponseValueFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseValue' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseCustomFields$inboundSchema: z.ZodType<
  ContactGetResponseCustomFields,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => ContactGetResponseValue4$inboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => ContactGetResponseValue6$inboundSchema)),
    ]),
  ).optional(),
});

/** @internal */
export type ContactGetResponseCustomFields$Outbound = {
  id: string | null;
  name?: string | null | undefined;
  description?: string | null | undefined;
  value?:
    | ContactGetResponseValue4$Outbound
    | string
    | number
    | boolean
    | Array<string>
    | Array<ContactGetResponseValue6$Outbound>
    | null
    | undefined;
};

/** @internal */
export const ContactGetResponseCustomFields$outboundSchema: z.ZodType<
  ContactGetResponseCustomFields$Outbound,
  z.ZodTypeDef,
  ContactGetResponseCustomFields
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => ContactGetResponseValue4$outboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => ContactGetResponseValue6$outboundSchema)),
    ]),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseCustomFields$ {
  /** @deprecated use `ContactGetResponseCustomFields$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseCustomFields$inboundSchema;
  /** @deprecated use `ContactGetResponseCustomFields$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseCustomFields$outboundSchema;
  /** @deprecated use `ContactGetResponseCustomFields$Outbound` instead. */
  export type Outbound = ContactGetResponseCustomFields$Outbound;
}

export function contactGetResponseCustomFieldsToJSON(
  contactGetResponseCustomFields: ContactGetResponseCustomFields,
): string {
  return JSON.stringify(
    ContactGetResponseCustomFields$outboundSchema.parse(
      contactGetResponseCustomFields,
    ),
  );
}

export function contactGetResponseCustomFieldsFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseCustomFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseCustomFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseCustomFields' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseCustomMappings$inboundSchema: z.ZodType<
  ContactGetResponseCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ContactGetResponseCustomMappings$Outbound = {};

/** @internal */
export const ContactGetResponseCustomMappings$outboundSchema: z.ZodType<
  ContactGetResponseCustomMappings$Outbound,
  z.ZodTypeDef,
  ContactGetResponseCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseCustomMappings$ {
  /** @deprecated use `ContactGetResponseCustomMappings$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseCustomMappings$inboundSchema;
  /** @deprecated use `ContactGetResponseCustomMappings$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseCustomMappings$outboundSchema;
  /** @deprecated use `ContactGetResponseCustomMappings$Outbound` instead. */
  export type Outbound = ContactGetResponseCustomMappings$Outbound;
}

export function contactGetResponseCustomMappingsToJSON(
  contactGetResponseCustomMappings: ContactGetResponseCustomMappings,
): string {
  return JSON.stringify(
    ContactGetResponseCustomMappings$outboundSchema.parse(
      contactGetResponseCustomMappings,
    ),
  );
}

export function contactGetResponseCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseCustomMappings' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseExtendPaths$inboundSchema: z.ZodType<
  ContactGetResponseExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type ContactGetResponseExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const ContactGetResponseExtendPaths$outboundSchema: z.ZodType<
  ContactGetResponseExtendPaths$Outbound,
  z.ZodTypeDef,
  ContactGetResponseExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseExtendPaths$ {
  /** @deprecated use `ContactGetResponseExtendPaths$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseExtendPaths$inboundSchema;
  /** @deprecated use `ContactGetResponseExtendPaths$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseExtendPaths$outboundSchema;
  /** @deprecated use `ContactGetResponseExtendPaths$Outbound` instead. */
  export type Outbound = ContactGetResponseExtendPaths$Outbound;
}

export function contactGetResponseExtendPathsToJSON(
  contactGetResponseExtendPaths: ContactGetResponseExtendPaths,
): string {
  return JSON.stringify(
    ContactGetResponseExtendPaths$outboundSchema.parse(
      contactGetResponseExtendPaths,
    ),
  );
}

export function contactGetResponseExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseExtendPaths' from JSON`,
  );
}

/** @internal */
export const ContactGetResponsePassThrough$inboundSchema: z.ZodType<
  ContactGetResponsePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => ContactGetResponseExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type ContactGetResponsePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<ContactGetResponseExtendPaths$Outbound> | undefined;
};

/** @internal */
export const ContactGetResponsePassThrough$outboundSchema: z.ZodType<
  ContactGetResponsePassThrough$Outbound,
  z.ZodTypeDef,
  ContactGetResponsePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => ContactGetResponseExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponsePassThrough$ {
  /** @deprecated use `ContactGetResponsePassThrough$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponsePassThrough$inboundSchema;
  /** @deprecated use `ContactGetResponsePassThrough$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponsePassThrough$outboundSchema;
  /** @deprecated use `ContactGetResponsePassThrough$Outbound` instead. */
  export type Outbound = ContactGetResponsePassThrough$Outbound;
}

export function contactGetResponsePassThroughToJSON(
  contactGetResponsePassThrough: ContactGetResponsePassThrough,
): string {
  return JSON.stringify(
    ContactGetResponsePassThrough$outboundSchema.parse(
      contactGetResponsePassThrough,
    ),
  );
}

export function contactGetResponsePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponsePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponsePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponsePassThrough' from JSON`,
  );
}

/** @internal */
export const ContactGetResponseData$inboundSchema: z.ZodType<
  ContactGetResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  name: z.nullable(z.string()),
  owner_id: z.nullable(z.string()).optional(),
  type: z.nullable(ContactGetResponseType$inboundSchema).optional(),
  company_id: z.nullable(z.string()).optional(),
  company_name: z.nullable(z.string()).optional(),
  lead_id: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  middle_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  prefix: z.nullable(z.string()).optional(),
  suffix: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  gender: z.nullable(ContactGetResponseGender$inboundSchema).optional(),
  birthday: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  photo_url: z.nullable(z.string()).optional(),
  lead_source: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  current_balance: z.nullable(z.number()).optional(),
  status: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  websites: z.array(z.lazy(() => ContactGetResponseWebsites$inboundSchema))
    .optional(),
  addresses: z.array(z.lazy(() => ContactGetResponseAddresses$inboundSchema))
    .optional(),
  social_links: z.array(
    z.lazy(() => ContactGetResponseSocialLinks$inboundSchema),
  ).optional(),
  phone_numbers: z.array(
    z.lazy(() => ContactGetResponsePhoneNumbers$inboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => ContactGetResponseEmails$inboundSchema))
    .optional(),
  email_domain: z.nullable(z.string()).optional(),
  custom_fields: z.array(
    z.lazy(() => ContactGetResponseCustomFields$inboundSchema),
  ).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  first_call_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  first_email_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  last_activity_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  custom_mappings: z.nullable(
    z.lazy(() => ContactGetResponseCustomMappings$inboundSchema),
  ).optional(),
  updated_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  created_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  opportunity_ids: z.array(z.string()).optional(),
  pass_through: z.array(
    z.lazy(() => ContactGetResponsePassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "company_id": "companyId",
    "company_name": "companyName",
    "lead_id": "leadId",
    "first_name": "firstName",
    "middle_name": "middleName",
    "last_name": "lastName",
    "photo_url": "photoUrl",
    "lead_source": "leadSource",
    "current_balance": "currentBalance",
    "social_links": "socialLinks",
    "phone_numbers": "phoneNumbers",
    "email_domain": "emailDomain",
    "custom_fields": "customFields",
    "first_call_at": "firstCallAt",
    "first_email_at": "firstEmailAt",
    "last_activity_at": "lastActivityAt",
    "custom_mappings": "customMappings",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "opportunity_ids": "opportunityIds",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type ContactGetResponseData$Outbound = {
  id?: string | undefined;
  name: string | null;
  owner_id?: string | null | undefined;
  type?: string | null | undefined;
  company_id?: string | null | undefined;
  company_name?: string | null | undefined;
  lead_id?: string | null | undefined;
  first_name?: string | null | undefined;
  middle_name?: string | null | undefined;
  last_name?: string | null | undefined;
  prefix?: string | null | undefined;
  suffix?: string | null | undefined;
  title?: string | null | undefined;
  department?: string | null | undefined;
  language?: string | null | undefined;
  gender?: string | null | undefined;
  birthday?: string | null | undefined;
  image?: string | null | undefined;
  photo_url?: string | null | undefined;
  lead_source?: string | null | undefined;
  fax?: string | null | undefined;
  description?: string | null | undefined;
  current_balance?: number | null | undefined;
  status?: string | null | undefined;
  active?: boolean | null | undefined;
  websites?: Array<ContactGetResponseWebsites$Outbound> | undefined;
  addresses?: Array<ContactGetResponseAddresses$Outbound> | undefined;
  social_links?: Array<ContactGetResponseSocialLinks$Outbound> | undefined;
  phone_numbers?: Array<ContactGetResponsePhoneNumbers$Outbound> | undefined;
  emails?: Array<ContactGetResponseEmails$Outbound> | undefined;
  email_domain?: string | null | undefined;
  custom_fields?: Array<ContactGetResponseCustomFields$Outbound> | undefined;
  tags?: Array<string> | null | undefined;
  first_call_at?: string | null | undefined;
  first_email_at?: string | null | undefined;
  last_activity_at?: string | null | undefined;
  custom_mappings?:
    | ContactGetResponseCustomMappings$Outbound
    | null
    | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  opportunity_ids?: Array<string> | undefined;
  pass_through?: Array<ContactGetResponsePassThrough$Outbound> | undefined;
};

/** @internal */
export const ContactGetResponseData$outboundSchema: z.ZodType<
  ContactGetResponseData$Outbound,
  z.ZodTypeDef,
  ContactGetResponseData
> = z.object({
  id: z.string().optional(),
  name: z.nullable(z.string()),
  ownerId: z.nullable(z.string()).optional(),
  type: z.nullable(ContactGetResponseType$outboundSchema).optional(),
  companyId: z.nullable(z.string()).optional(),
  companyName: z.nullable(z.string()).optional(),
  leadId: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  middleName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  prefix: z.nullable(z.string()).optional(),
  suffix: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  gender: z.nullable(ContactGetResponseGender$outboundSchema).optional(),
  birthday: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  photoUrl: z.nullable(z.string()).optional(),
  leadSource: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  currentBalance: z.nullable(z.number()).optional(),
  status: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  websites: z.array(z.lazy(() => ContactGetResponseWebsites$outboundSchema))
    .optional(),
  addresses: z.array(z.lazy(() => ContactGetResponseAddresses$outboundSchema))
    .optional(),
  socialLinks: z.array(
    z.lazy(() => ContactGetResponseSocialLinks$outboundSchema),
  ).optional(),
  phoneNumbers: z.array(
    z.lazy(() => ContactGetResponsePhoneNumbers$outboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => ContactGetResponseEmails$outboundSchema))
    .optional(),
  emailDomain: z.nullable(z.string()).optional(),
  customFields: z.array(
    z.lazy(() => ContactGetResponseCustomFields$outboundSchema),
  ).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  firstCallAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  firstEmailAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  lastActivityAt: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  customMappings: z.nullable(
    z.lazy(() => ContactGetResponseCustomMappings$outboundSchema),
  ).optional(),
  updatedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  createdAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  opportunityIds: z.array(z.string()).optional(),
  passThrough: z.array(
    z.lazy(() => ContactGetResponsePassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    companyId: "company_id",
    companyName: "company_name",
    leadId: "lead_id",
    firstName: "first_name",
    middleName: "middle_name",
    lastName: "last_name",
    photoUrl: "photo_url",
    leadSource: "lead_source",
    currentBalance: "current_balance",
    socialLinks: "social_links",
    phoneNumbers: "phone_numbers",
    emailDomain: "email_domain",
    customFields: "custom_fields",
    firstCallAt: "first_call_at",
    firstEmailAt: "first_email_at",
    lastActivityAt: "last_activity_at",
    customMappings: "custom_mappings",
    updatedAt: "updated_at",
    createdAt: "created_at",
    opportunityIds: "opportunity_ids",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponseData$ {
  /** @deprecated use `ContactGetResponseData$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponseData$inboundSchema;
  /** @deprecated use `ContactGetResponseData$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponseData$outboundSchema;
  /** @deprecated use `ContactGetResponseData$Outbound` instead. */
  export type Outbound = ContactGetResponseData$Outbound;
}

export function contactGetResponseDataToJSON(
  contactGetResponseData: ContactGetResponseData,
): string {
  return JSON.stringify(
    ContactGetResponseData$outboundSchema.parse(contactGetResponseData),
  );
}

export function contactGetResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponseData' from JSON`,
  );
}

/** @internal */
export const ContactGetResponse$inboundSchema: z.ZodType<
  ContactGetResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => ContactGetResponseData$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type ContactGetResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: ContactGetResponseData$Outbound;
};

/** @internal */
export const ContactGetResponse$outboundSchema: z.ZodType<
  ContactGetResponse$Outbound,
  z.ZodTypeDef,
  ContactGetResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => ContactGetResponseData$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactGetResponse$ {
  /** @deprecated use `ContactGetResponse$inboundSchema` instead. */
  export const inboundSchema = ContactGetResponse$inboundSchema;
  /** @deprecated use `ContactGetResponse$outboundSchema` instead. */
  export const outboundSchema = ContactGetResponse$outboundSchema;
  /** @deprecated use `ContactGetResponse$Outbound` instead. */
  export type Outbound = ContactGetResponse$Outbound;
}

export function contactGetResponseToJSON(
  contactGetResponse: ContactGetResponse,
): string {
  return JSON.stringify(
    ContactGetResponse$outboundSchema.parse(contactGetResponse),
  );
}

export function contactGetResponseFromJSON(
  jsonString: string,
): SafeParseResult<ContactGetResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactGetResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactGetResponse' from JSON`,
  );
}

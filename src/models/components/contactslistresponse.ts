/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The classification or category of the contact, such as 'customer', 'supplier', or 'partner'. This optional field helps in segmenting contacts for targeted communication and reporting. Understanding the type of contact can influence how interactions are prioritized and managed within the CRM system.
 */
export const ContactsListResponseType = {
  Customer: "customer",
  Supplier: "supplier",
  Employee: "employee",
  Personal: "personal",
} as const;
/**
 * The classification or category of the contact, such as 'customer', 'supplier', or 'partner'. This optional field helps in segmenting contacts for targeted communication and reporting. Understanding the type of contact can influence how interactions are prioritized and managed within the CRM system.
 */
export type ContactsListResponseType = ClosedEnum<
  typeof ContactsListResponseType
>;

/**
 * Specifies the gender of the contact, which can be used for personalized communication and marketing strategies. Acceptable values typically include 'male', 'female', 'non-binary', or 'other'. This field is optional and should be used in accordance with privacy regulations and the contact's preferences.
 */
export const ContactsListResponseGender = {
  Male: "male",
  Female: "female",
  Unisex: "unisex",
} as const;
/**
 * Specifies the gender of the contact, which can be used for personalized communication and marketing strategies. Acceptable values typically include 'male', 'female', 'non-binary', or 'other'. This field is optional and should be used in accordance with privacy regulations and the contact's preferences.
 */
export type ContactsListResponseGender = ClosedEnum<
  typeof ContactsListResponseGender
>;

/**
 * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
 */
export const ContactsListResponseDataType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
 */
export type ContactsListResponseDataType = ClosedEnum<
  typeof ContactsListResponseDataType
>;

export type ContactsListResponseWebsites = {
  /**
   * A unique identifier for each website entry associated with the lead, ensuring that each website can be distinctly referenced and managed within the CRM system. This ID is crucial for operations that involve updating or removing specific websites from the lead's profile, maintaining data integrity and consistency.
   */
  id?: string | null | undefined;
  /**
   * The website URL for the lead's business or personal site. This URL serves as a digital point of contact and is essential for verifying the lead's online presence. It must be a valid URL format, starting with http:// or https://, and is crucial for CRM users to access further information about the lead's activities or offerings. This field is required to ensure that the lead's digital footprint is accurately captured and easily accessible.
   */
  url: string;
  /**
   * The type of website associated with the lead, such as 'personal', 'business', or 'portfolio'. This categorization helps CRM users quickly understand the nature of the website and its relevance to the lead's profile. While not required, specifying the type can enhance data organization and retrieval, aiding in targeted communication strategies.
   */
  type?: ContactsListResponseDataType | null | undefined;
};

/**
 * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
 */
export const ContactsListResponseDataAddressesType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Office: "office",
  Shipping: "shipping",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
 */
export type ContactsListResponseDataAddressesType = ClosedEnum<
  typeof ContactsListResponseDataAddressesType
>;

export type ContactsListResponseAddresses = {
  /**
   * A unique identifier for each address within the user's address array. This ID is crucial for distinguishing between different address records, especially when updating or deleting specific addresses. It ensures that each address can be individually referenced and managed within the CRM system, maintaining data integrity and accuracy.
   */
  id?: string | null | undefined;
  /**
   * Specifies the type of address, such as 'home', 'work', or 'billing'. This classification helps in organizing and retrieving addresses based on their usage context. It is important for applications that need to differentiate between various address types for operations like shipping or invoicing.
   */
  type?: ContactsListResponseDataAddressesType | null | undefined;
  /**
   * The full address in a single string format, used when structured address data is not available. This field is essential for APIs that do not support detailed address components, allowing for a flexible representation of address information. It is particularly useful for quick data entry and display purposes.
   */
  string?: string | null | undefined;
  /**
   * A descriptive name for the address, often used to label or identify the address within the user's profile. This can include names like 'Headquarters', 'Main Office', or 'John's Apartment', providing a human-readable identifier that simplifies address management and selection within the CRM.
   */
  name?: string | null | undefined;
  /**
   * Line 1 of the address e.g. number, street, suite, apt #, etc.
   */
  line1?: string | null | undefined;
  /**
   * Line 2 of the address
   */
  line2?: string | null | undefined;
  /**
   * Line 3 of the address
   */
  line3?: string | null | undefined;
  /**
   * Line 4 of the address
   */
  line4?: string | null | undefined;
  /**
   * Street number
   */
  streetNumber?: string | null | undefined;
  /**
   * The name of the city associated with the user's address. This field is used to specify the city where the user resides or is located. It is important for geographical identification and can be used for location-based services or analytics. Ensure the city name is spelled correctly to maintain data accuracy and integrity within the CRM system.
   */
  city?: string | null | undefined;
  /**
   * The name of the state or region associated with the user's address. This field helps in identifying the specific administrative area within a country where the user is located. It is crucial for regional segmentation and can aid in compliance with local regulations. Ensure the state name is accurate to facilitate proper data management and reporting.
   */
  state?: string | null | undefined;
  /**
   * The postal code or equivalent for the user's address. This field is essential for precise location identification and is often used in mailing and shipping processes. It can also be used for demographic analysis and service eligibility checks. Ensure the postal code is valid and corresponds to the correct city and state to avoid errors in data processing.
   */
  postalCode?: string | null | undefined;
  /**
   * The country code for the user's address, following the ISO 3166-1 alpha-2 standard. This field is vital for internationalization and ensures that the user's location is correctly identified on a global scale. It supports cross-border operations and compliance with international standards. Ensure the country code is accurate to maintain consistency in global data management.
   */
  country?: string | null | undefined;
  /**
   * The latitude coordinate of the user's address. This field provides the geographical latitude, which is used in mapping and location-based services. It is important for applications that require precise geolocation, such as delivery services or geographic analysis. Ensure the latitude is accurate to enhance the reliability of location-dependent operations.
   */
  latitude?: string | null | undefined;
  /**
   * The longitude coordinate of the address, representing the east-west position on the Earth's surface. This value is crucial for geolocation services and mapping functionalities within the CRM, enabling precise location tracking and integration with geographic information systems. It should be a valid string representation of a decimal degree, typically ranging from -180.0 to 180.0.
   */
  longitude?: string | null | undefined;
  /**
   * This field captures the sublocality or county of the address, providing additional geographic context. It is particularly useful for regional segmentation and analysis, allowing for more granular data categorization and reporting. The county name should be accurately spelled to ensure consistency across records.
   */
  county?: string | null | undefined;
  /**
   * The full name of the primary contact person associated with the address. This information is vital for personalized communication and relationship management within the CRM. It should include both first and last names, and be kept up-to-date to reflect any changes in contact personnel.
   */
  contactName?: string | null | undefined;
  /**
   * The salutation or title used for the contact person at the address, such as Mr., Ms., Dr., etc. This field enhances formal communication and is important for maintaining professional etiquette in correspondence. It should be chosen based on the contact's preference and cultural norms.
   */
  salutation?: string | null | undefined;
  /**
   * The primary phone number associated with the address, used for direct communication with the contact person. This number should be formatted according to international standards to ensure it can be dialed from any location. It is essential for timely and effective communication, especially in customer service scenarios.
   */
  phoneNumber?: string | null | undefined;
  /**
   * The fax number associated with the user's address. This field allows for the inclusion of traditional communication methods, which may be necessary for certain business transactions or legal documentation. While not commonly used in modern digital communications, maintaining a fax number can be crucial for businesses that still rely on this method. Ensure the number is formatted correctly to avoid transmission errors.
   */
  fax?: string | null | undefined;
  /**
   * The email address linked to the user's address, serving as a primary mode of digital communication. This field is essential for sending notifications, updates, and other important information directly to the user. It should be a valid email format to ensure successful delivery and communication. Keeping this information up-to-date is vital for maintaining effective contact with the user.
   */
  email?: string | null | undefined;
  /**
   * The website URL associated with the user's address, providing a digital point of reference or contact. This can be used to direct users to a personal or business website, offering more information or services. Ensure the URL is complete and correctly formatted to facilitate seamless access. This field supports the user's digital presence and connectivity.
   */
  website?: string | null | undefined;
  /**
   * Additional notes related to the user's address, offering space for any extra information that might be relevant but does not fit into other predefined fields. This could include special delivery instructions, historical data, or personal preferences. These notes can be crucial for personalized service and ensuring all relevant details are captured.
   */
  notes?: string | null | undefined;
  /**
   * A binary value used to track changes to the user's address object, ensuring data integrity and preventing update conflicts. This field is automatically incremented with each update, allowing the system to detect concurrent modifications and manage them appropriately. It is crucial for maintaining accurate and consistent data across the CRM system, especially in environments with multiple users accessing the same records.
   */
  rowVersion?: string | null | undefined;
};

export type ContactsListResponseSocialLinks = {
  /**
   * A unique identifier for each social link entry within the array. This ID is used to distinguish between different social media profiles associated with the lead, ensuring that each link can be individually referenced and managed. It is essential for operations that involve updating or removing specific social links without affecting others.
   */
  id?: string | null | undefined;
  /**
   * The complete URL of the social media profile associated with the lead. This field is required and must be a valid URL format, such as 'https://www.twitter.com/apideck'. It provides direct access to the lead's social media presence, enabling CRM users to quickly view and interact with the lead's profiles. Accurate URLs are vital for maintaining effective communication and engagement strategies.
   */
  url: string;
  /**
   * Specifies the type of social media link associated with the lead, such as Twitter, LinkedIn, or Facebook. This field helps categorize and manage the lead's social media presence within the CRM, allowing for targeted communication strategies. It is optional but recommended for leads with active social media profiles to enhance engagement tracking.
   */
  type?: string | null | undefined;
};

/**
 * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
 */
export const ContactsListResponseDataPhoneNumbersType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Work: "work",
  Office: "office",
  Mobile: "mobile",
  Assistant: "assistant",
  Fax: "fax",
  DirectDialIn: "direct-dial-in",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
 */
export type ContactsListResponseDataPhoneNumbersType = ClosedEnum<
  typeof ContactsListResponseDataPhoneNumbersType
>;

export type ContactsListResponsePhoneNumbers = {
  /**
   * A unique identifier for each phone number entry within the user's phone numbers array. This ID is crucial for distinguishing between different phone numbers, especially when updating or deleting specific numbers. It ensures that operations are performed on the correct phone number entry, maintaining data integrity within the user's contact information.
   */
  id?: string | null | undefined;
  /**
   * The international dialing code associated with the phone number, such as '+1' for the United States. This field is essential for ensuring that phone numbers are formatted correctly for international dialing and can be used to validate the geographical origin of the number. It helps in standardizing phone numbers across different regions and is critical for applications that involve international communication.
   */
  countryCode?: string | null | undefined;
  /**
   * The regional area code that precedes the local phone number, such as '323' for parts of Los Angeles. This code is important for routing calls within specific geographic areas and is a key component of the full phone number. Including the area code ensures that the phone number is complete and can be dialed correctly from both local and international locations.
   */
  areaCode?: string | null | undefined;
  /**
   * The main part of the phone number, excluding the country and area codes. This field is required as it represents the actual number that will be dialed within the specified area and country codes. It is the core component of the user's contact information and must be accurate to ensure successful communication. This field is mandatory to ensure that there is a valid number associated with the user.
   */
  number: string;
  /**
   * The extension of the phone number, typically used in corporate environments to direct calls to specific departments or employees. This field is optional and should be used when the phone number is part of a larger system, such as a PBX, where extensions are necessary for routing calls internally. Including an extension ensures that calls reach the intended recipient without delay.
   */
  extension?: string | null | undefined;
  /**
   * The type of phone number, indicating its purpose or usage context, such as 'mobile', 'home', 'work', etc. This classification helps in organizing contact methods and is crucial for determining the best way to reach a user. It is optional but recommended for clarity in communication preferences.
   */
  type?: ContactsListResponseDataPhoneNumbersType | null | undefined;
};

/**
 * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
 */
export const ContactsListResponseDataEmailsType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
 */
export type ContactsListResponseDataEmailsType = ClosedEnum<
  typeof ContactsListResponseDataEmailsType
>;

export type ContactsListResponseEmails = {
  /**
   * A unique identifier for each email address within the user's email collection. This ID is used to distinguish between multiple email addresses associated with a single user, allowing for precise updates and management of contact information. It is optional but can be useful for operations that require specific email targeting.
   */
  id?: string | null | undefined;
  /**
   * The actual email address used for electronic communication with the user. This field is required and must be a valid email format to ensure successful delivery of messages. It serves as a primary contact method and is essential for user engagement and CRM operations.
   */
  email: string | null;
  /**
   * Specifies the category or role of the email address associated with the user, such as 'work', 'personal', or 'other'. This helps in distinguishing between different types of email addresses for effective communication management within the CRM system. It is not mandatory, but providing this information can enhance the clarity and organization of user contact details.
   */
  type?: ContactsListResponseDataEmailsType | null | undefined;
};

export type ContactsListResponseValue6 = {};

export type ContactsListResponseValue4 = {};

/**
 * The value assigned to a custom field within the opportunity record. Custom fields allow for additional, user-defined data to be stored, providing flexibility to tailor the CRM to specific business needs. This field is optional and can be used to capture unique attributes or metrics relevant to the opportunity that are not covered by standard fields.
 */
export type ContactsListResponseValue =
  | ContactsListResponseValue4
  | string
  | number
  | boolean
  | Array<string>
  | Array<ContactsListResponseValue6>;

export type ContactsListResponseCustomFields = {
  /**
   * Unique identifier for the custom field. This ID is essential for distinguishing each custom field within the opportunity's data structure. It ensures that each field can be individually accessed, updated, or removed as needed. The ID must be unique within the context of the opportunity to prevent data conflicts and maintain data integrity.
   */
  id: string | null;
  /**
   * Name of the custom field. This name serves as a label for the custom field, providing a human-readable identifier that describes the field's purpose or content. While not required, including a name can improve clarity and usability, especially when multiple custom fields are present. It should be concise yet descriptive enough to convey the field's role in the opportunity's data.
   */
  name?: string | null | undefined;
  /**
   * More information about the custom field. This description offers additional context or details about the custom field's intended use or significance. It can include guidelines on what type of data should be entered or how the field relates to the overall sales process. Providing a description is optional but can enhance understanding and proper utilization of the custom field by users.
   */
  description?: string | null | undefined;
  /**
   * The value assigned to a custom field within the opportunity record. Custom fields allow for additional, user-defined data to be stored, providing flexibility to tailor the CRM to specific business needs. This field is optional and can be used to capture unique attributes or metrics relevant to the opportunity that are not covered by standard fields.
   */
  value?:
    | ContactsListResponseValue4
    | string
    | number
    | boolean
    | Array<string>
    | Array<ContactsListResponseValue6>
    | null
    | undefined;
};

/**
 * This object contains any custom mappings that have been configured for the contact resource. Custom mappings allow for the adaptation of the contact data to fit specific business needs or third-party integrations. They are particularly useful when integrating with multiple CRM systems or when specific fields need to be aligned with external data structures. This property is optional and will only be included if custom mappings are set up for the contact.
 */
export type ContactsListResponseCustomMappings = {};

export type ContactsListResponseExtendPaths = {
  /**
   * A JSONPath string that specifies the exact location within the user record where the value should be applied. This is essential for making precise updates to nested fields, ensuring that changes are made only to the intended parts of the data structure. The path must be valid and correspond to an existing field within the user record.
   */
  path: string;
  /**
   * This property represents the specific value that you wish to assign to a designated path within the user record. It can be of any data type, such as a string, number, boolean, or object, depending on the field being updated. The flexibility of this property allows for a wide range of updates, from simple text changes to complex data structures. In the context of the `usersUpdate` operation, this property is crucial for specifying the exact data modification you intend to make, ensuring that only the targeted fields are altered without affecting other data. Proper validation should be applied to ensure the value is compatible with the field's expected data type and business rules. Common use cases include updating user contact information, preferences, or custom attributes specific to your CRM's schema.
   */
  value?: any | undefined;
};

export type ContactsListResponsePassThrough = {
  /**
   * The unique identifier for the specific service to which this pass_through should be applied. This is crucial for directing the update operation to the correct service within the CRM system, ensuring that the modifications are executed in the appropriate context. It must be a valid service ID that corresponds to an active service integration, and it is required for the operation to proceed.
   */
  serviceId: string;
  /**
   * An optional identifier for a specific workflow operation within the CRM system to which this pass_through should be applied. This is particularly useful for Unify calls that involve multiple downstream requests, allowing for precise targeting and execution of specific operations. If provided, it should match an existing operation ID to ensure correct processing.
   */
  operationId?: string | undefined;
  /**
   * A flexible object that allows for the inclusion of any additional properties needed for direct extension of the user record. This can be used to add custom fields or metadata that are not part of the standard user schema, providing a way to tailor the user data to specific business needs. The structure of this object should align with the CRM's data model to ensure compatibility.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects designed for structured data modifications via specified paths. This allows for precise updates to nested data structures within the user record, enabling complex modifications without altering unrelated data. Each object in the array should define a clear path and value to be applied, ensuring targeted updates.
   */
  extendPaths?: Array<ContactsListResponseExtendPaths> | undefined;
};

export type ContactsListResponseData = {
  /**
   * The unique identifier for the contact within the CRM system. This ID is automatically generated when a contact is created and is used to precisely locate and update the contact record. While not required for the update operation, providing it ensures that the correct contact is modified, especially in systems with large datasets. It is crucial for maintaining data integrity and avoiding accidental updates to the wrong contact.
   */
  id?: string | undefined;
  /**
   * The full name of the contact, which serves as a primary identifier within the CRM. This field is required for updates to ensure that the contact's identity is clear and unambiguous. It is used in various CRM functionalities, such as search and display, and should reflect the contact's preferred name format. Accurate naming helps in personalizing communication and maintaining professional relationships.
   */
  name: string | null;
  /**
   * The identifier for the user or entity that owns or manages the contact within the CRM. This field is optional but can be critical for assigning responsibility and tracking interactions with the contact. It helps in organizing contacts by ownership, which is useful for sales teams and account managers to manage their client portfolios effectively.
   */
  ownerId?: string | null | undefined;
  /**
   * The classification or category of the contact, such as 'customer', 'supplier', or 'partner'. This optional field helps in segmenting contacts for targeted communication and reporting. Understanding the type of contact can influence how interactions are prioritized and managed within the CRM system.
   */
  type?: ContactsListResponseType | null | undefined;
  /**
   * The unique identifier for the company with which the contact is associated. This optional field links the contact to a specific company record within the CRM, facilitating a comprehensive view of business relationships. It is particularly useful in B2B contexts where contacts are often tied to organizational accounts, aiding in the management of corporate interactions and history.
   */
  companyId?: string | null | undefined;
  /**
   * The name of the company the contact is associated with. This field is used to link the contact to their respective organization within the CRM. It is essential for organizing contacts under their business entities, facilitating better management and retrieval of contact information. While not mandatory, providing the company name enhances the context and relevance of the contact record, especially in business-to-business interactions.
   */
  companyName?: string | null | undefined;
  /**
   * The lead the contact is associated with. This identifier connects the contact to a specific lead record within the CRM, which is crucial for tracking the contact's journey from a potential lead to a customer. It helps in maintaining a seamless flow of information and ensures that all interactions with the contact are aligned with their lead status. Although optional, associating a contact with a lead can provide valuable insights into sales processes and customer engagement strategies.
   */
  leadId?: string | null | undefined;
  /**
   * The first name of the contact. This field is used to personalize communications and is a key component of the contact's identity within the CRM. It is important for ensuring accurate and respectful interactions, as well as for searching and filtering contacts. While not required, including the first name enhances the quality of customer relationship management by allowing for more personalized and effective communication.
   */
  firstName?: string | null | undefined;
  /**
   * The middle name of the contact. This optional field can be used to store additional name information that may be relevant for distinguishing between contacts with similar names or for formal documentation purposes. Including a middle name can enhance the accuracy of contact identification and is particularly useful in regions or cultures where middle names are commonly used.
   */
  middleName?: string | null | undefined;
  /**
   * The last name of the contact. This field is critical for identifying and organizing contacts within the CRM. It is often used in conjunction with the first name to ensure precise identification and is essential for sorting and searching contact records. While not mandatory, providing the last name significantly improves the system's ability to manage and retrieve contact information efficiently.
   */
  lastName?: string | null | undefined;
  /**
   * The prefix of the contact, such as Mr., Ms., Dr., etc. This field is used to address the contact formally and can enhance personalization in communications. It is optional and should be chosen based on the contact's preference or cultural norms.
   */
  prefix?: string | null | undefined;
  /**
   * The suffix of the contact, such as Jr., Sr., III, etc. This field helps in distinguishing between individuals with similar names within the CRM. It is optional and should be used when applicable to maintain accurate records.
   */
  suffix?: string | null | undefined;
  /**
   * The job title of the contact within their organization. This information is crucial for understanding the contact's role and responsibilities, aiding in targeted communication and relationship management. It is optional but recommended for business context.
   */
  title?: string | null | undefined;
  /**
   * The department within the organization where the contact works. This field helps in segmenting contacts based on their organizational role, facilitating more effective communication strategies. It is optional but useful for targeted outreach.
   */
  department?: string | null | undefined;
  /**
   * The preferred language of communication for the contact, specified using the ISO 639-1 code (e.g., 'EN' for English). This field ensures that communications are delivered in a language the contact understands, enhancing engagement and reducing misunderstandings. It is optional but highly recommended for international contacts.
   */
  language?: string | null | undefined;
  /**
   * Specifies the gender of the contact, which can be used for personalized communication and marketing strategies. Acceptable values typically include 'male', 'female', 'non-binary', or 'other'. This field is optional and should be used in accordance with privacy regulations and the contact's preferences.
   */
  gender?: ContactsListResponseGender | null | undefined;
  /**
   * The birth date of the contact, formatted as a string (e.g., 'YYYY-MM-DD'). This information can be utilized for sending personalized birthday messages or offers, enhancing customer engagement. Ensure the date is accurate to avoid miscommunication.
   */
  birthday?: string | null | undefined;
  /**
   * A string representing the image data or a reference to the contact's image. This field can be used to visually identify contacts within the CRM system, aiding in quick recognition and personalization. Ensure the image is appropriately formatted and stored securely.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  image?: string | null | undefined;
  /**
   * The URL linking to the contact's photo, which can be displayed in the CRM interface to help users quickly identify the contact. This should be a valid URL pointing to an accessible image file. It's important to ensure the URL remains up-to-date and the image is stored in a secure location.
   */
  photoUrl?: string | null | undefined;
  /**
   * Indicates the origin of the contact, such as 'web', 'referral', or 'advertisement'. Understanding the lead source helps in analyzing the effectiveness of different marketing channels and strategies. This field is optional but valuable for marketing analytics and strategy refinement.
   */
  leadSource?: string | null | undefined;
  /**
   * The fax number associated with the contact, used for sending and receiving documents via fax. This field is optional and should be formatted according to international dialing standards if applicable. Including a fax number can be beneficial for businesses that still rely on fax communication for official documentation or contracts.
   */
  fax?: string | null | undefined;
  /**
   * A detailed narrative or note about the contact, providing context or additional information that may be relevant for CRM users. This could include personal preferences, historical interactions, or any other pertinent details that help in personalizing communication or understanding the contact's background. This field is optional but can enhance the quality of customer relationship management by offering insights that are not captured by structured data fields.
   */
  description?: string | null | undefined;
  /**
   * The current financial balance associated with the contact, reflecting any outstanding amounts owed or credits available. This numeric field is crucial for financial tracking and management within the CRM, especially for contacts who are clients or vendors. It should be updated regularly to ensure accurate financial records and can be used to trigger alerts or actions if certain thresholds are met. This field is optional and should be formatted as a decimal number.
   */
  currentBalance?: number | null | undefined;
  /**
   * The current status of the contact within the CRM system, indicating their relationship or engagement level with the organization. Common statuses might include 'active', 'inactive', 'prospect', or 'customer'. This field helps in segmenting contacts for targeted marketing or follow-up actions and should be updated to reflect any changes in the contact's lifecycle. This field is optional but highly recommended for effective contact management.
   */
  status?: string | null | undefined;
  /**
   * A boolean flag indicating whether the contact is currently active within the CRM system. An active status typically means the contact is engaged or available for communication and transactions. This field is crucial for filtering contacts in reports and ensuring that communications are directed only to those who are currently relevant. Setting this field to 'false' can help in cleaning up the database by deactivating contacts that are no longer needed. This field is optional but important for maintaining an organized and efficient CRM.
   */
  active?: boolean | null | undefined;
  /**
   * A collection of website entries associated with the contact. This array can include multiple websites, each represented as an object with specific attributes such as URL and type. Useful for storing all relevant online presences of the contact, enhancing the contact's profile with comprehensive digital footprint information.
   */
  websites?: Array<ContactsListResponseWebsites> | undefined;
  /**
   * An array containing address entries related to the contact. Each entry can include details such as street, city, and postal code. This array allows for the inclusion of multiple addresses, supporting scenarios where a contact may have several locations, such as home and work addresses. It enriches the contact's profile by providing geographical context.
   */
  addresses?: Array<ContactsListResponseAddresses> | undefined;
  /**
   * An array of social media links associated with the contact. This field allows for the inclusion of various social media profiles, such as LinkedIn, Twitter, or Facebook, providing a comprehensive view of the contact's online presence. While optional, these links can be valuable for networking and understanding the contact's professional and personal interests, enhancing engagement strategies.
   */
  socialLinks?: Array<ContactsListResponseSocialLinks> | undefined;
  /**
   * An array containing one or more phone number objects associated with the contact. Each object within the array can hold detailed information about a specific phone number, such as type and ID. This structure allows for the inclusion of multiple contact numbers, facilitating comprehensive communication options for the contact.
   */
  phoneNumbers?: Array<ContactsListResponsePhoneNumbers> | undefined;
  /**
   * An array of email objects associated with the contact. Each object within this array represents a distinct email address linked to the contact, allowing for multiple email addresses to be stored and managed. This is particularly useful for contacts who use different emails for various purposes, such as personal and professional communication. The array can be updated to add, remove, or modify email addresses as needed, ensuring the contact's email information is current and comprehensive.
   */
  emails?: Array<ContactsListResponseEmails> | undefined;
  /**
   * The domain part of the contact's primary email address, extracted for analytical or organizational purposes. This field can be used to group contacts by their email domains, which is useful for domain-specific marketing campaigns or understanding the distribution of contacts across different email providers. It is not required but can provide additional insights into the contact's email usage.
   */
  emailDomain?: string | null | undefined;
  /**
   * An array of custom fields associated with the contact record. Each entry in this array represents a specific custom field that can be used to store additional information not covered by standard fields. This allows for greater flexibility and customization of contact records to meet specific business needs. Custom fields can include data such as preferences, additional contact methods, or any other relevant information that enhances the contact profile.
   */
  customFields?: Array<ContactsListResponseCustomFields> | undefined;
  /**
   * An array of tags associated with the contact, used to categorize and filter contacts within the CRM system. Tags can represent various attributes or statuses, such as 'VIP', 'Lead', or 'Prospect', and help in organizing contacts for targeted marketing or communication strategies. This field is optional and can be updated to reflect changes in the contact's status or classification.
   */
  tags?: Array<string> | null | undefined;
  /**
   * The date and time when the first call was made to or received from the contact, formatted as an ISO 8601 string. This information is crucial for tracking the initial point of voice communication with the contact, providing insights into the contact's engagement history. It helps in understanding the timeline of interactions and planning follow-up activities.
   */
  firstCallAt?: Date | null | undefined;
  /**
   * The date and time when the first email was sent to or received from the contact, formatted as an ISO 8601 string. This field is important for documenting the initial email interaction, which can be pivotal in establishing communication history and assessing the contact's responsiveness. It aids in strategizing future email campaigns and follow-ups.
   */
  firstEmailAt?: Date | null | undefined;
  /**
   * The date and time of the most recent interaction with the contact, formatted as an ISO 8601 string. This field is essential for monitoring ongoing engagement and determining the recency of contact activities. It helps in prioritizing contacts for follow-up actions and maintaining up-to-date records of contact interactions.
   */
  lastActivityAt?: Date | null | undefined;
  /**
   * This object contains any custom mappings that have been configured for the contact resource. Custom mappings allow for the adaptation of the contact data to fit specific business needs or third-party integrations. They are particularly useful when integrating with multiple CRM systems or when specific fields need to be aligned with external data structures. This property is optional and will only be included if custom mappings are set up for the contact.
   */
  customMappings?: ContactsListResponseCustomMappings | null | undefined;
  /**
   * A timestamp indicating the last time the contact record was updated. This field is crucial for tracking changes and ensuring data consistency across systems. It follows the ISO 8601 format (e.g., '2023-10-01T12:00:00Z') and is automatically managed by the system. This property is optional but provides valuable information for audit trails and synchronization processes.
   */
  updatedAt?: Date | null | undefined;
  /**
   * A timestamp representing when the contact record was initially created in the CRM. This field is important for historical data analysis and understanding the lifecycle of a contact. It uses the ISO 8601 format (e.g., '2023-10-01T12:00:00Z') and is set automatically at the time of creation. While optional, it is essential for maintaining accurate records of contact inception dates.
   */
  createdAt?: Date | null | undefined;
  /**
   * An array containing the unique identifiers of opportunities associated with the contact. This linkage is vital for understanding the contact's involvement in various sales or business opportunities. Each ID in the array corresponds to a specific opportunity record in the CRM. This property is optional but can be used to enhance the contact's profile with related business engagements.
   */
  opportunityIds?: Array<string> | undefined;
  /**
   * The `pass_through` property is an array that allows you to include service-specific custom data or structured modifications directly within the request body when updating contact resources. This feature is particularly useful for integrating unique business logic or additional data fields that are not natively supported by the CRM system. By leveraging `pass_through`, you can ensure that all necessary information is transmitted to the appropriate service, enhancing the flexibility and adaptability of the update operation. It is important to structure this data correctly to align with the service's requirements, ensuring seamless integration and operation.
   */
  passThrough?: Array<ContactsListResponsePassThrough> | undefined;
};

/**
 * This property provides cursors that are used to navigate through paginated API responses, allowing clients to move to previous or next pages of data. It is included in the response when pagination is enabled, facilitating seamless data retrieval across multiple API calls. This ensures that applications can efficiently access large datasets without overwhelming the client or server.
 */
export type ContactsListResponseCursors = {
  /**
   * The 'previous' cursor is a string token used to retrieve the preceding set of results in a paginated API response. It is included in the response when there are more results available before the current set, allowing clients to navigate backward through the data. This cursor is particularly useful in scenarios where users need to review or analyze data from earlier pages.
   */
  previous?: string | null | undefined;
  /**
   * The 'current' cursor is a string token representing the current position in the paginated list of results. It is included in the response to indicate the current page's starting point, helping clients maintain their place in the data sequence during navigation. This is essential for tracking the current dataset being viewed or processed.
   */
  current?: string | null | undefined;
  /**
   * The 'next' cursor is a string token that facilitates navigation to the subsequent set of results in a paginated API response. It is included when additional data is available beyond the current page, enabling clients to continue retrieving more results seamlessly. This is crucial for applications that need to process large datasets incrementally.
   */
  next?: string | null | undefined;
};

/**
 * This object contains metadata about the response, providing additional context and information about the data returned. It may include details such as pagination cursors, timestamps, or other relevant metadata that help in understanding the scope and nature of the response. This property is included to assist in managing and interpreting the response data, especially in complex or paginated queries.
 */
export type ContactsListResponseMeta = {
  /**
   * This property indicates the number of items that are included in the 'data' section of the response. It is particularly useful for understanding the volume of data returned in a single API call, especially when pagination is in use. This property is included in the response to help clients manage data processing and display, ensuring that applications can handle the data efficiently.
   */
  itemsOnPage?: number | undefined;
  /**
   * This property provides cursors that are used to navigate through paginated API responses, allowing clients to move to previous or next pages of data. It is included in the response when pagination is enabled, facilitating seamless data retrieval across multiple API calls. This ensures that applications can efficiently access large datasets without overwhelming the client or server.
   */
  cursors?: ContactsListResponseCursors | undefined;
};

/**
 * The 'links' object contains hypermedia links that facilitate navigation to previous or next pages within the API response. These links are included in paginated responses to provide direct URLs for accessing adjacent pages, enhancing the ease of navigation through large datasets. This is particularly beneficial for developers implementing client-side pagination, as it simplifies the process of linking to subsequent or prior data pages.
 */
export type ContactsListResponseLinks = {
  /**
   * The 'previous' link is a URL string that directs clients to the previous page of results in the API. It is included when there are earlier pages available, allowing users to easily navigate back to review or access prior data. This link is essential for applications that support backward navigation through paginated datasets.
   */
  previous?: string | null | undefined;
  /**
   * This property provides a URL link that directs to the current page of the user list in the API response. It is particularly useful for applications implementing pagination, allowing them to easily reload or refresh the current set of user data. This link is included in the response when pagination is in use, ensuring that users can maintain their current position within the dataset when navigating through multiple pages of results.
   */
  current?: string | undefined;
  /**
   * This property contains a URL link that directs to the next page of the user list in the API response. It is essential for applications that need to handle large datasets by breaking them into manageable pages. This link is included when there are additional pages of user data available beyond the current page, facilitating seamless navigation through the complete list of users without manually constructing URLs.
   */
  next?: string | null | undefined;
};

/**
 * Contacts
 */
export type ContactsListResponse = {
  /**
   * The HTTP response status code returned by the server, indicating the result of the API request. A status code of 200 signifies a successful retrieval of contacts, while other codes may indicate errors or issues with the request. This code is essential for understanding the outcome of the operation and is always included in the response.
   */
  statusCode: number;
  /**
   * A textual representation of the HTTP response status, providing a human-readable explanation of the status code. For example, 'OK' corresponds to a 200 status code, indicating a successful operation. This property helps in quickly understanding the result of the API call without needing to interpret numeric codes.
   */
  status: string;
  /**
   * The Apideck ID of the service provider that processed the request. This identifier is crucial when multiple service integrations are active, as it specifies which service handled the operation. It ensures clarity in multi-service environments and is always included in the response for tracking purposes.
   */
  service: string;
  /**
   * The name of the unified API resource that was accessed or manipulated during the operation. In this context, it typically refers to 'contacts', indicating that the operation involved retrieving contact data. This property is included to confirm the specific resource targeted by the request.
   */
  resource: string;
  /**
   * The specific operation performed by the API, such as 'retrieve' or 'list'. This property provides context about the action taken on the resource, helping users understand what was done during the API call. It is always included to clarify the nature of the request and response.
   */
  operation: string;
  /**
   * An array containing the list of contact objects retrieved from the CRM system. Each object in this array represents a single contact with its associated details, such as name, ID, and type. This array is always included in the response to provide the requested contact data, and its presence is crucial for iterating over the contact information returned by the API.
   */
  data: Array<ContactsListResponseData>;
  /**
   * This object contains metadata about the response, providing additional context and information about the data returned. It may include details such as pagination cursors, timestamps, or other relevant metadata that help in understanding the scope and nature of the response. This property is included to assist in managing and interpreting the response data, especially in complex or paginated queries.
   */
  meta?: ContactsListResponseMeta | undefined;
  /**
   * The 'links' object contains hypermedia links that facilitate navigation to previous or next pages within the API response. These links are included in paginated responses to provide direct URLs for accessing adjacent pages, enhancing the ease of navigation through large datasets. This is particularly beneficial for developers implementing client-side pagination, as it simplifies the process of linking to subsequent or prior data pages.
   */
  links?: ContactsListResponseLinks | undefined;
};

/** @internal */
export const ContactsListResponseType$inboundSchema: z.ZodNativeEnum<
  typeof ContactsListResponseType
> = z.nativeEnum(ContactsListResponseType);

/** @internal */
export const ContactsListResponseType$outboundSchema: z.ZodNativeEnum<
  typeof ContactsListResponseType
> = ContactsListResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseType$ {
  /** @deprecated use `ContactsListResponseType$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseType$inboundSchema;
  /** @deprecated use `ContactsListResponseType$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseType$outboundSchema;
}

/** @internal */
export const ContactsListResponseGender$inboundSchema: z.ZodNativeEnum<
  typeof ContactsListResponseGender
> = z.nativeEnum(ContactsListResponseGender);

/** @internal */
export const ContactsListResponseGender$outboundSchema: z.ZodNativeEnum<
  typeof ContactsListResponseGender
> = ContactsListResponseGender$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseGender$ {
  /** @deprecated use `ContactsListResponseGender$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseGender$inboundSchema;
  /** @deprecated use `ContactsListResponseGender$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseGender$outboundSchema;
}

/** @internal */
export const ContactsListResponseDataType$inboundSchema: z.ZodNativeEnum<
  typeof ContactsListResponseDataType
> = z.nativeEnum(ContactsListResponseDataType);

/** @internal */
export const ContactsListResponseDataType$outboundSchema: z.ZodNativeEnum<
  typeof ContactsListResponseDataType
> = ContactsListResponseDataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseDataType$ {
  /** @deprecated use `ContactsListResponseDataType$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseDataType$inboundSchema;
  /** @deprecated use `ContactsListResponseDataType$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseDataType$outboundSchema;
}

/** @internal */
export const ContactsListResponseWebsites$inboundSchema: z.ZodType<
  ContactsListResponseWebsites,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(ContactsListResponseDataType$inboundSchema).optional(),
});

/** @internal */
export type ContactsListResponseWebsites$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const ContactsListResponseWebsites$outboundSchema: z.ZodType<
  ContactsListResponseWebsites$Outbound,
  z.ZodTypeDef,
  ContactsListResponseWebsites
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(ContactsListResponseDataType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseWebsites$ {
  /** @deprecated use `ContactsListResponseWebsites$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseWebsites$inboundSchema;
  /** @deprecated use `ContactsListResponseWebsites$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseWebsites$outboundSchema;
  /** @deprecated use `ContactsListResponseWebsites$Outbound` instead. */
  export type Outbound = ContactsListResponseWebsites$Outbound;
}

export function contactsListResponseWebsitesToJSON(
  contactsListResponseWebsites: ContactsListResponseWebsites,
): string {
  return JSON.stringify(
    ContactsListResponseWebsites$outboundSchema.parse(
      contactsListResponseWebsites,
    ),
  );
}

export function contactsListResponseWebsitesFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseWebsites, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseWebsites$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseWebsites' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseDataAddressesType$inboundSchema:
  z.ZodNativeEnum<typeof ContactsListResponseDataAddressesType> = z.nativeEnum(
    ContactsListResponseDataAddressesType,
  );

/** @internal */
export const ContactsListResponseDataAddressesType$outboundSchema:
  z.ZodNativeEnum<typeof ContactsListResponseDataAddressesType> =
    ContactsListResponseDataAddressesType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseDataAddressesType$ {
  /** @deprecated use `ContactsListResponseDataAddressesType$inboundSchema` instead. */
  export const inboundSchema =
    ContactsListResponseDataAddressesType$inboundSchema;
  /** @deprecated use `ContactsListResponseDataAddressesType$outboundSchema` instead. */
  export const outboundSchema =
    ContactsListResponseDataAddressesType$outboundSchema;
}

/** @internal */
export const ContactsListResponseAddresses$inboundSchema: z.ZodType<
  ContactsListResponseAddresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(ContactsListResponseDataAddressesType$inboundSchema)
    .optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  street_number: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postal_code: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contact_name: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phone_number: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  row_version: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "street_number": "streetNumber",
    "postal_code": "postalCode",
    "contact_name": "contactName",
    "phone_number": "phoneNumber",
    "row_version": "rowVersion",
  });
});

/** @internal */
export type ContactsListResponseAddresses$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
  string?: string | null | undefined;
  name?: string | null | undefined;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  line3?: string | null | undefined;
  line4?: string | null | undefined;
  street_number?: string | null | undefined;
  city?: string | null | undefined;
  state?: string | null | undefined;
  postal_code?: string | null | undefined;
  country?: string | null | undefined;
  latitude?: string | null | undefined;
  longitude?: string | null | undefined;
  county?: string | null | undefined;
  contact_name?: string | null | undefined;
  salutation?: string | null | undefined;
  phone_number?: string | null | undefined;
  fax?: string | null | undefined;
  email?: string | null | undefined;
  website?: string | null | undefined;
  notes?: string | null | undefined;
  row_version?: string | null | undefined;
};

/** @internal */
export const ContactsListResponseAddresses$outboundSchema: z.ZodType<
  ContactsListResponseAddresses$Outbound,
  z.ZodTypeDef,
  ContactsListResponseAddresses
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(ContactsListResponseDataAddressesType$outboundSchema)
    .optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  streetNumber: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contactName: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phoneNumber: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  rowVersion: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    streetNumber: "street_number",
    postalCode: "postal_code",
    contactName: "contact_name",
    phoneNumber: "phone_number",
    rowVersion: "row_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseAddresses$ {
  /** @deprecated use `ContactsListResponseAddresses$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseAddresses$inboundSchema;
  /** @deprecated use `ContactsListResponseAddresses$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseAddresses$outboundSchema;
  /** @deprecated use `ContactsListResponseAddresses$Outbound` instead. */
  export type Outbound = ContactsListResponseAddresses$Outbound;
}

export function contactsListResponseAddressesToJSON(
  contactsListResponseAddresses: ContactsListResponseAddresses,
): string {
  return JSON.stringify(
    ContactsListResponseAddresses$outboundSchema.parse(
      contactsListResponseAddresses,
    ),
  );
}

export function contactsListResponseAddressesFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseAddresses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseAddresses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseAddresses' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseSocialLinks$inboundSchema: z.ZodType<
  ContactsListResponseSocialLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/** @internal */
export type ContactsListResponseSocialLinks$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const ContactsListResponseSocialLinks$outboundSchema: z.ZodType<
  ContactsListResponseSocialLinks$Outbound,
  z.ZodTypeDef,
  ContactsListResponseSocialLinks
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseSocialLinks$ {
  /** @deprecated use `ContactsListResponseSocialLinks$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseSocialLinks$inboundSchema;
  /** @deprecated use `ContactsListResponseSocialLinks$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseSocialLinks$outboundSchema;
  /** @deprecated use `ContactsListResponseSocialLinks$Outbound` instead. */
  export type Outbound = ContactsListResponseSocialLinks$Outbound;
}

export function contactsListResponseSocialLinksToJSON(
  contactsListResponseSocialLinks: ContactsListResponseSocialLinks,
): string {
  return JSON.stringify(
    ContactsListResponseSocialLinks$outboundSchema.parse(
      contactsListResponseSocialLinks,
    ),
  );
}

export function contactsListResponseSocialLinksFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseSocialLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseSocialLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseSocialLinks' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseDataPhoneNumbersType$inboundSchema:
  z.ZodNativeEnum<typeof ContactsListResponseDataPhoneNumbersType> = z
    .nativeEnum(ContactsListResponseDataPhoneNumbersType);

/** @internal */
export const ContactsListResponseDataPhoneNumbersType$outboundSchema:
  z.ZodNativeEnum<typeof ContactsListResponseDataPhoneNumbersType> =
    ContactsListResponseDataPhoneNumbersType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseDataPhoneNumbersType$ {
  /** @deprecated use `ContactsListResponseDataPhoneNumbersType$inboundSchema` instead. */
  export const inboundSchema =
    ContactsListResponseDataPhoneNumbersType$inboundSchema;
  /** @deprecated use `ContactsListResponseDataPhoneNumbersType$outboundSchema` instead. */
  export const outboundSchema =
    ContactsListResponseDataPhoneNumbersType$outboundSchema;
}

/** @internal */
export const ContactsListResponsePhoneNumbers$inboundSchema: z.ZodType<
  ContactsListResponsePhoneNumbers,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  country_code: z.nullable(z.string()).optional(),
  area_code: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(ContactsListResponseDataPhoneNumbersType$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "country_code": "countryCode",
    "area_code": "areaCode",
  });
});

/** @internal */
export type ContactsListResponsePhoneNumbers$Outbound = {
  id?: string | null | undefined;
  country_code?: string | null | undefined;
  area_code?: string | null | undefined;
  number: string;
  extension?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const ContactsListResponsePhoneNumbers$outboundSchema: z.ZodType<
  ContactsListResponsePhoneNumbers$Outbound,
  z.ZodTypeDef,
  ContactsListResponsePhoneNumbers
> = z.object({
  id: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  areaCode: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(ContactsListResponseDataPhoneNumbersType$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    countryCode: "country_code",
    areaCode: "area_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponsePhoneNumbers$ {
  /** @deprecated use `ContactsListResponsePhoneNumbers$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponsePhoneNumbers$inboundSchema;
  /** @deprecated use `ContactsListResponsePhoneNumbers$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponsePhoneNumbers$outboundSchema;
  /** @deprecated use `ContactsListResponsePhoneNumbers$Outbound` instead. */
  export type Outbound = ContactsListResponsePhoneNumbers$Outbound;
}

export function contactsListResponsePhoneNumbersToJSON(
  contactsListResponsePhoneNumbers: ContactsListResponsePhoneNumbers,
): string {
  return JSON.stringify(
    ContactsListResponsePhoneNumbers$outboundSchema.parse(
      contactsListResponsePhoneNumbers,
    ),
  );
}

export function contactsListResponsePhoneNumbersFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponsePhoneNumbers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponsePhoneNumbers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponsePhoneNumbers' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseDataEmailsType$inboundSchema: z.ZodNativeEnum<
  typeof ContactsListResponseDataEmailsType
> = z.nativeEnum(ContactsListResponseDataEmailsType);

/** @internal */
export const ContactsListResponseDataEmailsType$outboundSchema: z.ZodNativeEnum<
  typeof ContactsListResponseDataEmailsType
> = ContactsListResponseDataEmailsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseDataEmailsType$ {
  /** @deprecated use `ContactsListResponseDataEmailsType$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseDataEmailsType$inboundSchema;
  /** @deprecated use `ContactsListResponseDataEmailsType$outboundSchema` instead. */
  export const outboundSchema =
    ContactsListResponseDataEmailsType$outboundSchema;
}

/** @internal */
export const ContactsListResponseEmails$inboundSchema: z.ZodType<
  ContactsListResponseEmails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(ContactsListResponseDataEmailsType$inboundSchema).optional(),
});

/** @internal */
export type ContactsListResponseEmails$Outbound = {
  id?: string | null | undefined;
  email: string | null;
  type?: string | null | undefined;
};

/** @internal */
export const ContactsListResponseEmails$outboundSchema: z.ZodType<
  ContactsListResponseEmails$Outbound,
  z.ZodTypeDef,
  ContactsListResponseEmails
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(ContactsListResponseDataEmailsType$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseEmails$ {
  /** @deprecated use `ContactsListResponseEmails$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseEmails$inboundSchema;
  /** @deprecated use `ContactsListResponseEmails$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseEmails$outboundSchema;
  /** @deprecated use `ContactsListResponseEmails$Outbound` instead. */
  export type Outbound = ContactsListResponseEmails$Outbound;
}

export function contactsListResponseEmailsToJSON(
  contactsListResponseEmails: ContactsListResponseEmails,
): string {
  return JSON.stringify(
    ContactsListResponseEmails$outboundSchema.parse(contactsListResponseEmails),
  );
}

export function contactsListResponseEmailsFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseEmails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseEmails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseEmails' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseValue6$inboundSchema: z.ZodType<
  ContactsListResponseValue6,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ContactsListResponseValue6$Outbound = {};

/** @internal */
export const ContactsListResponseValue6$outboundSchema: z.ZodType<
  ContactsListResponseValue6$Outbound,
  z.ZodTypeDef,
  ContactsListResponseValue6
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseValue6$ {
  /** @deprecated use `ContactsListResponseValue6$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseValue6$inboundSchema;
  /** @deprecated use `ContactsListResponseValue6$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseValue6$outboundSchema;
  /** @deprecated use `ContactsListResponseValue6$Outbound` instead. */
  export type Outbound = ContactsListResponseValue6$Outbound;
}

export function contactsListResponseValue6ToJSON(
  contactsListResponseValue6: ContactsListResponseValue6,
): string {
  return JSON.stringify(
    ContactsListResponseValue6$outboundSchema.parse(contactsListResponseValue6),
  );
}

export function contactsListResponseValue6FromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseValue6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseValue6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseValue6' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseValue4$inboundSchema: z.ZodType<
  ContactsListResponseValue4,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ContactsListResponseValue4$Outbound = {};

/** @internal */
export const ContactsListResponseValue4$outboundSchema: z.ZodType<
  ContactsListResponseValue4$Outbound,
  z.ZodTypeDef,
  ContactsListResponseValue4
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseValue4$ {
  /** @deprecated use `ContactsListResponseValue4$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseValue4$inboundSchema;
  /** @deprecated use `ContactsListResponseValue4$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseValue4$outboundSchema;
  /** @deprecated use `ContactsListResponseValue4$Outbound` instead. */
  export type Outbound = ContactsListResponseValue4$Outbound;
}

export function contactsListResponseValue4ToJSON(
  contactsListResponseValue4: ContactsListResponseValue4,
): string {
  return JSON.stringify(
    ContactsListResponseValue4$outboundSchema.parse(contactsListResponseValue4),
  );
}

export function contactsListResponseValue4FromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseValue4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseValue4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseValue4' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseValue$inboundSchema: z.ZodType<
  ContactsListResponseValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ContactsListResponseValue4$inboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
  z.array(z.string()),
  z.array(z.lazy(() => ContactsListResponseValue6$inboundSchema)),
]);

/** @internal */
export type ContactsListResponseValue$Outbound =
  | ContactsListResponseValue4$Outbound
  | string
  | number
  | boolean
  | Array<string>
  | Array<ContactsListResponseValue6$Outbound>;

/** @internal */
export const ContactsListResponseValue$outboundSchema: z.ZodType<
  ContactsListResponseValue$Outbound,
  z.ZodTypeDef,
  ContactsListResponseValue
> = z.union([
  z.lazy(() => ContactsListResponseValue4$outboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
  z.array(z.string()),
  z.array(z.lazy(() => ContactsListResponseValue6$outboundSchema)),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseValue$ {
  /** @deprecated use `ContactsListResponseValue$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseValue$inboundSchema;
  /** @deprecated use `ContactsListResponseValue$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseValue$outboundSchema;
  /** @deprecated use `ContactsListResponseValue$Outbound` instead. */
  export type Outbound = ContactsListResponseValue$Outbound;
}

export function contactsListResponseValueToJSON(
  contactsListResponseValue: ContactsListResponseValue,
): string {
  return JSON.stringify(
    ContactsListResponseValue$outboundSchema.parse(contactsListResponseValue),
  );
}

export function contactsListResponseValueFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseValue' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseCustomFields$inboundSchema: z.ZodType<
  ContactsListResponseCustomFields,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => ContactsListResponseValue4$inboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => ContactsListResponseValue6$inboundSchema)),
    ]),
  ).optional(),
});

/** @internal */
export type ContactsListResponseCustomFields$Outbound = {
  id: string | null;
  name?: string | null | undefined;
  description?: string | null | undefined;
  value?:
    | ContactsListResponseValue4$Outbound
    | string
    | number
    | boolean
    | Array<string>
    | Array<ContactsListResponseValue6$Outbound>
    | null
    | undefined;
};

/** @internal */
export const ContactsListResponseCustomFields$outboundSchema: z.ZodType<
  ContactsListResponseCustomFields$Outbound,
  z.ZodTypeDef,
  ContactsListResponseCustomFields
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => ContactsListResponseValue4$outboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => ContactsListResponseValue6$outboundSchema)),
    ]),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseCustomFields$ {
  /** @deprecated use `ContactsListResponseCustomFields$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseCustomFields$inboundSchema;
  /** @deprecated use `ContactsListResponseCustomFields$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseCustomFields$outboundSchema;
  /** @deprecated use `ContactsListResponseCustomFields$Outbound` instead. */
  export type Outbound = ContactsListResponseCustomFields$Outbound;
}

export function contactsListResponseCustomFieldsToJSON(
  contactsListResponseCustomFields: ContactsListResponseCustomFields,
): string {
  return JSON.stringify(
    ContactsListResponseCustomFields$outboundSchema.parse(
      contactsListResponseCustomFields,
    ),
  );
}

export function contactsListResponseCustomFieldsFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseCustomFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseCustomFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseCustomFields' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseCustomMappings$inboundSchema: z.ZodType<
  ContactsListResponseCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ContactsListResponseCustomMappings$Outbound = {};

/** @internal */
export const ContactsListResponseCustomMappings$outboundSchema: z.ZodType<
  ContactsListResponseCustomMappings$Outbound,
  z.ZodTypeDef,
  ContactsListResponseCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseCustomMappings$ {
  /** @deprecated use `ContactsListResponseCustomMappings$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseCustomMappings$inboundSchema;
  /** @deprecated use `ContactsListResponseCustomMappings$outboundSchema` instead. */
  export const outboundSchema =
    ContactsListResponseCustomMappings$outboundSchema;
  /** @deprecated use `ContactsListResponseCustomMappings$Outbound` instead. */
  export type Outbound = ContactsListResponseCustomMappings$Outbound;
}

export function contactsListResponseCustomMappingsToJSON(
  contactsListResponseCustomMappings: ContactsListResponseCustomMappings,
): string {
  return JSON.stringify(
    ContactsListResponseCustomMappings$outboundSchema.parse(
      contactsListResponseCustomMappings,
    ),
  );
}

export function contactsListResponseCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ContactsListResponseCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseCustomMappings' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseExtendPaths$inboundSchema: z.ZodType<
  ContactsListResponseExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type ContactsListResponseExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const ContactsListResponseExtendPaths$outboundSchema: z.ZodType<
  ContactsListResponseExtendPaths$Outbound,
  z.ZodTypeDef,
  ContactsListResponseExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseExtendPaths$ {
  /** @deprecated use `ContactsListResponseExtendPaths$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseExtendPaths$inboundSchema;
  /** @deprecated use `ContactsListResponseExtendPaths$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseExtendPaths$outboundSchema;
  /** @deprecated use `ContactsListResponseExtendPaths$Outbound` instead. */
  export type Outbound = ContactsListResponseExtendPaths$Outbound;
}

export function contactsListResponseExtendPathsToJSON(
  contactsListResponseExtendPaths: ContactsListResponseExtendPaths,
): string {
  return JSON.stringify(
    ContactsListResponseExtendPaths$outboundSchema.parse(
      contactsListResponseExtendPaths,
    ),
  );
}

export function contactsListResponseExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseExtendPaths' from JSON`,
  );
}

/** @internal */
export const ContactsListResponsePassThrough$inboundSchema: z.ZodType<
  ContactsListResponsePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => ContactsListResponseExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type ContactsListResponsePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<ContactsListResponseExtendPaths$Outbound> | undefined;
};

/** @internal */
export const ContactsListResponsePassThrough$outboundSchema: z.ZodType<
  ContactsListResponsePassThrough$Outbound,
  z.ZodTypeDef,
  ContactsListResponsePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => ContactsListResponseExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponsePassThrough$ {
  /** @deprecated use `ContactsListResponsePassThrough$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponsePassThrough$inboundSchema;
  /** @deprecated use `ContactsListResponsePassThrough$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponsePassThrough$outboundSchema;
  /** @deprecated use `ContactsListResponsePassThrough$Outbound` instead. */
  export type Outbound = ContactsListResponsePassThrough$Outbound;
}

export function contactsListResponsePassThroughToJSON(
  contactsListResponsePassThrough: ContactsListResponsePassThrough,
): string {
  return JSON.stringify(
    ContactsListResponsePassThrough$outboundSchema.parse(
      contactsListResponsePassThrough,
    ),
  );
}

export function contactsListResponsePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponsePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponsePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponsePassThrough' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseData$inboundSchema: z.ZodType<
  ContactsListResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  name: z.nullable(z.string()),
  owner_id: z.nullable(z.string()).optional(),
  type: z.nullable(ContactsListResponseType$inboundSchema).optional(),
  company_id: z.nullable(z.string()).optional(),
  company_name: z.nullable(z.string()).optional(),
  lead_id: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  middle_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  prefix: z.nullable(z.string()).optional(),
  suffix: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  gender: z.nullable(ContactsListResponseGender$inboundSchema).optional(),
  birthday: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  photo_url: z.nullable(z.string()).optional(),
  lead_source: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  current_balance: z.nullable(z.number()).optional(),
  status: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  websites: z.array(z.lazy(() => ContactsListResponseWebsites$inboundSchema))
    .optional(),
  addresses: z.array(z.lazy(() => ContactsListResponseAddresses$inboundSchema))
    .optional(),
  social_links: z.array(
    z.lazy(() => ContactsListResponseSocialLinks$inboundSchema),
  ).optional(),
  phone_numbers: z.array(
    z.lazy(() => ContactsListResponsePhoneNumbers$inboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => ContactsListResponseEmails$inboundSchema))
    .optional(),
  email_domain: z.nullable(z.string()).optional(),
  custom_fields: z.array(
    z.lazy(() => ContactsListResponseCustomFields$inboundSchema),
  ).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  first_call_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  first_email_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  last_activity_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  custom_mappings: z.nullable(
    z.lazy(() => ContactsListResponseCustomMappings$inboundSchema),
  ).optional(),
  updated_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  created_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  opportunity_ids: z.array(z.string()).optional(),
  pass_through: z.array(
    z.lazy(() => ContactsListResponsePassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "company_id": "companyId",
    "company_name": "companyName",
    "lead_id": "leadId",
    "first_name": "firstName",
    "middle_name": "middleName",
    "last_name": "lastName",
    "photo_url": "photoUrl",
    "lead_source": "leadSource",
    "current_balance": "currentBalance",
    "social_links": "socialLinks",
    "phone_numbers": "phoneNumbers",
    "email_domain": "emailDomain",
    "custom_fields": "customFields",
    "first_call_at": "firstCallAt",
    "first_email_at": "firstEmailAt",
    "last_activity_at": "lastActivityAt",
    "custom_mappings": "customMappings",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "opportunity_ids": "opportunityIds",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type ContactsListResponseData$Outbound = {
  id?: string | undefined;
  name: string | null;
  owner_id?: string | null | undefined;
  type?: string | null | undefined;
  company_id?: string | null | undefined;
  company_name?: string | null | undefined;
  lead_id?: string | null | undefined;
  first_name?: string | null | undefined;
  middle_name?: string | null | undefined;
  last_name?: string | null | undefined;
  prefix?: string | null | undefined;
  suffix?: string | null | undefined;
  title?: string | null | undefined;
  department?: string | null | undefined;
  language?: string | null | undefined;
  gender?: string | null | undefined;
  birthday?: string | null | undefined;
  image?: string | null | undefined;
  photo_url?: string | null | undefined;
  lead_source?: string | null | undefined;
  fax?: string | null | undefined;
  description?: string | null | undefined;
  current_balance?: number | null | undefined;
  status?: string | null | undefined;
  active?: boolean | null | undefined;
  websites?: Array<ContactsListResponseWebsites$Outbound> | undefined;
  addresses?: Array<ContactsListResponseAddresses$Outbound> | undefined;
  social_links?: Array<ContactsListResponseSocialLinks$Outbound> | undefined;
  phone_numbers?: Array<ContactsListResponsePhoneNumbers$Outbound> | undefined;
  emails?: Array<ContactsListResponseEmails$Outbound> | undefined;
  email_domain?: string | null | undefined;
  custom_fields?: Array<ContactsListResponseCustomFields$Outbound> | undefined;
  tags?: Array<string> | null | undefined;
  first_call_at?: string | null | undefined;
  first_email_at?: string | null | undefined;
  last_activity_at?: string | null | undefined;
  custom_mappings?:
    | ContactsListResponseCustomMappings$Outbound
    | null
    | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  opportunity_ids?: Array<string> | undefined;
  pass_through?: Array<ContactsListResponsePassThrough$Outbound> | undefined;
};

/** @internal */
export const ContactsListResponseData$outboundSchema: z.ZodType<
  ContactsListResponseData$Outbound,
  z.ZodTypeDef,
  ContactsListResponseData
> = z.object({
  id: z.string().optional(),
  name: z.nullable(z.string()),
  ownerId: z.nullable(z.string()).optional(),
  type: z.nullable(ContactsListResponseType$outboundSchema).optional(),
  companyId: z.nullable(z.string()).optional(),
  companyName: z.nullable(z.string()).optional(),
  leadId: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  middleName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  prefix: z.nullable(z.string()).optional(),
  suffix: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  gender: z.nullable(ContactsListResponseGender$outboundSchema).optional(),
  birthday: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  photoUrl: z.nullable(z.string()).optional(),
  leadSource: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  currentBalance: z.nullable(z.number()).optional(),
  status: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  websites: z.array(z.lazy(() => ContactsListResponseWebsites$outboundSchema))
    .optional(),
  addresses: z.array(z.lazy(() => ContactsListResponseAddresses$outboundSchema))
    .optional(),
  socialLinks: z.array(
    z.lazy(() => ContactsListResponseSocialLinks$outboundSchema),
  ).optional(),
  phoneNumbers: z.array(
    z.lazy(() => ContactsListResponsePhoneNumbers$outboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => ContactsListResponseEmails$outboundSchema))
    .optional(),
  emailDomain: z.nullable(z.string()).optional(),
  customFields: z.array(
    z.lazy(() => ContactsListResponseCustomFields$outboundSchema),
  ).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  firstCallAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  firstEmailAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  lastActivityAt: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  customMappings: z.nullable(
    z.lazy(() => ContactsListResponseCustomMappings$outboundSchema),
  ).optional(),
  updatedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  createdAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  opportunityIds: z.array(z.string()).optional(),
  passThrough: z.array(
    z.lazy(() => ContactsListResponsePassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    companyId: "company_id",
    companyName: "company_name",
    leadId: "lead_id",
    firstName: "first_name",
    middleName: "middle_name",
    lastName: "last_name",
    photoUrl: "photo_url",
    leadSource: "lead_source",
    currentBalance: "current_balance",
    socialLinks: "social_links",
    phoneNumbers: "phone_numbers",
    emailDomain: "email_domain",
    customFields: "custom_fields",
    firstCallAt: "first_call_at",
    firstEmailAt: "first_email_at",
    lastActivityAt: "last_activity_at",
    customMappings: "custom_mappings",
    updatedAt: "updated_at",
    createdAt: "created_at",
    opportunityIds: "opportunity_ids",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseData$ {
  /** @deprecated use `ContactsListResponseData$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseData$inboundSchema;
  /** @deprecated use `ContactsListResponseData$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseData$outboundSchema;
  /** @deprecated use `ContactsListResponseData$Outbound` instead. */
  export type Outbound = ContactsListResponseData$Outbound;
}

export function contactsListResponseDataToJSON(
  contactsListResponseData: ContactsListResponseData,
): string {
  return JSON.stringify(
    ContactsListResponseData$outboundSchema.parse(contactsListResponseData),
  );
}

export function contactsListResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseData' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseCursors$inboundSchema: z.ZodType<
  ContactsListResponseCursors,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type ContactsListResponseCursors$Outbound = {
  previous?: string | null | undefined;
  current?: string | null | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const ContactsListResponseCursors$outboundSchema: z.ZodType<
  ContactsListResponseCursors$Outbound,
  z.ZodTypeDef,
  ContactsListResponseCursors
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseCursors$ {
  /** @deprecated use `ContactsListResponseCursors$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseCursors$inboundSchema;
  /** @deprecated use `ContactsListResponseCursors$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseCursors$outboundSchema;
  /** @deprecated use `ContactsListResponseCursors$Outbound` instead. */
  export type Outbound = ContactsListResponseCursors$Outbound;
}

export function contactsListResponseCursorsToJSON(
  contactsListResponseCursors: ContactsListResponseCursors,
): string {
  return JSON.stringify(
    ContactsListResponseCursors$outboundSchema.parse(
      contactsListResponseCursors,
    ),
  );
}

export function contactsListResponseCursorsFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseCursors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseCursors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseCursors' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseMeta$inboundSchema: z.ZodType<
  ContactsListResponseMeta,
  z.ZodTypeDef,
  unknown
> = z.object({
  items_on_page: z.number().int().optional(),
  cursors: z.lazy(() => ContactsListResponseCursors$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "items_on_page": "itemsOnPage",
  });
});

/** @internal */
export type ContactsListResponseMeta$Outbound = {
  items_on_page?: number | undefined;
  cursors?: ContactsListResponseCursors$Outbound | undefined;
};

/** @internal */
export const ContactsListResponseMeta$outboundSchema: z.ZodType<
  ContactsListResponseMeta$Outbound,
  z.ZodTypeDef,
  ContactsListResponseMeta
> = z.object({
  itemsOnPage: z.number().int().optional(),
  cursors: z.lazy(() => ContactsListResponseCursors$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    itemsOnPage: "items_on_page",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseMeta$ {
  /** @deprecated use `ContactsListResponseMeta$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseMeta$inboundSchema;
  /** @deprecated use `ContactsListResponseMeta$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseMeta$outboundSchema;
  /** @deprecated use `ContactsListResponseMeta$Outbound` instead. */
  export type Outbound = ContactsListResponseMeta$Outbound;
}

export function contactsListResponseMetaToJSON(
  contactsListResponseMeta: ContactsListResponseMeta,
): string {
  return JSON.stringify(
    ContactsListResponseMeta$outboundSchema.parse(contactsListResponseMeta),
  );
}

export function contactsListResponseMetaFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseMeta, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseMeta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseMeta' from JSON`,
  );
}

/** @internal */
export const ContactsListResponseLinks$inboundSchema: z.ZodType<
  ContactsListResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type ContactsListResponseLinks$Outbound = {
  previous?: string | null | undefined;
  current?: string | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const ContactsListResponseLinks$outboundSchema: z.ZodType<
  ContactsListResponseLinks$Outbound,
  z.ZodTypeDef,
  ContactsListResponseLinks
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponseLinks$ {
  /** @deprecated use `ContactsListResponseLinks$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponseLinks$inboundSchema;
  /** @deprecated use `ContactsListResponseLinks$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponseLinks$outboundSchema;
  /** @deprecated use `ContactsListResponseLinks$Outbound` instead. */
  export type Outbound = ContactsListResponseLinks$Outbound;
}

export function contactsListResponseLinksToJSON(
  contactsListResponseLinks: ContactsListResponseLinks,
): string {
  return JSON.stringify(
    ContactsListResponseLinks$outboundSchema.parse(contactsListResponseLinks),
  );
}

export function contactsListResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponseLinks' from JSON`,
  );
}

/** @internal */
export const ContactsListResponse$inboundSchema: z.ZodType<
  ContactsListResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => ContactsListResponseData$inboundSchema)),
  meta: z.lazy(() => ContactsListResponseMeta$inboundSchema).optional(),
  links: z.lazy(() => ContactsListResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type ContactsListResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: Array<ContactsListResponseData$Outbound>;
  meta?: ContactsListResponseMeta$Outbound | undefined;
  links?: ContactsListResponseLinks$Outbound | undefined;
};

/** @internal */
export const ContactsListResponse$outboundSchema: z.ZodType<
  ContactsListResponse$Outbound,
  z.ZodTypeDef,
  ContactsListResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => ContactsListResponseData$outboundSchema)),
  meta: z.lazy(() => ContactsListResponseMeta$outboundSchema).optional(),
  links: z.lazy(() => ContactsListResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContactsListResponse$ {
  /** @deprecated use `ContactsListResponse$inboundSchema` instead. */
  export const inboundSchema = ContactsListResponse$inboundSchema;
  /** @deprecated use `ContactsListResponse$outboundSchema` instead. */
  export const outboundSchema = ContactsListResponse$outboundSchema;
  /** @deprecated use `ContactsListResponse$Outbound` instead. */
  export type Outbound = ContactsListResponse$Outbound;
}

export function contactsListResponseToJSON(
  contactsListResponse: ContactsListResponse,
): string {
  return JSON.stringify(
    ContactsListResponse$outboundSchema.parse(contactsListResponse),
  );
}

export function contactsListResponseFromJSON(
  jsonString: string,
): SafeParseResult<ContactsListResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactsListResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactsListResponse' from JSON`,
  );
}

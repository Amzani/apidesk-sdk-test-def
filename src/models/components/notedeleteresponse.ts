/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The root object containing all relevant information about the note deletion operation. This object encapsulates the details of the response, ensuring that the consumer receives a structured and comprehensive result. It is always included in the response to provide a consistent format, even if the operation does not return additional data beyond confirmation of deletion.
 */
export type NoteDeleteResponseUnifiedId = {
  /**
   * The 'data.id' field represents the unique identifier of the user resource that has been updated. This identifier is crucial for confirming that the correct user record was modified. It is always included in the response to ensure that the client can verify the specific user record that was affected by the update operation.
   */
  id: string;
};

/**
 * Note deleted
 */
export type NoteDeleteResponse = {
  /**
   * The HTTP response status code returned by the server. This integer value indicates the result of the DELETE operation, with a 200 status code signifying successful deletion of the specified note. It is always included in the response to inform the client about the outcome of their request.
   */
  statusCode: number;
  /**
   * A textual representation of the HTTP response status. This string provides a human-readable explanation of the status code, such as 'OK' for a successful operation. It is included to give a clear indication of the request's result, complementing the numeric status code.
   */
  status: string;
  /**
   * The Apideck ID of the service provider involved in the operation. This string identifies which service within the Apideck ecosystem processed the DELETE request, especially useful when multiple services are integrated. It is always included to ensure clarity about the source of the response.
   */
  service: string;
  /**
   * The name of the Unified API resource that was targeted by the operation. This string specifies the type of resource, such as 'note', that the DELETE request was performed on. It is included to confirm the specific resource affected by the operation, ensuring the client knows exactly what was deleted.
   */
  resource: string;
  /**
   * The specific operation performed by the API, in this case, 'delete'. This string indicates the action taken on the resource, confirming that the request was to remove a note. It is always included to provide a clear record of the action executed by the API.
   */
  operation: string;
  /**
   * The root object containing all relevant information about the note deletion operation. This object encapsulates the details of the response, ensuring that the consumer receives a structured and comprehensive result. It is always included in the response to provide a consistent format, even if the operation does not return additional data beyond confirmation of deletion.
   */
  data: NoteDeleteResponseUnifiedId;
};

/** @internal */
export const NoteDeleteResponseUnifiedId$inboundSchema: z.ZodType<
  NoteDeleteResponseUnifiedId,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

/** @internal */
export type NoteDeleteResponseUnifiedId$Outbound = {
  id: string;
};

/** @internal */
export const NoteDeleteResponseUnifiedId$outboundSchema: z.ZodType<
  NoteDeleteResponseUnifiedId$Outbound,
  z.ZodTypeDef,
  NoteDeleteResponseUnifiedId
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteDeleteResponseUnifiedId$ {
  /** @deprecated use `NoteDeleteResponseUnifiedId$inboundSchema` instead. */
  export const inboundSchema = NoteDeleteResponseUnifiedId$inboundSchema;
  /** @deprecated use `NoteDeleteResponseUnifiedId$outboundSchema` instead. */
  export const outboundSchema = NoteDeleteResponseUnifiedId$outboundSchema;
  /** @deprecated use `NoteDeleteResponseUnifiedId$Outbound` instead. */
  export type Outbound = NoteDeleteResponseUnifiedId$Outbound;
}

export function noteDeleteResponseUnifiedIdToJSON(
  noteDeleteResponseUnifiedId: NoteDeleteResponseUnifiedId,
): string {
  return JSON.stringify(
    NoteDeleteResponseUnifiedId$outboundSchema.parse(
      noteDeleteResponseUnifiedId,
    ),
  );
}

export function noteDeleteResponseUnifiedIdFromJSON(
  jsonString: string,
): SafeParseResult<NoteDeleteResponseUnifiedId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteDeleteResponseUnifiedId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteDeleteResponseUnifiedId' from JSON`,
  );
}

/** @internal */
export const NoteDeleteResponse$inboundSchema: z.ZodType<
  NoteDeleteResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => NoteDeleteResponseUnifiedId$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type NoteDeleteResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: NoteDeleteResponseUnifiedId$Outbound;
};

/** @internal */
export const NoteDeleteResponse$outboundSchema: z.ZodType<
  NoteDeleteResponse$Outbound,
  z.ZodTypeDef,
  NoteDeleteResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => NoteDeleteResponseUnifiedId$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteDeleteResponse$ {
  /** @deprecated use `NoteDeleteResponse$inboundSchema` instead. */
  export const inboundSchema = NoteDeleteResponse$inboundSchema;
  /** @deprecated use `NoteDeleteResponse$outboundSchema` instead. */
  export const outboundSchema = NoteDeleteResponse$outboundSchema;
  /** @deprecated use `NoteDeleteResponse$Outbound` instead. */
  export type Outbound = NoteDeleteResponse$Outbound;
}

export function noteDeleteResponseToJSON(
  noteDeleteResponse: NoteDeleteResponse,
): string {
  return JSON.stringify(
    NoteDeleteResponse$outboundSchema.parse(noteDeleteResponse),
  );
}

export function noteDeleteResponseFromJSON(
  jsonString: string,
): SafeParseResult<NoteDeleteResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteDeleteResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteDeleteResponse' from JSON`,
  );
}

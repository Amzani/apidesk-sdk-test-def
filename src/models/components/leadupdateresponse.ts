/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The root object containing all the updated lead information. This object is always included in the response to encapsulate the lead's data that has been modified. It serves as the primary container for all fields that have been successfully updated during the operation, reflecting the current state of the lead after the PATCH request is processed.
 */
export type LeadUpdateResponseUnifiedId = {
  /**
   * The 'data.id' field represents the unique identifier of the user resource that has been updated. This identifier is crucial for confirming that the correct user record was modified. It is always included in the response to ensure that the client can verify the specific user record that was affected by the update operation.
   */
  id: string;
};

/**
 * Lead updated
 */
export type LeadUpdateResponse = {
  /**
   * The HTTP response status code returned by the server. This integer value indicates the result of the PATCH request to update a lead. A status code of 200 signifies a successful update, while other codes may indicate errors or issues with the request, such as 400 for a bad request or 404 if the lead ID is not found. This code is crucial for determining the outcome of the operation and handling responses programmatically.
   */
  statusCode: number;
  /**
   * A textual representation of the HTTP response status. This string provides a human-readable explanation of the status code, such as 'OK' for a successful update or 'Not Found' if the specified lead ID does not exist. It complements the status code by offering a more descriptive context, which is useful for logging and debugging purposes.
   */
  status: string;
  /**
   * The Apideck ID of the service provider involved in the operation. This string identifies which third-party service (e.g., Pipedrive) was targeted by the update request. It is included in the response to confirm the specific integration that processed the request, especially important when multiple services are connected.
   */
  service: string;
  /**
   * The name of the unified API resource that was accessed or modified. This string indicates the type of resource, such as 'lead', that the operation was performed on. It helps in understanding the context of the API call and ensuring that the correct resource was targeted during the update process.
   */
  resource: string;
  /**
   * The specific operation that was performed on the resource. This string describes the action taken, such as 'update', and confirms the type of modification applied to the lead. It is included in the response to provide clarity on what change was executed, aiding in tracking and auditing API interactions.
   */
  operation: string;
  /**
   * The root object containing all the updated lead information. This object is always included in the response to encapsulate the lead's data that has been modified. It serves as the primary container for all fields that have been successfully updated during the operation, reflecting the current state of the lead after the PATCH request is processed.
   */
  data: LeadUpdateResponseUnifiedId;
};

/** @internal */
export const LeadUpdateResponseUnifiedId$inboundSchema: z.ZodType<
  LeadUpdateResponseUnifiedId,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

/** @internal */
export type LeadUpdateResponseUnifiedId$Outbound = {
  id: string;
};

/** @internal */
export const LeadUpdateResponseUnifiedId$outboundSchema: z.ZodType<
  LeadUpdateResponseUnifiedId$Outbound,
  z.ZodTypeDef,
  LeadUpdateResponseUnifiedId
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadUpdateResponseUnifiedId$ {
  /** @deprecated use `LeadUpdateResponseUnifiedId$inboundSchema` instead. */
  export const inboundSchema = LeadUpdateResponseUnifiedId$inboundSchema;
  /** @deprecated use `LeadUpdateResponseUnifiedId$outboundSchema` instead. */
  export const outboundSchema = LeadUpdateResponseUnifiedId$outboundSchema;
  /** @deprecated use `LeadUpdateResponseUnifiedId$Outbound` instead. */
  export type Outbound = LeadUpdateResponseUnifiedId$Outbound;
}

export function leadUpdateResponseUnifiedIdToJSON(
  leadUpdateResponseUnifiedId: LeadUpdateResponseUnifiedId,
): string {
  return JSON.stringify(
    LeadUpdateResponseUnifiedId$outboundSchema.parse(
      leadUpdateResponseUnifiedId,
    ),
  );
}

export function leadUpdateResponseUnifiedIdFromJSON(
  jsonString: string,
): SafeParseResult<LeadUpdateResponseUnifiedId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadUpdateResponseUnifiedId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadUpdateResponseUnifiedId' from JSON`,
  );
}

/** @internal */
export const LeadUpdateResponse$inboundSchema: z.ZodType<
  LeadUpdateResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => LeadUpdateResponseUnifiedId$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type LeadUpdateResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: LeadUpdateResponseUnifiedId$Outbound;
};

/** @internal */
export const LeadUpdateResponse$outboundSchema: z.ZodType<
  LeadUpdateResponse$Outbound,
  z.ZodTypeDef,
  LeadUpdateResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => LeadUpdateResponseUnifiedId$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LeadUpdateResponse$ {
  /** @deprecated use `LeadUpdateResponse$inboundSchema` instead. */
  export const inboundSchema = LeadUpdateResponse$inboundSchema;
  /** @deprecated use `LeadUpdateResponse$outboundSchema` instead. */
  export const outboundSchema = LeadUpdateResponse$outboundSchema;
  /** @deprecated use `LeadUpdateResponse$Outbound` instead. */
  export type Outbound = LeadUpdateResponse$Outbound;
}

export function leadUpdateResponseToJSON(
  leadUpdateResponse: LeadUpdateResponse,
): string {
  return JSON.stringify(
    LeadUpdateResponse$outboundSchema.parse(leadUpdateResponse),
  );
}

export function leadUpdateResponseFromJSON(
  jsonString: string,
): SafeParseResult<LeadUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LeadUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LeadUpdateResponse' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Indicates the type of address, such as 'home', 'work', or 'billing'. This string helps categorize the address for better organization and retrieval within the user's profile.
 */
export const GetUserResponseType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Office: "office",
  Shipping: "shipping",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Indicates the type of address, such as 'home', 'work', or 'billing'. This string helps categorize the address for better organization and retrieval within the user's profile.
 */
export type GetUserResponseType = ClosedEnum<typeof GetUserResponseType>;

export type GetUserResponseAddresses = {
  /**
   * A unique string identifier for each address in the user's address list. This ID is used to distinguish between different addresses and is crucial for operations that require address-specific actions, such as updates or deletions.
   */
  id?: string | null | undefined;
  /**
   * Indicates the type of address, such as 'home', 'work', or 'billing'. This string helps categorize the address for better organization and retrieval within the user's profile.
   */
  type?: GetUserResponseType | null | undefined;
  /**
   * The full address as a single string, which may include street, city, state, and postal code. This format is used when structured address data is unavailable, providing a complete address in a single field for display or processing purposes.
   */
  string?: string | null | undefined;
  /**
   * The name associated with the address entry, typically used to identify the location or recipient. This is a descriptive label and may include names like 'Home', 'Office', or 'Billing'. It is returned as a string and can be used to differentiate between multiple addresses in the user's profile.
   */
  name?: string | null | undefined;
  /**
   * The primary line of the address, which includes essential details such as the street number, street name, and any apartment or suite numbers. This string is crucial for identifying the exact location and is often required for mailing and delivery purposes.
   */
  line1?: string | null | undefined;
  /**
   * An additional line for the address, often used for supplementary information like building names, floor numbers, or other relevant details. This string provides extra context to ensure accurate delivery or identification of the address.
   */
  line2?: string | null | undefined;
  /**
   * A third line available for further address details, which can include additional instructions or identifiers not covered in the first two lines. This string helps in providing a complete address when necessary.
   */
  line3?: string | null | undefined;
  /**
   * A fourth line for any remaining address information, allowing for comprehensive address descriptions. This string is useful for complex addresses that require more detail than usual.
   */
  line4?: string | null | undefined;
  /**
   * The street number component of the user's address. This is typically a numeric value but may include letters or special characters, depending on the address format. It is part of the detailed address information returned for the user, aiding in precise location identification.
   */
  streetNumber?: string | null | undefined;
  /**
   * The city name where the user resides. This string value represents the locality within the user's address and is crucial for geographical identification and any location-based services.
   */
  city?: string | null | undefined;
  /**
   * The state or region name associated with the user's address. This property helps in identifying the broader administrative area within which the user's city is located, useful for regional segmentation and analysis.
   */
  state?: string | null | undefined;
  /**
   * The postal code or ZIP code for the user's address. This alphanumeric string is used for mail delivery purposes and helps in pinpointing the user's exact location within a city or region.
   */
  postalCode?: string | null | undefined;
  /**
   * The country code of the user's address, formatted according to the ISO 3166-1 alpha-2 standard. This two-letter code is essential for internationalization and understanding the user's national context.
   */
  country?: string | null | undefined;
  /**
   * The latitude coordinate of the user's address, represented as a string. This value is part of the geographical data used to pinpoint the exact location of the address on a map. It is useful for applications that require location-based services or mapping features.
   */
  latitude?: string | null | undefined;
  /**
   * The longitude coordinate of the user's address, represented as a string. This value complements the latitude to provide precise geographical positioning of the address. It is essential for applications that involve geolocation services or mapping.
   */
  longitude?: string | null | undefined;
  /**
   * The county or sublocality associated with the user's address, provided as a string. This field helps in identifying the administrative region of the address, which can be important for regional analysis or services that are county-specific.
   */
  county?: string | null | undefined;
  /**
   * The full name of the contact person associated with the user's address, stored as a string. This information is useful for personalizing communications or for contact verification purposes when dealing with address-related queries.
   */
  contactName?: string | null | undefined;
  /**
   * The salutation or title used for the contact person at the user's address, such as 'Mr.', 'Ms.', or 'Dr.', provided as a string. This field is used to ensure respectful and appropriate communication with the contact person.
   */
  salutation?: string | null | undefined;
  /**
   * Contains the phone number associated with the user's address. This string may include country and area codes, formatted according to international dialing standards. Useful for applications that need to display or contact the user via phone.
   */
  phoneNumber?: string | null | undefined;
  /**
   * Holds the fax number linked to the user's address. The format is typically a string that includes any necessary country and area codes. This is relevant for systems that still utilize fax communication for document transmission.
   */
  fax?: string | null | undefined;
  /**
   * Represents the email address associated with the user's address. This string should be a valid email format, ensuring it can be used for electronic communication. Essential for applications that send notifications or require email verification.
   */
  email?: string | null | undefined;
  /**
   * The website URL related to the user's address, provided as a string. This should be a fully qualified URL, including the protocol (e.g., http:// or https://). Useful for linking to the user's personal or business web page.
   */
  website?: string | null | undefined;
  /**
   * Additional notes or comments about the user's address, stored as a string. This field can include any extra information that might be relevant for understanding the context or specifics of the address. Helpful for CRM users who need to record observations or special instructions.
   */
  notes?: string | null | undefined;
  /**
   * This property contains a versioning string used to track changes to the user's address data. It is a binary value that increments with each update, ensuring that applications can detect and handle concurrent modifications effectively. This helps maintain data integrity by preventing conflicts during updates.
   */
  rowVersion?: string | null | undefined;
};

/**
 * Specifies the type of phone number, such as 'mobile', 'home', or 'work'. This string helps categorize the phone number for better organization and contact management.
 */
export const GetUserResponseDataType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Work: "work",
  Office: "office",
  Mobile: "mobile",
  Assistant: "assistant",
  Fax: "fax",
  DirectDialIn: "direct-dial-in",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * Specifies the type of phone number, such as 'mobile', 'home', or 'work'. This string helps categorize the phone number for better organization and contact management.
 */
export type GetUserResponseDataType = ClosedEnum<
  typeof GetUserResponseDataType
>;

export type GetUserResponsePhoneNumbers = {
  /**
   * A unique identifier for each phone number associated with the user. This ID is used to reference specific phone numbers within the user's profile.
   */
  id?: string | null | undefined;
  /**
   * The international dialing code for the phone number, represented as a string (e.g., '+1' for the United States). This code is crucial for making international calls and is part of the complete phone number format.
   */
  countryCode?: string | null | undefined;
  /**
   * The local area code for the phone number, provided as a string (e.g., '323' for a Los Angeles number). This code helps identify the specific geographic region of the phone number within a country.
   */
  areaCode?: string | null | undefined;
  /**
   * The user's primary phone number as recorded in the CRM. This is a mandatory field and is always returned as a string. It is used for direct communication with the user and may be formatted according to international standards.
   */
  number: string;
  /**
   * An optional extension number associated with the user's phone number. This string value is used in systems where direct dialing to specific departments or individuals is supported.
   */
  extension?: string | null | undefined;
  /**
   * Specifies the type of phone number, such as 'mobile', 'home', or 'work'. This string helps categorize the phone number for better organization and contact management.
   */
  type?: GetUserResponseDataType | null | undefined;
};

/**
 * Specifies the type of email address, such as 'work', 'personal', or 'other'. This field is optional and may not be present if the email type is not specified in the user's profile.
 */
export const GetUserResponseDataEmailsType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the type of email address, such as 'work', 'personal', or 'other'. This field is optional and may not be present if the email type is not specified in the user's profile.
 */
export type GetUserResponseDataEmailsType = ClosedEnum<
  typeof GetUserResponseDataEmailsType
>;

export type GetUserResponseEmails = {
  /**
   * A unique identifier for each email address associated with the user. This string is used to distinguish between multiple email entries and is crucial for managing user contact information efficiently.
   */
  id?: string | null | undefined;
  /**
   * The primary email address associated with the user account. This is a required field and is always returned as a non-empty string. It is used for user identification and communication purposes within the CRM system.
   */
  email: string | null;
  /**
   * Specifies the type of email address, such as 'work', 'personal', or 'other'. This field is optional and may not be present if the email type is not specified in the user's profile.
   */
  type?: GetUserResponseDataEmailsType | null | undefined;
};

/**
 * An object containing any custom mappings configured for the user resource. This field is included only when custom mappings are set up, allowing for additional user-specific data to be retrieved and utilized.
 */
export type GetUserResponseCustomMappings = {};

export type GetUserResponseExtendPaths = {
  /**
   * This property contains a JSONPath string that specifies the exact location within the user's data structure where a particular value should be applied. It is essential for pinpointing the precise path in complex nested data, ensuring that updates or retrievals are accurately targeted. The format follows standard JSONPath notation, which is crucial for developers working with dynamic data structures.
   */
  path: string;
  /**
   * This property holds the value that is to be set at the specified JSONPath within the user's data. The value can be of any data type, including string, number, object, or array, depending on the context of the data being manipulated. This flexibility allows developers to dynamically update user information with precision, ensuring that the correct data type is applied at the designated path.
   */
  value?: any | undefined;
};

export type GetUserResponsePassThrough = {
  /**
   * A string identifier for the specific service to which the pass_through data should be applied. This ensures that the custom data is directed to the correct service when retrieving user information.
   */
  serviceId: string;
  /**
   * An optional string identifier for a specific workflow operation. This is useful when the user data retrieval involves multiple downstream requests, allowing for precise operation targeting.
   */
  operationId?: string | undefined;
  /**
   * An object that allows for direct extension with any properties. This is used to include additional, non-standard data fields in the user details response, providing flexibility in data representation.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects used for structured data modifications via paths. This allows for precise alterations to the user data structure, enabling customized data retrieval based on specific paths.
   */
  extendPaths?: Array<GetUserResponseExtendPaths> | undefined;
};

/**
 * The main container object that holds all the detailed information about the user. This object includes various properties such as the user's ID, username, and personal details. It is the primary structure returned in the response, encapsulating all user-specific data.
 */
export type GetUserResponseData = {
  /**
   * A unique string identifier assigned to each user within the CRM system. This ID is crucial for referencing the user in subsequent API calls or database queries. It is typically a non-empty string that uniquely distinguishes the user from others.
   */
  id?: string | undefined;
  /**
   * The unique identifier of the parent user, if applicable. This field is used in scenarios where users are organized hierarchically, such as in a team or organizational structure. It helps in identifying the immediate superior or associated parent user.
   */
  parentId?: string | null | undefined;
  /**
   * The username associated with the user, used for login and identification purposes within the CRM. This is typically a unique string that users select or are assigned, and it is essential for authentication and user management processes.
   */
  username?: string | null | undefined;
  /**
   * The first name of the user as recorded in the CRM. This string value is used for personalization and display purposes in user interfaces and communications. It is part of the user's personal information profile.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the user as recorded in the CRM system. This field is optional and may be empty if not provided during user creation. It is used in conjunction with the first name to identify the user in reports and communications.
   */
  lastName?: string | null | undefined;
  /**
   * The professional job title of the user within their organization. This string field provides insight into the user's role and responsibilities and is useful for categorizing users in the CRM system.
   */
  title?: string | null | undefined;
  /**
   * The division within the company where the user is currently assigned. This field helps in organizing users into larger business units, which may encompass multiple departments or teams. It is useful for understanding the user's organizational context.
   */
  division?: string | null | undefined;
  /**
   * The specific department where the user is currently working. This field is deprecated in favor of using 'department_id' and 'department_name' for more precise identification. It may still appear in responses for backward compatibility.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  department?: string | null | undefined;
  /**
   * The name of the company that employs the user. This field is a string and provides the official business name as recorded in the CRM, helping to associate the user with their employer.
   */
  companyName?: string | null | undefined;
  /**
   * This property contains the unique identifier assigned to each employee within the company, such as an Employee Number, Employee ID, or Employee Code. It is typically a string of alphanumeric characters and is used to uniquely identify staff members in the CRM system. This field is optional and may not be present for all users.
   */
  employeeNumber?: string | null | undefined;
  /**
   * This property provides a textual description of the user object, offering additional context or notes about the user. It is a free-form string that can include any relevant information that helps in understanding the user's profile or role within the organization. This field is optional and may vary in content.
   */
  description?: string | null | undefined;
  /**
   * This property contains the URL of the user's avatar image, which is typically a link to an image file hosted online. The URL is a string that can be used to display the user's profile picture in applications or user interfaces. This field is optional and may not be available for all users.
   */
  image?: string | null | undefined;
  /**
   * This property specifies the user's preferred language using the ISO 639-1 language code format, such as 'EN' for English. It indicates the language settings for the user, which can be used to tailor content and communications to their preferences. This field is optional and may not be set for all users.
   */
  language?: string | null | undefined;
  /**
   * This property indicates the current status of the user within the CRM system, such as 'active', 'inactive', or other status indicators. It is a string that helps determine the user's availability or role status in the system. This field is optional and may vary depending on the user's current state.
   */
  status?: string | null | undefined;
  /**
   * An array containing the user's addresses. Each entry in the array represents a distinct address associated with the user, which may include home, work, or other types of addresses. This array can be empty if no addresses are recorded for the user.
   */
  addresses?: Array<GetUserResponseAddresses> | undefined;
  /**
   * An array containing the user's phone numbers, each represented as an object with detailed information such as ID, country code, and area code. This array can be empty if no phone numbers are associated with the user.
   */
  phoneNumbers?: Array<GetUserResponsePhoneNumbers> | undefined;
  /**
   * A list of email addresses associated with the user. This array contains objects detailing each email, ensuring comprehensive contact information is available for communication purposes.
   */
  emails: Array<GetUserResponseEmails>;
  /**
   * An object containing any custom mappings configured for the user resource. This field is included only when custom mappings are set up, allowing for additional user-specific data to be retrieved and utilized.
   */
  customMappings?: GetUserResponseCustomMappings | null | undefined;
  /**
   * The timestamp indicating when the user's information was last updated in the CRM. This is an optional field and follows the ISO 8601 format, providing precise date and time details for synchronization purposes.
   */
  updatedAt?: string | null | undefined;
  /**
   * The timestamp representing when the user account was initially created in the CRM system. This optional field is formatted according to ISO 8601 standards, offering a clear historical reference for the user's record.
   */
  createdAt?: string | null | undefined;
  /**
   * An array containing service-specific custom data or structured modifications. This property is used to pass additional data when fetching user details, allowing for more tailored responses based on the service requirements.
   */
  passThrough?: Array<GetUserResponsePassThrough> | undefined;
};

/**
 * User
 */
export type GetUserResponse = {
  /**
   * The HTTP response status code indicating the result of the API request. This integer value helps determine whether the request was successful (e.g., 200 for success) or if there was an error (e.g., 404 for not found). It is crucial for error handling and debugging.
   */
  statusCode: number;
  /**
   * A textual representation of the HTTP response status, such as 'OK' for a successful request or 'Not Found' for an error. This string provides a human-readable explanation of the status code, aiding in understanding the outcome of the API call.
   */
  status: string;
  /**
   * The unique Apideck identifier for the service provider from which the user data is retrieved. This string helps in identifying the source of the data, especially when multiple service providers are integrated within the application.
   */
  service: string;
  /**
   * The name of the Unified API resource that was accessed, in this case, typically representing the user entity. This string indicates the type of resource involved in the operation, helping developers understand the context of the data returned.
   */
  resource: string;
  /**
   * The specific operation performed by the API, such as 'get' for retrieving user details. This string clarifies the action taken, providing context about the API request and its purpose within the CRM system.
   */
  operation: string;
  /**
   * The main container object that holds all the detailed information about the user. This object includes various properties such as the user's ID, username, and personal details. It is the primary structure returned in the response, encapsulating all user-specific data.
   */
  data: GetUserResponseData;
};

/** @internal */
export const GetUserResponseType$inboundSchema: z.ZodNativeEnum<
  typeof GetUserResponseType
> = z.nativeEnum(GetUserResponseType);

/** @internal */
export const GetUserResponseType$outboundSchema: z.ZodNativeEnum<
  typeof GetUserResponseType
> = GetUserResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponseType$ {
  /** @deprecated use `GetUserResponseType$inboundSchema` instead. */
  export const inboundSchema = GetUserResponseType$inboundSchema;
  /** @deprecated use `GetUserResponseType$outboundSchema` instead. */
  export const outboundSchema = GetUserResponseType$outboundSchema;
}

/** @internal */
export const GetUserResponseAddresses$inboundSchema: z.ZodType<
  GetUserResponseAddresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(GetUserResponseType$inboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  street_number: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postal_code: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contact_name: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phone_number: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  row_version: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "street_number": "streetNumber",
    "postal_code": "postalCode",
    "contact_name": "contactName",
    "phone_number": "phoneNumber",
    "row_version": "rowVersion",
  });
});

/** @internal */
export type GetUserResponseAddresses$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
  string?: string | null | undefined;
  name?: string | null | undefined;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  line3?: string | null | undefined;
  line4?: string | null | undefined;
  street_number?: string | null | undefined;
  city?: string | null | undefined;
  state?: string | null | undefined;
  postal_code?: string | null | undefined;
  country?: string | null | undefined;
  latitude?: string | null | undefined;
  longitude?: string | null | undefined;
  county?: string | null | undefined;
  contact_name?: string | null | undefined;
  salutation?: string | null | undefined;
  phone_number?: string | null | undefined;
  fax?: string | null | undefined;
  email?: string | null | undefined;
  website?: string | null | undefined;
  notes?: string | null | undefined;
  row_version?: string | null | undefined;
};

/** @internal */
export const GetUserResponseAddresses$outboundSchema: z.ZodType<
  GetUserResponseAddresses$Outbound,
  z.ZodTypeDef,
  GetUserResponseAddresses
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(GetUserResponseType$outboundSchema).optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  streetNumber: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contactName: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phoneNumber: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  rowVersion: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    streetNumber: "street_number",
    postalCode: "postal_code",
    contactName: "contact_name",
    phoneNumber: "phone_number",
    rowVersion: "row_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponseAddresses$ {
  /** @deprecated use `GetUserResponseAddresses$inboundSchema` instead. */
  export const inboundSchema = GetUserResponseAddresses$inboundSchema;
  /** @deprecated use `GetUserResponseAddresses$outboundSchema` instead. */
  export const outboundSchema = GetUserResponseAddresses$outboundSchema;
  /** @deprecated use `GetUserResponseAddresses$Outbound` instead. */
  export type Outbound = GetUserResponseAddresses$Outbound;
}

export function getUserResponseAddressesToJSON(
  getUserResponseAddresses: GetUserResponseAddresses,
): string {
  return JSON.stringify(
    GetUserResponseAddresses$outboundSchema.parse(getUserResponseAddresses),
  );
}

export function getUserResponseAddressesFromJSON(
  jsonString: string,
): SafeParseResult<GetUserResponseAddresses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUserResponseAddresses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUserResponseAddresses' from JSON`,
  );
}

/** @internal */
export const GetUserResponseDataType$inboundSchema: z.ZodNativeEnum<
  typeof GetUserResponseDataType
> = z.nativeEnum(GetUserResponseDataType);

/** @internal */
export const GetUserResponseDataType$outboundSchema: z.ZodNativeEnum<
  typeof GetUserResponseDataType
> = GetUserResponseDataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponseDataType$ {
  /** @deprecated use `GetUserResponseDataType$inboundSchema` instead. */
  export const inboundSchema = GetUserResponseDataType$inboundSchema;
  /** @deprecated use `GetUserResponseDataType$outboundSchema` instead. */
  export const outboundSchema = GetUserResponseDataType$outboundSchema;
}

/** @internal */
export const GetUserResponsePhoneNumbers$inboundSchema: z.ZodType<
  GetUserResponsePhoneNumbers,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  country_code: z.nullable(z.string()).optional(),
  area_code: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(GetUserResponseDataType$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "country_code": "countryCode",
    "area_code": "areaCode",
  });
});

/** @internal */
export type GetUserResponsePhoneNumbers$Outbound = {
  id?: string | null | undefined;
  country_code?: string | null | undefined;
  area_code?: string | null | undefined;
  number: string;
  extension?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const GetUserResponsePhoneNumbers$outboundSchema: z.ZodType<
  GetUserResponsePhoneNumbers$Outbound,
  z.ZodTypeDef,
  GetUserResponsePhoneNumbers
> = z.object({
  id: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  areaCode: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(GetUserResponseDataType$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    countryCode: "country_code",
    areaCode: "area_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponsePhoneNumbers$ {
  /** @deprecated use `GetUserResponsePhoneNumbers$inboundSchema` instead. */
  export const inboundSchema = GetUserResponsePhoneNumbers$inboundSchema;
  /** @deprecated use `GetUserResponsePhoneNumbers$outboundSchema` instead. */
  export const outboundSchema = GetUserResponsePhoneNumbers$outboundSchema;
  /** @deprecated use `GetUserResponsePhoneNumbers$Outbound` instead. */
  export type Outbound = GetUserResponsePhoneNumbers$Outbound;
}

export function getUserResponsePhoneNumbersToJSON(
  getUserResponsePhoneNumbers: GetUserResponsePhoneNumbers,
): string {
  return JSON.stringify(
    GetUserResponsePhoneNumbers$outboundSchema.parse(
      getUserResponsePhoneNumbers,
    ),
  );
}

export function getUserResponsePhoneNumbersFromJSON(
  jsonString: string,
): SafeParseResult<GetUserResponsePhoneNumbers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUserResponsePhoneNumbers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUserResponsePhoneNumbers' from JSON`,
  );
}

/** @internal */
export const GetUserResponseDataEmailsType$inboundSchema: z.ZodNativeEnum<
  typeof GetUserResponseDataEmailsType
> = z.nativeEnum(GetUserResponseDataEmailsType);

/** @internal */
export const GetUserResponseDataEmailsType$outboundSchema: z.ZodNativeEnum<
  typeof GetUserResponseDataEmailsType
> = GetUserResponseDataEmailsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponseDataEmailsType$ {
  /** @deprecated use `GetUserResponseDataEmailsType$inboundSchema` instead. */
  export const inboundSchema = GetUserResponseDataEmailsType$inboundSchema;
  /** @deprecated use `GetUserResponseDataEmailsType$outboundSchema` instead. */
  export const outboundSchema = GetUserResponseDataEmailsType$outboundSchema;
}

/** @internal */
export const GetUserResponseEmails$inboundSchema: z.ZodType<
  GetUserResponseEmails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(GetUserResponseDataEmailsType$inboundSchema).optional(),
});

/** @internal */
export type GetUserResponseEmails$Outbound = {
  id?: string | null | undefined;
  email: string | null;
  type?: string | null | undefined;
};

/** @internal */
export const GetUserResponseEmails$outboundSchema: z.ZodType<
  GetUserResponseEmails$Outbound,
  z.ZodTypeDef,
  GetUserResponseEmails
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(GetUserResponseDataEmailsType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponseEmails$ {
  /** @deprecated use `GetUserResponseEmails$inboundSchema` instead. */
  export const inboundSchema = GetUserResponseEmails$inboundSchema;
  /** @deprecated use `GetUserResponseEmails$outboundSchema` instead. */
  export const outboundSchema = GetUserResponseEmails$outboundSchema;
  /** @deprecated use `GetUserResponseEmails$Outbound` instead. */
  export type Outbound = GetUserResponseEmails$Outbound;
}

export function getUserResponseEmailsToJSON(
  getUserResponseEmails: GetUserResponseEmails,
): string {
  return JSON.stringify(
    GetUserResponseEmails$outboundSchema.parse(getUserResponseEmails),
  );
}

export function getUserResponseEmailsFromJSON(
  jsonString: string,
): SafeParseResult<GetUserResponseEmails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUserResponseEmails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUserResponseEmails' from JSON`,
  );
}

/** @internal */
export const GetUserResponseCustomMappings$inboundSchema: z.ZodType<
  GetUserResponseCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type GetUserResponseCustomMappings$Outbound = {};

/** @internal */
export const GetUserResponseCustomMappings$outboundSchema: z.ZodType<
  GetUserResponseCustomMappings$Outbound,
  z.ZodTypeDef,
  GetUserResponseCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponseCustomMappings$ {
  /** @deprecated use `GetUserResponseCustomMappings$inboundSchema` instead. */
  export const inboundSchema = GetUserResponseCustomMappings$inboundSchema;
  /** @deprecated use `GetUserResponseCustomMappings$outboundSchema` instead. */
  export const outboundSchema = GetUserResponseCustomMappings$outboundSchema;
  /** @deprecated use `GetUserResponseCustomMappings$Outbound` instead. */
  export type Outbound = GetUserResponseCustomMappings$Outbound;
}

export function getUserResponseCustomMappingsToJSON(
  getUserResponseCustomMappings: GetUserResponseCustomMappings,
): string {
  return JSON.stringify(
    GetUserResponseCustomMappings$outboundSchema.parse(
      getUserResponseCustomMappings,
    ),
  );
}

export function getUserResponseCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<GetUserResponseCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUserResponseCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUserResponseCustomMappings' from JSON`,
  );
}

/** @internal */
export const GetUserResponseExtendPaths$inboundSchema: z.ZodType<
  GetUserResponseExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type GetUserResponseExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const GetUserResponseExtendPaths$outboundSchema: z.ZodType<
  GetUserResponseExtendPaths$Outbound,
  z.ZodTypeDef,
  GetUserResponseExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponseExtendPaths$ {
  /** @deprecated use `GetUserResponseExtendPaths$inboundSchema` instead. */
  export const inboundSchema = GetUserResponseExtendPaths$inboundSchema;
  /** @deprecated use `GetUserResponseExtendPaths$outboundSchema` instead. */
  export const outboundSchema = GetUserResponseExtendPaths$outboundSchema;
  /** @deprecated use `GetUserResponseExtendPaths$Outbound` instead. */
  export type Outbound = GetUserResponseExtendPaths$Outbound;
}

export function getUserResponseExtendPathsToJSON(
  getUserResponseExtendPaths: GetUserResponseExtendPaths,
): string {
  return JSON.stringify(
    GetUserResponseExtendPaths$outboundSchema.parse(getUserResponseExtendPaths),
  );
}

export function getUserResponseExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<GetUserResponseExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUserResponseExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUserResponseExtendPaths' from JSON`,
  );
}

/** @internal */
export const GetUserResponsePassThrough$inboundSchema: z.ZodType<
  GetUserResponsePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(z.lazy(() => GetUserResponseExtendPaths$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type GetUserResponsePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<GetUserResponseExtendPaths$Outbound> | undefined;
};

/** @internal */
export const GetUserResponsePassThrough$outboundSchema: z.ZodType<
  GetUserResponsePassThrough$Outbound,
  z.ZodTypeDef,
  GetUserResponsePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(z.lazy(() => GetUserResponseExtendPaths$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponsePassThrough$ {
  /** @deprecated use `GetUserResponsePassThrough$inboundSchema` instead. */
  export const inboundSchema = GetUserResponsePassThrough$inboundSchema;
  /** @deprecated use `GetUserResponsePassThrough$outboundSchema` instead. */
  export const outboundSchema = GetUserResponsePassThrough$outboundSchema;
  /** @deprecated use `GetUserResponsePassThrough$Outbound` instead. */
  export type Outbound = GetUserResponsePassThrough$Outbound;
}

export function getUserResponsePassThroughToJSON(
  getUserResponsePassThrough: GetUserResponsePassThrough,
): string {
  return JSON.stringify(
    GetUserResponsePassThrough$outboundSchema.parse(getUserResponsePassThrough),
  );
}

export function getUserResponsePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<GetUserResponsePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUserResponsePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUserResponsePassThrough' from JSON`,
  );
}

/** @internal */
export const GetUserResponseData$inboundSchema: z.ZodType<
  GetUserResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  parent_id: z.nullable(z.string()).optional(),
  username: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  division: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  company_name: z.nullable(z.string()).optional(),
  employee_number: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  addresses: z.array(z.lazy(() => GetUserResponseAddresses$inboundSchema))
    .optional(),
  phone_numbers: z.array(
    z.lazy(() => GetUserResponsePhoneNumbers$inboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => GetUserResponseEmails$inboundSchema)),
  custom_mappings: z.nullable(
    z.lazy(() => GetUserResponseCustomMappings$inboundSchema),
  ).optional(),
  updated_at: z.nullable(z.string()).optional(),
  created_at: z.nullable(z.string()).optional(),
  pass_through: z.array(z.lazy(() => GetUserResponsePassThrough$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "parent_id": "parentId",
    "first_name": "firstName",
    "last_name": "lastName",
    "company_name": "companyName",
    "employee_number": "employeeNumber",
    "phone_numbers": "phoneNumbers",
    "custom_mappings": "customMappings",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type GetUserResponseData$Outbound = {
  id?: string | undefined;
  parent_id?: string | null | undefined;
  username?: string | null | undefined;
  first_name?: string | null | undefined;
  last_name?: string | null | undefined;
  title?: string | null | undefined;
  division?: string | null | undefined;
  department?: string | null | undefined;
  company_name?: string | null | undefined;
  employee_number?: string | null | undefined;
  description?: string | null | undefined;
  image?: string | null | undefined;
  language?: string | null | undefined;
  status?: string | null | undefined;
  addresses?: Array<GetUserResponseAddresses$Outbound> | undefined;
  phone_numbers?: Array<GetUserResponsePhoneNumbers$Outbound> | undefined;
  emails: Array<GetUserResponseEmails$Outbound>;
  custom_mappings?: GetUserResponseCustomMappings$Outbound | null | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  pass_through?: Array<GetUserResponsePassThrough$Outbound> | undefined;
};

/** @internal */
export const GetUserResponseData$outboundSchema: z.ZodType<
  GetUserResponseData$Outbound,
  z.ZodTypeDef,
  GetUserResponseData
> = z.object({
  id: z.string().optional(),
  parentId: z.nullable(z.string()).optional(),
  username: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  division: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  companyName: z.nullable(z.string()).optional(),
  employeeNumber: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  addresses: z.array(z.lazy(() => GetUserResponseAddresses$outboundSchema))
    .optional(),
  phoneNumbers: z.array(
    z.lazy(() => GetUserResponsePhoneNumbers$outboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => GetUserResponseEmails$outboundSchema)),
  customMappings: z.nullable(
    z.lazy(() => GetUserResponseCustomMappings$outboundSchema),
  ).optional(),
  updatedAt: z.nullable(z.string()).optional(),
  createdAt: z.nullable(z.string()).optional(),
  passThrough: z.array(z.lazy(() => GetUserResponsePassThrough$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    parentId: "parent_id",
    firstName: "first_name",
    lastName: "last_name",
    companyName: "company_name",
    employeeNumber: "employee_number",
    phoneNumbers: "phone_numbers",
    customMappings: "custom_mappings",
    updatedAt: "updated_at",
    createdAt: "created_at",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponseData$ {
  /** @deprecated use `GetUserResponseData$inboundSchema` instead. */
  export const inboundSchema = GetUserResponseData$inboundSchema;
  /** @deprecated use `GetUserResponseData$outboundSchema` instead. */
  export const outboundSchema = GetUserResponseData$outboundSchema;
  /** @deprecated use `GetUserResponseData$Outbound` instead. */
  export type Outbound = GetUserResponseData$Outbound;
}

export function getUserResponseDataToJSON(
  getUserResponseData: GetUserResponseData,
): string {
  return JSON.stringify(
    GetUserResponseData$outboundSchema.parse(getUserResponseData),
  );
}

export function getUserResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<GetUserResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUserResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUserResponseData' from JSON`,
  );
}

/** @internal */
export const GetUserResponse$inboundSchema: z.ZodType<
  GetUserResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => GetUserResponseData$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type GetUserResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: GetUserResponseData$Outbound;
};

/** @internal */
export const GetUserResponse$outboundSchema: z.ZodType<
  GetUserResponse$Outbound,
  z.ZodTypeDef,
  GetUserResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => GetUserResponseData$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserResponse$ {
  /** @deprecated use `GetUserResponse$inboundSchema` instead. */
  export const inboundSchema = GetUserResponse$inboundSchema;
  /** @deprecated use `GetUserResponse$outboundSchema` instead. */
  export const outboundSchema = GetUserResponse$outboundSchema;
  /** @deprecated use `GetUserResponse$Outbound` instead. */
  export type Outbound = GetUserResponse$Outbound;
}

export function getUserResponseToJSON(
  getUserResponse: GetUserResponse,
): string {
  return JSON.stringify(GetUserResponse$outboundSchema.parse(getUserResponse));
}

export function getUserResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetUserResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUserResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUserResponse' from JSON`,
  );
}

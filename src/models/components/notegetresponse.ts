/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * This object contains any custom mappings that have been configured for the note resource. Custom mappings allow for additional, user-defined fields to be associated with the note, providing flexibility to adapt the CRM to specific business needs. This property is included when such mappings are present, enabling users to extend the standard note functionality with custom attributes that can capture unique business data. This is particularly useful in scenarios where standard fields do not fully capture the required information, allowing for a more tailored CRM experience.
 */
export type NoteGetResponseCustomMappings = {};

export type NoteGetResponseExtendPaths = {
  /**
   * A JSONPath string that specifies the exact location within the user record where the value should be applied. This is essential for making precise updates to nested fields, ensuring that changes are made only to the intended parts of the data structure. The path must be valid and correspond to an existing field within the user record.
   */
  path: string;
  /**
   * This property represents the specific value that you wish to assign to a designated path within the user record. It can be of any data type, such as a string, number, boolean, or object, depending on the field being updated. The flexibility of this property allows for a wide range of updates, from simple text changes to complex data structures. In the context of the `usersUpdate` operation, this property is crucial for specifying the exact data modification you intend to make, ensuring that only the targeted fields are altered without affecting other data. Proper validation should be applied to ensure the value is compatible with the field's expected data type and business rules. Common use cases include updating user contact information, preferences, or custom attributes specific to your CRM's schema.
   */
  value?: any | undefined;
};

export type NoteGetResponsePassThrough = {
  /**
   * The unique identifier for the specific service to which this pass_through should be applied. This is crucial for directing the update operation to the correct service within the CRM system, ensuring that the modifications are executed in the appropriate context. It must be a valid service ID that corresponds to an active service integration, and it is required for the operation to proceed.
   */
  serviceId: string;
  /**
   * An optional identifier for a specific workflow operation within the CRM system to which this pass_through should be applied. This is particularly useful for Unify calls that involve multiple downstream requests, allowing for precise targeting and execution of specific operations. If provided, it should match an existing operation ID to ensure correct processing.
   */
  operationId?: string | undefined;
  /**
   * A flexible object that allows for the inclusion of any additional properties needed for direct extension of the user record. This can be used to add custom fields or metadata that are not part of the standard user schema, providing a way to tailor the user data to specific business needs. The structure of this object should align with the CRM's data model to ensure compatibility.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * An array of objects designed for structured data modifications via specified paths. This allows for precise updates to nested data structures within the user record, enabling complex modifications without altering unrelated data. Each object in the array should define a clear path and value to be applied, ensuring targeted updates.
   */
  extendPaths?: Array<NoteGetResponseExtendPaths> | undefined;
};

/**
 * The main container object for the note's details, encapsulating all relevant information about the note retrieved from the CRM system. This object is always included in the response to provide a structured format for accessing individual note properties such as ID, title, content, and owner information.
 */
export type NoteGetResponseData = {
  /**
   * The unique identifier of the note. This ID is crucial for locating the specific note within the CRM system that you wish to update. It must be a valid, pre-existing identifier, as the operation will fail if the note does not exist. Typically, this ID is generated by the system when the note is created and is immutable.
   */
  id?: string | undefined;
  /**
   * The title of the note. This serves as a brief summary or headline for the note's content, helping users quickly identify the note's subject matter. While not required, providing a clear and descriptive title can enhance searchability and organization within the CRM.
   */
  title?: string | null | undefined;
  /**
   * The content of the note. This field contains the main body of text for the note, where detailed information is recorded. It supports rich text formatting, allowing for a structured and readable presentation of information. Updating this field is essential when the note's details need to be revised or expanded.
   */
  content?: string | null | undefined;
  /**
   * The user that owns the note. This identifier links the note to a specific user within the CRM, typically the person responsible for the note's content. It is important for tracking accountability and managing access permissions. The owner ID should correspond to a valid user ID in the system.
   */
  ownerId?: string | null | undefined;
  /**
   * The contact that is related to the note. This field associates the note with a specific contact in the CRM, providing context and relevance to the note's content. It is particularly useful for notes that document interactions or information pertinent to a particular contact. Ensure this ID matches an existing contact ID in the CRM.
   */
  contactId?: string | null | undefined;
  /**
   * This field represents the unique identifier of the company associated with the note. It is used to link the note to a specific company within the CRM system, providing context and relevance to the note's content. While not mandatory, including this ID ensures that the note is correctly categorized under the appropriate company, facilitating better organization and retrieval of notes related to company activities. This is particularly useful in scenarios where notes are used to track interactions or updates related to specific companies.
   */
  companyId?: string | null | undefined;
  /**
   * This property holds the unique identifier for the opportunity linked to the note. It serves to associate the note with a particular sales opportunity within the CRM, thereby enhancing the note's relevance and context. Although optional, providing this ID helps in tracking the progress and updates related to specific opportunities, making it easier for sales teams to access all pertinent information in one place. This is especially beneficial in managing sales pipelines and ensuring that all notes are aligned with ongoing opportunities.
   */
  opportunityId?: string | null | undefined;
  /**
   * This attribute specifies the unique identifier for the lead associated with the note. It is used to connect the note to a particular lead in the CRM, adding context and specificity to the note's content. While not required, including this ID can significantly aid in organizing notes by lead, which is crucial for tracking interactions and follow-ups with potential clients. This is particularly important in lead management processes where maintaining detailed records of communications and updates is essential for conversion efforts.
   */
  leadId?: string | null | undefined;
  /**
   * This boolean field indicates whether the note is currently active. An active note is one that is considered relevant and up-to-date, whereas an inactive note might be archived or no longer applicable. This property is useful for filtering notes based on their current status, allowing users to focus on notes that are pertinent to ongoing activities or discussions. It is particularly valuable in maintaining an organized and efficient note management system within the CRM.
   */
  active?: boolean | null | undefined;
  /**
   * This object contains any custom mappings that have been configured for the note resource. Custom mappings allow for additional, user-defined fields to be associated with the note, providing flexibility to adapt the CRM to specific business needs. This property is included when such mappings are present, enabling users to extend the standard note functionality with custom attributes that can capture unique business data. This is particularly useful in scenarios where standard fields do not fully capture the required information, allowing for a more tailored CRM experience.
   */
  customMappings?: NoteGetResponseCustomMappings | null | undefined;
  /**
   * The identifier of the user who last modified the note. This field is crucial for tracking changes and maintaining an audit trail within the CRM system. It helps in identifying who made the last update, which is essential for accountability and historical reference. Typically, this would be a user ID or username that corresponds to a valid user in the system.
   */
  updatedBy?: string | null | undefined;
  /**
   * The identifier of the user who originally created the note. This information is important for understanding the origin of the note and for maintaining a complete historical record. It allows users to trace back to the creator for any clarifications or context regarding the note's initial content. This should be a valid user ID or username within the CRM system.
   */
  createdBy?: string | null | undefined;
  /**
   * The timestamp indicating when the note was last updated. This field is formatted in ISO 8601 and is vital for tracking the recency of changes. It helps users understand how current the note's information is and can be used to resolve conflicts in concurrent updates. This timestamp should reflect the exact time of the last modification in UTC.
   */
  updatedAt?: string | null | undefined;
  /**
   * The timestamp indicating when the note was originally created. This field, formatted in ISO 8601, provides a historical reference point for the note's existence. It is useful for chronological sorting and understanding the timeline of interactions related to the note. This timestamp should accurately reflect the creation time in UTC.
   */
  createdAt?: string | null | undefined;
  /**
   * An array that allows the inclusion of service-specific custom data or structured modifications when updating the note. This property is particularly useful for integrations that require additional metadata or configuration settings that are not covered by standard fields. It enables flexibility and extensibility in handling diverse CRM requirements. Each element in the array should conform to the expected structure defined by the target service.
   */
  passThrough?: Array<NoteGetResponsePassThrough> | undefined;
};

/**
 * Note
 */
export type NoteGetResponse = {
  /**
   * The HTTP response status code indicating the result of the API request. This integer value is crucial for understanding the outcome of the request, such as 200 for success or 404 if the note is not found. It is always included in the response to provide immediate feedback on the request's success or failure.
   */
  statusCode: number;
  /**
   * A textual representation of the HTTP response status. This string provides a human-readable explanation of the status code, such as 'OK' for a successful request or 'Not Found' for a missing resource. It complements the status code by offering a more descriptive context and is always included in the response.
   */
  status: string;
  /**
   * The Apideck ID of the service provider that processed the request. This string uniquely identifies which service within the Apideck ecosystem handled the operation, especially useful when multiple integrations are involved. It is always included to ensure clarity about the source of the response data.
   */
  service: string;
  /**
   * The name of the unified API resource that was accessed. This string indicates the specific resource type, such as 'note', that the operation was performed on. It helps in understanding the context of the request and is always included to confirm the target of the operation.
   */
  resource: string;
  /**
   * The specific operation that was performed during the API request. This string describes the action taken, such as 'retrieve' for fetching a note, and is crucial for logging and auditing purposes. It is always included to provide a clear record of the action executed by the API.
   */
  operation: string;
  /**
   * The main container object for the note's details, encapsulating all relevant information about the note retrieved from the CRM system. This object is always included in the response to provide a structured format for accessing individual note properties such as ID, title, content, and owner information.
   */
  data: NoteGetResponseData;
};

/** @internal */
export const NoteGetResponseCustomMappings$inboundSchema: z.ZodType<
  NoteGetResponseCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type NoteGetResponseCustomMappings$Outbound = {};

/** @internal */
export const NoteGetResponseCustomMappings$outboundSchema: z.ZodType<
  NoteGetResponseCustomMappings$Outbound,
  z.ZodTypeDef,
  NoteGetResponseCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteGetResponseCustomMappings$ {
  /** @deprecated use `NoteGetResponseCustomMappings$inboundSchema` instead. */
  export const inboundSchema = NoteGetResponseCustomMappings$inboundSchema;
  /** @deprecated use `NoteGetResponseCustomMappings$outboundSchema` instead. */
  export const outboundSchema = NoteGetResponseCustomMappings$outboundSchema;
  /** @deprecated use `NoteGetResponseCustomMappings$Outbound` instead. */
  export type Outbound = NoteGetResponseCustomMappings$Outbound;
}

export function noteGetResponseCustomMappingsToJSON(
  noteGetResponseCustomMappings: NoteGetResponseCustomMappings,
): string {
  return JSON.stringify(
    NoteGetResponseCustomMappings$outboundSchema.parse(
      noteGetResponseCustomMappings,
    ),
  );
}

export function noteGetResponseCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<NoteGetResponseCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteGetResponseCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteGetResponseCustomMappings' from JSON`,
  );
}

/** @internal */
export const NoteGetResponseExtendPaths$inboundSchema: z.ZodType<
  NoteGetResponseExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type NoteGetResponseExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const NoteGetResponseExtendPaths$outboundSchema: z.ZodType<
  NoteGetResponseExtendPaths$Outbound,
  z.ZodTypeDef,
  NoteGetResponseExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteGetResponseExtendPaths$ {
  /** @deprecated use `NoteGetResponseExtendPaths$inboundSchema` instead. */
  export const inboundSchema = NoteGetResponseExtendPaths$inboundSchema;
  /** @deprecated use `NoteGetResponseExtendPaths$outboundSchema` instead. */
  export const outboundSchema = NoteGetResponseExtendPaths$outboundSchema;
  /** @deprecated use `NoteGetResponseExtendPaths$Outbound` instead. */
  export type Outbound = NoteGetResponseExtendPaths$Outbound;
}

export function noteGetResponseExtendPathsToJSON(
  noteGetResponseExtendPaths: NoteGetResponseExtendPaths,
): string {
  return JSON.stringify(
    NoteGetResponseExtendPaths$outboundSchema.parse(noteGetResponseExtendPaths),
  );
}

export function noteGetResponseExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<NoteGetResponseExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteGetResponseExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteGetResponseExtendPaths' from JSON`,
  );
}

/** @internal */
export const NoteGetResponsePassThrough$inboundSchema: z.ZodType<
  NoteGetResponsePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(z.lazy(() => NoteGetResponseExtendPaths$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type NoteGetResponsePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<NoteGetResponseExtendPaths$Outbound> | undefined;
};

/** @internal */
export const NoteGetResponsePassThrough$outboundSchema: z.ZodType<
  NoteGetResponsePassThrough$Outbound,
  z.ZodTypeDef,
  NoteGetResponsePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(z.lazy(() => NoteGetResponseExtendPaths$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteGetResponsePassThrough$ {
  /** @deprecated use `NoteGetResponsePassThrough$inboundSchema` instead. */
  export const inboundSchema = NoteGetResponsePassThrough$inboundSchema;
  /** @deprecated use `NoteGetResponsePassThrough$outboundSchema` instead. */
  export const outboundSchema = NoteGetResponsePassThrough$outboundSchema;
  /** @deprecated use `NoteGetResponsePassThrough$Outbound` instead. */
  export type Outbound = NoteGetResponsePassThrough$Outbound;
}

export function noteGetResponsePassThroughToJSON(
  noteGetResponsePassThrough: NoteGetResponsePassThrough,
): string {
  return JSON.stringify(
    NoteGetResponsePassThrough$outboundSchema.parse(noteGetResponsePassThrough),
  );
}

export function noteGetResponsePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<NoteGetResponsePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteGetResponsePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteGetResponsePassThrough' from JSON`,
  );
}

/** @internal */
export const NoteGetResponseData$inboundSchema: z.ZodType<
  NoteGetResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  owner_id: z.nullable(z.string()).optional(),
  contact_id: z.nullable(z.string()).optional(),
  company_id: z.nullable(z.string()).optional(),
  opportunity_id: z.nullable(z.string()).optional(),
  lead_id: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  custom_mappings: z.nullable(
    z.lazy(() => NoteGetResponseCustomMappings$inboundSchema),
  ).optional(),
  updated_by: z.nullable(z.string()).optional(),
  created_by: z.nullable(z.string()).optional(),
  updated_at: z.nullable(z.string()).optional(),
  created_at: z.nullable(z.string()).optional(),
  pass_through: z.array(z.lazy(() => NoteGetResponsePassThrough$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "contact_id": "contactId",
    "company_id": "companyId",
    "opportunity_id": "opportunityId",
    "lead_id": "leadId",
    "custom_mappings": "customMappings",
    "updated_by": "updatedBy",
    "created_by": "createdBy",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type NoteGetResponseData$Outbound = {
  id?: string | undefined;
  title?: string | null | undefined;
  content?: string | null | undefined;
  owner_id?: string | null | undefined;
  contact_id?: string | null | undefined;
  company_id?: string | null | undefined;
  opportunity_id?: string | null | undefined;
  lead_id?: string | null | undefined;
  active?: boolean | null | undefined;
  custom_mappings?: NoteGetResponseCustomMappings$Outbound | null | undefined;
  updated_by?: string | null | undefined;
  created_by?: string | null | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  pass_through?: Array<NoteGetResponsePassThrough$Outbound> | undefined;
};

/** @internal */
export const NoteGetResponseData$outboundSchema: z.ZodType<
  NoteGetResponseData$Outbound,
  z.ZodTypeDef,
  NoteGetResponseData
> = z.object({
  id: z.string().optional(),
  title: z.nullable(z.string()).optional(),
  content: z.nullable(z.string()).optional(),
  ownerId: z.nullable(z.string()).optional(),
  contactId: z.nullable(z.string()).optional(),
  companyId: z.nullable(z.string()).optional(),
  opportunityId: z.nullable(z.string()).optional(),
  leadId: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  customMappings: z.nullable(
    z.lazy(() => NoteGetResponseCustomMappings$outboundSchema),
  ).optional(),
  updatedBy: z.nullable(z.string()).optional(),
  createdBy: z.nullable(z.string()).optional(),
  updatedAt: z.nullable(z.string()).optional(),
  createdAt: z.nullable(z.string()).optional(),
  passThrough: z.array(z.lazy(() => NoteGetResponsePassThrough$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    contactId: "contact_id",
    companyId: "company_id",
    opportunityId: "opportunity_id",
    leadId: "lead_id",
    customMappings: "custom_mappings",
    updatedBy: "updated_by",
    createdBy: "created_by",
    updatedAt: "updated_at",
    createdAt: "created_at",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteGetResponseData$ {
  /** @deprecated use `NoteGetResponseData$inboundSchema` instead. */
  export const inboundSchema = NoteGetResponseData$inboundSchema;
  /** @deprecated use `NoteGetResponseData$outboundSchema` instead. */
  export const outboundSchema = NoteGetResponseData$outboundSchema;
  /** @deprecated use `NoteGetResponseData$Outbound` instead. */
  export type Outbound = NoteGetResponseData$Outbound;
}

export function noteGetResponseDataToJSON(
  noteGetResponseData: NoteGetResponseData,
): string {
  return JSON.stringify(
    NoteGetResponseData$outboundSchema.parse(noteGetResponseData),
  );
}

export function noteGetResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<NoteGetResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteGetResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteGetResponseData' from JSON`,
  );
}

/** @internal */
export const NoteGetResponse$inboundSchema: z.ZodType<
  NoteGetResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => NoteGetResponseData$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type NoteGetResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: NoteGetResponseData$Outbound;
};

/** @internal */
export const NoteGetResponse$outboundSchema: z.ZodType<
  NoteGetResponse$Outbound,
  z.ZodTypeDef,
  NoteGetResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.lazy(() => NoteGetResponseData$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NoteGetResponse$ {
  /** @deprecated use `NoteGetResponse$inboundSchema` instead. */
  export const inboundSchema = NoteGetResponse$inboundSchema;
  /** @deprecated use `NoteGetResponse$outboundSchema` instead. */
  export const outboundSchema = NoteGetResponse$outboundSchema;
  /** @deprecated use `NoteGetResponse$Outbound` instead. */
  export type Outbound = NoteGetResponse$Outbound;
}

export function noteGetResponseToJSON(
  noteGetResponse: NoteGetResponse,
): string {
  return JSON.stringify(NoteGetResponse$outboundSchema.parse(noteGetResponse));
}

export function noteGetResponseFromJSON(
  jsonString: string,
): SafeParseResult<NoteGetResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteGetResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteGetResponse' from JSON`,
  );
}

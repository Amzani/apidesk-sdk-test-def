/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Specifies the type or category of the contact, such as 'customer', 'lead', or 'vendor'. This string helps in classifying contacts for better organization and targeted operations within the CRM.
 */
export const ListContactsResponseType = {
  Customer: "customer",
  Supplier: "supplier",
  Employee: "employee",
  Personal: "personal",
} as const;
/**
 * Specifies the type or category of the contact, such as 'customer', 'lead', or 'vendor'. This string helps in classifying contacts for better organization and targeted operations within the CRM.
 */
export type ListContactsResponseType = ClosedEnum<
  typeof ListContactsResponseType
>;

/**
 * The gender of the contact, typically represented as 'male', 'female', or other gender identities. This information can be used for personalized communication and analytics.
 */
export const ListContactsResponseGender = {
  Male: "male",
  Female: "female",
  Unisex: "unisex",
} as const;
/**
 * The gender of the contact, typically represented as 'male', 'female', or other gender identities. This information can be used for personalized communication and analytics.
 */
export type ListContactsResponseGender = ClosedEnum<
  typeof ListContactsResponseGender
>;

/**
 * Specifies the type of website, such as personal, business, or social media, associated with the contact. This string helps categorize the websites, enabling applications to display or process them according to their type.
 */
export const ListContactsResponseDataType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * Specifies the type of website, such as personal, business, or social media, associated with the contact. This string helps categorize the websites, enabling applications to display or process them according to their type.
 */
export type ListContactsResponseDataType = ClosedEnum<
  typeof ListContactsResponseDataType
>;

export type ListContactsResponseWebsites = {
  /**
   * A unique string identifier for each website associated with the contact. This ID is used to distinguish between different websites and is essential for operations that require specific website data manipulation or retrieval.
   */
  id?: string | null | undefined;
  /**
   * The URL of the website associated with the contact, provided as a string. This is a required field and is crucial for linking to the contact's online presence or resources directly from the application.
   */
  url: string;
  /**
   * Specifies the type of website, such as personal, business, or social media, associated with the contact. This string helps categorize the websites, enabling applications to display or process them according to their type.
   */
  type?: ListContactsResponseDataType | null | undefined;
};

/**
 * Specifies the category or purpose of the address, such as 'home', 'work', or 'billing'. This string helps in identifying the context in which the address is used, aiding in filtering and organizing addresses based on their type.
 */
export const ListContactsResponseDataAddressesType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Office: "office",
  Shipping: "shipping",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the category or purpose of the address, such as 'home', 'work', or 'billing'. This string helps in identifying the context in which the address is used, aiding in filtering and organizing addresses based on their type.
 */
export type ListContactsResponseDataAddressesType = ClosedEnum<
  typeof ListContactsResponseDataAddressesType
>;

export type ListContactsResponseAddresses = {
  /**
   * A unique identifier for each address entry within the contact's address list. This string is used to distinguish between different addresses and is essential for operations that require specific address manipulation or retrieval.
   */
  id?: string | null | undefined;
  /**
   * Specifies the category or purpose of the address, such as 'home', 'work', or 'billing'. This string helps in identifying the context in which the address is used, aiding in filtering and organizing addresses based on their type.
   */
  type?: ListContactsResponseDataAddressesType | null | undefined;
  /**
   * The complete address as a single string, which may include street, city, state, and postal code. This format is particularly useful when structured address data is unavailable, providing a straightforward way to display or process address information.
   */
  string?: string | null | undefined;
  /**
   * A descriptive name associated with the address, such as 'Headquarters' or 'Main Office'. This string provides a human-readable label for the address, making it easier to identify and differentiate between multiple addresses in user interfaces or reports.
   */
  name?: string | null | undefined;
  /**
   * This property contains the first line of the address, typically including the street number, street name, and any suite or apartment number. It is a string value that provides the primary location information for a contact's address, essential for identifying the exact location in mailing and navigation applications.
   */
  line1?: string | null | undefined;
  /**
   * This property holds the second line of the address, often used for additional address details such as building name or floor number. It is a string value that supplements the primary address line, offering more precise location information when needed.
   */
  line2?: string | null | undefined;
  /**
   * This property contains the third line of the address, which can be used for further address details not covered in the first two lines. It is a string value that provides additional context for complex addresses, ensuring all necessary location information is captured.
   */
  line3?: string | null | undefined;
  /**
   * This property includes the fourth line of the address, reserved for any extra address information that may be required. It is a string value that allows for comprehensive address details, particularly useful for international addresses with multiple components.
   */
  line4?: string | null | undefined;
  /**
   * This property specifies the street number of the address, a crucial component for pinpointing the exact location of a contact. It is a string value that is part of the primary address line, used in conjunction with the street name to identify a specific address.
   */
  streetNumber?: string | null | undefined;
  /**
   * The city name associated with the contact's address. This string value represents the urban area where the contact resides or is located. It is part of the address details returned in the contact list, useful for geographical categorization and display purposes.
   */
  city?: string | null | undefined;
  /**
   * The state or region name related to the contact's address. This string provides the administrative division within the country where the contact is situated. It helps in organizing contacts by regional boundaries and is included in the address details of the response.
   */
  state?: string | null | undefined;
  /**
   * The postal code or ZIP code for the contact's address. This string is used to identify the specific area within a city or town for mailing purposes. It is crucial for precise location identification and is part of the address information in the contact data.
   */
  postalCode?: string | null | undefined;
  /**
   * The country code for the contact's address, following the ISO 3166-1 alpha-2 standard. This two-letter string identifies the country where the contact is located, facilitating international address recognition and sorting in the contact list.
   */
  country?: string | null | undefined;
  /**
   * The latitude coordinate of the contact's address. This string represents the geographical latitude, which is used in mapping and location-based services to pinpoint the contact's exact position on the globe. It is part of the geolocation data included in the contact response.
   */
  latitude?: string | null | undefined;
  /**
   * The longitude coordinate of the address, represented as a string. This value is part of the geographical data used to pinpoint the exact location of a contact's address on a map. It is optional and may not be present if the address does not include geographical coordinates.
   */
  longitude?: string | null | undefined;
  /**
   * The county or sublocality associated with the address, provided as a string. This field helps in identifying the regional division within a state or country where the contact is located. It is optional and may be omitted if not applicable.
   */
  county?: string | null | undefined;
  /**
   * The full name of the contact person associated with the address, formatted as a string. This information is useful for identifying the primary individual linked to the address, especially in business or personal correspondence. It is optional and may not be included if not specified.
   */
  contactName?: string | null | undefined;
  /**
   * The salutation or title used for the contact person at the address, such as 'Mr.', 'Ms.', or 'Dr.', provided as a string. This field is used to address the contact person respectfully in communications. It is optional and may be absent if not specified.
   */
  salutation?: string | null | undefined;
  /**
   * The phone number associated with the address, formatted as a string. This number is used for contacting the individual or business at the specified address and may include country and area codes. It is optional and may not be present if no phone number is provided.
   */
  phoneNumber?: string | null | undefined;
  /**
   * The fax number associated with the contact's address. This is an optional field and may be empty if no fax number is provided. It is returned as a string and can be used for communication purposes where fax is applicable.
   */
  fax?: string | null | undefined;
  /**
   * The email address linked to the contact's address. This field is optional and may be empty if no email is provided. It is formatted as a string and is crucial for electronic communication with the contact.
   */
  email?: string | null | undefined;
  /**
   * The website URL associated with the contact's address. This optional field is returned as a string and may be empty if no website is provided. It is useful for accessing the contact's online presence or additional information.
   */
  website?: string | null | undefined;
  /**
   * Additional notes related to the contact's address. This field is optional and returned as a string, providing space for any extra information or comments about the address that may be relevant for users.
   */
  notes?: string | null | undefined;
  /**
   * A binary string value used to track changes to the contact's address object. This field is optional and is incremented with each update to prevent data conflicts, ensuring data integrity during synchronization processes.
   */
  rowVersion?: string | null | undefined;
};

export type ListContactsResponseSocialLinks = {
  /**
   * A unique identifier for each social link associated with the contact. This ID is used to distinguish between different social media profiles within the contact's social links array. It is optional and may not be present if the social link does not have a unique identifier.
   */
  id?: string | null | undefined;
  /**
   * The URL of the social media profile, such as 'https://www.twitter.com/apideck'. This string is required and provides a direct link to the contact's social media page, facilitating easy access and integration into applications.
   */
  url: string;
  /**
   * Indicates the type of social media platform, such as 'twitter' or 'linkedin'. This string helps categorize the social link, allowing applications to display appropriate icons or labels. It is optional and may be omitted if the type is not specified.
   */
  type?: string | null | undefined;
};

/**
 * Indicates the category of the phone number, such as 'mobile', 'home', or 'work'. This helps in identifying the context in which the phone number is used, aiding in better contact management and communication strategies.
 */
export const ListContactsResponseDataPhoneNumbersType = {
  Primary: "primary",
  Secondary: "secondary",
  Home: "home",
  Work: "work",
  Office: "office",
  Mobile: "mobile",
  Assistant: "assistant",
  Fax: "fax",
  DirectDialIn: "direct-dial-in",
  Personal: "personal",
  Other: "other",
} as const;
/**
 * Indicates the category of the phone number, such as 'mobile', 'home', or 'work'. This helps in identifying the context in which the phone number is used, aiding in better contact management and communication strategies.
 */
export type ListContactsResponseDataPhoneNumbersType = ClosedEnum<
  typeof ListContactsResponseDataPhoneNumbersType
>;

export type ListContactsResponsePhoneNumbers = {
  /**
   * A unique identifier assigned to each phone number entry within the contact's record. This identifier is used to distinguish between multiple phone numbers associated with a single contact and is typically a non-empty string when present.
   */
  id?: string | null | undefined;
  /**
   * The international dialing code associated with the phone number, such as '+1' for the United States. This code is crucial for making international calls and is included in the phone number format to ensure proper dialing.
   */
  countryCode?: string | null | undefined;
  /**
   * The regional area code that forms part of the phone number, for example, '323' for Los Angeles. This code helps in identifying the specific geographic region of the phone number within a country.
   */
  areaCode?: string | null | undefined;
  /**
   * The main sequence of digits that make up the phone number, excluding the country and area codes. This is the essential part of the phone number used for dialing and is always required for contact records.
   */
  number: string;
  /**
   * An optional numeric extension that can be dialed after the main phone number to reach a specific person or department within an organization. This is typically used in business settings where multiple extensions are available under a single main number.
   */
  extension?: string | null | undefined;
  /**
   * Indicates the category of the phone number, such as 'mobile', 'home', or 'work'. This helps in identifying the context in which the phone number is used, aiding in better contact management and communication strategies.
   */
  type?: ListContactsResponseDataPhoneNumbersType | null | undefined;
};

/**
 * Specifies the type of email address, such as 'personal' or 'work'. This classification aids in organizing and prioritizing email communications based on their intended use or context.
 */
export const ListContactsResponseDataEmailsType = {
  Primary: "primary",
  Secondary: "secondary",
  Work: "work",
  Personal: "personal",
  Billing: "billing",
  Other: "other",
} as const;
/**
 * Specifies the type of email address, such as 'personal' or 'work'. This classification aids in organizing and prioritizing email communications based on their intended use or context.
 */
export type ListContactsResponseDataEmailsType = ClosedEnum<
  typeof ListContactsResponseDataEmailsType
>;

export type ListContactsResponseEmails = {
  /**
   * A unique identifier for each email address associated with the contact. This ID is crucial for distinguishing between multiple email entries and performing operations like updates or deletions on specific emails.
   */
  id?: string | null | undefined;
  /**
   * The actual email address of the contact, formatted as a standard email string (e.g., 'example@domain.com'). This is a required field and serves as a primary means of electronic communication with the contact.
   */
  email: string | null;
  /**
   * Specifies the type of email address, such as 'personal' or 'work'. This classification aids in organizing and prioritizing email communications based on their intended use or context.
   */
  type?: ListContactsResponseDataEmailsType | null | undefined;
};

export type ListContactsResponseValue6 = {};

export type ListContactsResponseValue4 = {};

/**
 * Contains the value associated with a custom field for a contact. This value can be of various types, such as string, number, or date, depending on the custom field's configuration. It allows for the storage of additional, user-defined information that is not covered by standard contact fields.
 */
export type ListContactsResponseValue =
  | ListContactsResponseValue4
  | string
  | number
  | boolean
  | Array<string>
  | Array<ListContactsResponseValue6>;

export type ListContactsResponseCustomFields = {
  /**
   * A unique identifier for each custom field associated with the contact. This ID is crucial for distinguishing between different custom fields and is used when accessing or modifying specific custom field data. It is always returned as a non-empty string.
   */
  id: string | null;
  /**
   * The name assigned to the custom field, which describes the type of information it holds. This is a user-friendly label that helps in identifying the purpose of the custom field within the CRM. It is returned as a string and may be empty if not specified.
   */
  name?: string | null | undefined;
  /**
   * A detailed description of what the custom field represents, providing context and additional information about its use. This helps users understand the relevance and application of the custom field data. It is returned as a string and can be empty if no description is provided.
   */
  description?: string | null | undefined;
  /**
   * Contains the value associated with a custom field for a contact. This value can be of various types, such as string, number, or date, depending on the custom field's configuration. It allows for the storage of additional, user-defined information that is not covered by standard contact fields.
   */
  value?:
    | ListContactsResponseValue4
    | string
    | number
    | boolean
    | Array<string>
    | Array<ListContactsResponseValue6>
    | null
    | undefined;
};

/**
 * An object containing any custom field mappings configured for the contact resource. This allows developers to access additional, non-standard data fields that have been tailored to specific business needs. The structure of this object depends on the custom mappings set up in the CRM.
 */
export type ListContactsResponseCustomMappings = {};

export type ListContactsResponseExtendPaths = {
  /**
   * A JSONPath string that precisely identifies the location within the contact data where the specified value should be applied. This string must be a valid JSONPath expression, ensuring accurate targeting of data modifications within the contact records.
   */
  path: string;
  /**
   * The value to be set at the specified JSONPath within the contact data. This can be of any data type, allowing for versatile modifications to the contact records based on the application's requirements.
   */
  value?: any | undefined;
};

export type ListContactsResponsePassThrough = {
  /**
   * A string that uniquely identifies the service to which the pass_through data should be applied. This is required to ensure that the custom data is directed to the correct service within the CRM system.
   */
  serviceId: string;
  /**
   * An optional string identifier for a specific workflow operation that the pass_through data should be applied to. This is particularly useful for Unify calls that involve multiple downstream requests, ensuring that the correct operation is targeted.
   */
  operationId?: string | undefined;
  /**
   * An object that allows for direct extension with any properties, providing flexibility to include additional data as needed. This is useful for developers who need to customize the request with specific attributes that are not predefined in the API.
   */
  extendObject?: { [k: string]: any } | undefined;
  /**
   * This property contains an array of objects, each representing a structured data modification path. It is used to specify where and how data should be altered within the contact records. The array format allows for multiple modifications to be defined in a single request, enhancing flexibility in data handling.
   */
  extendPaths?: Array<ListContactsResponseExtendPaths> | undefined;
};

export type ListContactsResponseData = {
  /**
   * A unique identifier assigned to each contact within the CRM system. This string is used to distinguish each contact from others and is essential for operations that require specific contact identification, such as updates or deletions.
   */
  id?: string | undefined;
  /**
   * The full name of the contact as recorded in the CRM. This string is required and serves as a key piece of information for identifying and displaying contacts in user interfaces and reports.
   */
  name: string | null;
  /**
   * The identifier of the user or entity that owns or manages the contact. This string helps in assigning responsibility and tracking contact management within the CRM system.
   */
  ownerId?: string | null | undefined;
  /**
   * Specifies the type or category of the contact, such as 'customer', 'lead', or 'vendor'. This string helps in classifying contacts for better organization and targeted operations within the CRM.
   */
  type?: ListContactsResponseType | null | undefined;
  /**
   * A unique identifier for the company associated with the contact. This string value is used to link the contact to its respective company within the CRM system, facilitating data organization and retrieval.
   */
  companyId?: string | null | undefined;
  /**
   * The official name of the company that the contact is linked to. This string provides a human-readable reference to the company, aiding in the identification and display of contact affiliations within applications.
   */
  companyName?: string | null | undefined;
  /**
   * A unique identifier for the lead associated with the contact. This string is used to connect the contact to a specific lead record, which can be useful for tracking the contact's origin or sales process involvement.
   */
  leadId?: string | null | undefined;
  /**
   * The given name of the contact person. This string is part of the contact's personal information and is typically used in user interfaces and communications to address the contact directly.
   */
  firstName?: string | null | undefined;
  /**
   * The middle name of the contact, if available. This string provides additional personal identification details, which can be useful for distinguishing between contacts with similar names.
   */
  middleName?: string | null | undefined;
  /**
   * The last name of the contact as recorded in the CRM system. This field may be empty if the last name is not provided. It is used to identify and sort contacts within lists and reports.
   */
  lastName?: string | null | undefined;
  /**
   * The prefix of the contact, such as 'Mr.', 'Ms.', or 'Dr.', which is used for formal addressing. This field is optional and may be omitted if not applicable.
   */
  prefix?: string | null | undefined;
  /**
   * The suffix of the contact, such as 'Jr.', 'Sr.', or 'III', which is used to distinguish between individuals with similar names. This field is optional and may be left blank if not applicable.
   */
  suffix?: string | null | undefined;
  /**
   * The job title of the contact, indicating their role or position within their organization. This information is useful for understanding the contact's responsibilities and authority level.
   */
  title?: string | null | undefined;
  /**
   * The department within the organization where the contact works. This helps categorize contacts based on their functional area, aiding in targeted communication and analysis.
   */
  department?: string | null | undefined;
  /**
   * The language code representing the contact's preferred language, formatted according to ISO 639-1 standards. For example, 'EN' for English in the United States. This helps in localizing content and communications for the contact.
   */
  language?: string | null | undefined;
  /**
   * The gender of the contact, typically represented as 'male', 'female', or other gender identities. This information can be used for personalized communication and analytics.
   */
  gender?: ListContactsResponseGender | null | undefined;
  /**
   * The contact's date of birth, formatted as a string in the 'YYYY-MM-DD' format. This can be used for age verification, birthday greetings, or demographic analysis.
   */
  birthday?: string | null | undefined;
  /**
   * A URL pointing to an image file associated with the contact, such as a profile picture. This can be used to visually represent the contact in applications or reports.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  image?: string | null | undefined;
  /**
   * The URL of the contact's photo, typically used to display the contact's image in user interfaces. This is useful for visual identification and personalization in applications.
   */
  photoUrl?: string | null | undefined;
  /**
   * Indicates the origin from which the contact was acquired, such as 'web', 'referral', or 'advertisement'. This helps in tracking the effectiveness of different lead generation channels. The value is a string that may be used for analytics and reporting purposes.
   */
  leadSource?: string | null | undefined;
  /**
   * Contains the fax number associated with the contact, formatted as a string. This field may be empty if the contact does not have a fax number. Useful for businesses that still utilize fax communication.
   */
  fax?: string | null | undefined;
  /**
   * A brief textual description or notes about the contact, which can include additional context or personal notes. This string field is optional and can be used to store miscellaneous information that doesn't fit into other fields.
   */
  description?: string | null | undefined;
  /**
   * Represents the current financial balance associated with the contact, expressed as a numerical value. This could be used in contexts where the contact has an account balance or outstanding payments. The value is optional and may not be present for all contacts.
   */
  currentBalance?: number | null | undefined;
  /**
   * Denotes the current status of the contact, such as 'active', 'inactive', or 'pending'. This string helps in categorizing contacts based on their engagement or lifecycle stage within the CRM system. It is useful for filtering and managing contact lists.
   */
  status?: string | null | undefined;
  /**
   * Indicates whether the contact is currently active or inactive in the CRM system. This boolean value helps in filtering contacts based on their status, allowing applications to focus on active contacts for operations like communication or updates.
   */
  active?: boolean | null | undefined;
  /**
   * An array containing the list of websites associated with the contact. Each entry in the array represents a website object, providing detailed information such as URL and type, which can be used for displaying or linking purposes.
   */
  websites?: Array<ListContactsResponseWebsites> | undefined;
  /**
   * An array containing address objects associated with the contact. Each object in the array represents a distinct address entry, which may include details such as type, full address string, and name. This array allows applications to handle multiple addresses for a single contact efficiently.
   */
  addresses?: Array<ListContactsResponseAddresses> | undefined;
  /**
   * An array containing the social media links associated with the contact. Each entry in the array represents a distinct social media profile, providing a comprehensive view of the contact's online presence. This property is optional and may be empty if no social links are available for the contact.
   */
  socialLinks?: Array<ListContactsResponseSocialLinks> | undefined;
  /**
   * An array of phone numbers associated with the contact. Each entry in the array represents a different phone number, providing multiple contact options. This property is optional and may be empty if no phone numbers are available for the contact.
   */
  phoneNumbers?: Array<ListContactsResponsePhoneNumbers> | undefined;
  /**
   * An array containing email objects associated with the contact. Each object includes details such as the email address, its type, and a unique identifier, facilitating comprehensive email management for the contact.
   */
  emails?: Array<ListContactsResponseEmails> | undefined;
  /**
   * The email domain associated with the contact's primary email address. This is typically the part of the email address following the '@' symbol and helps in categorizing contacts by their organization or email provider. It is returned as a string and may be used for filtering or grouping contacts in the CRM.
   */
  emailDomain?: string | null | undefined;
  /**
   * An array of custom fields associated with the contact, allowing for additional, user-defined data to be stored. Each entry in the array represents a unique custom field, providing flexibility to include information beyond standard contact details. This array can be empty if no custom fields are defined for the contact.
   */
  customFields?: Array<ListContactsResponseCustomFields> | undefined;
  /**
   * An array of tags associated with the contact, each representing a label or category that helps in organizing and filtering contacts. Tags are useful for segmenting contacts based on specific criteria or characteristics.
   */
  tags?: Array<string> | null | undefined;
  /**
   * The date and time when the first call was made to or from the contact, formatted as an ISO 8601 string. This timestamp helps track the initial point of voice communication with the contact.
   */
  firstCallAt?: Date | null | undefined;
  /**
   * The date and time when the first email was sent to or received from the contact, formatted as an ISO 8601 string. This information is useful for understanding the history of email interactions with the contact.
   */
  firstEmailAt?: Date | null | undefined;
  /**
   * The timestamp indicating the most recent interaction or activity associated with the contact. This is formatted as an ISO 8601 string, allowing developers to track engagement and activity trends over time. Useful for applications that need to display or analyze recent contact interactions.
   */
  lastActivityAt?: Date | null | undefined;
  /**
   * An object containing any custom field mappings configured for the contact resource. This allows developers to access additional, non-standard data fields that have been tailored to specific business needs. The structure of this object depends on the custom mappings set up in the CRM.
   */
  customMappings?: ListContactsResponseCustomMappings | null | undefined;
  /**
   * The timestamp of the last modification made to the contact's record. Provided as an ISO 8601 string, this helps developers determine the recency of the data and manage synchronization processes effectively. It is crucial for applications that rely on the most current contact information.
   */
  updatedAt?: Date | null | undefined;
  /**
   * The timestamp indicating when the contact was initially created in the CRM system. This is formatted as an ISO 8601 string, providing a historical reference for when the contact was added. Useful for tracking the age of contact records and understanding data growth over time.
   */
  createdAt?: Date | null | undefined;
  /**
   * An array of identifiers representing opportunities associated with the contact. Each ID corresponds to a specific opportunity record in the CRM, allowing developers to link contacts to potential business deals or projects. This is essential for applications that need to display or analyze contact-related opportunities.
   */
  opportunityIds?: Array<string> | undefined;
  /**
   * An array that allows the inclusion of service-specific custom data or structured modifications in the request body. This property is used when creating or updating resources, enabling developers to pass additional information that may be required by specific services.
   */
  passThrough?: Array<ListContactsResponsePassThrough> | undefined;
};

/**
 * This object contains cursors that help navigate through paginated API results. It includes pointers to move to previous, current, or next pages, facilitating efficient data retrieval in large datasets. The structure is essential for implementing pagination in applications consuming the API.
 */
export type ListContactsResponseCursors = {
  /**
   * A string cursor that points to the previous page of results in a paginated response. Use this cursor to retrieve the set of results immediately preceding the current page, enabling backward navigation through the dataset.
   */
  previous?: string | null | undefined;
  /**
   * A string cursor representing the current page of results in the paginated response. This cursor is useful for maintaining the current position in the dataset, especially when refreshing or reloading data.
   */
  current?: string | null | undefined;
  /**
   * A string cursor that points to the next page of results in a paginated response. Use this cursor to fetch the subsequent set of results, allowing forward navigation through the dataset.
   */
  next?: string | null | undefined;
};

/**
 * An object containing metadata about the response, such as pagination details or request processing information. This metadata helps in understanding the context of the response and managing subsequent data retrieval operations efficiently.
 */
export type ListContactsResponseMeta = {
  /**
   * Indicates the number of contact items included in the current page of the response. This integer value helps in managing pagination by showing how many contacts are returned in this specific API call, aiding in navigation through large datasets.
   */
  itemsOnPage?: number | undefined;
  /**
   * This object contains cursors that help navigate through paginated API results. It includes pointers to move to previous, current, or next pages, facilitating efficient data retrieval in large datasets. The structure is essential for implementing pagination in applications consuming the API.
   */
  cursors?: ListContactsResponseCursors | undefined;
};

/**
 * This object contains hypermedia links that facilitate navigation to previous or next pages in the API response. It provides URLs that can be used directly to access other pages, supporting RESTful navigation patterns in client applications.
 */
export type ListContactsResponseLinks = {
  /**
   * This property contains the URL link to the previous page of contact results in the paginated response. It is a string formatted as a URL and is included when there is a preceding page available. This link is useful for navigating backward through the list of contacts when handling large datasets.
   */
  previous?: string | null | undefined;
  /**
   * This property provides the URL link to the current page of contact results in the paginated response. It is formatted as a string URL and represents the current position in the pagination sequence. This link is essential for referencing the current set of contacts being viewed or processed.
   */
  current?: string | undefined;
  /**
   * This property contains the URL link to the next page of contact results in the paginated response. It is a string formatted as a URL and is included when there is a subsequent page available. This link facilitates forward navigation through the contact list, aiding in efficient data retrieval and browsing.
   */
  next?: string | null | undefined;
};

/**
 * Contacts
 */
export type ListContactsResponse = {
  /**
   * The HTTP response status code indicating the result of the API request. This integer value helps determine whether the request was successful (e.g., 200 for success) or if there was an error (e.g., 404 for not found). It is crucial for error handling and debugging in client applications.
   */
  statusCode: number;
  /**
   * A string representation of the HTTP response status, such as 'OK' for a successful request or 'Not Found' for an error. This provides a human-readable status that complements the status code, aiding in quick understanding of the request outcome.
   */
  status: string;
  /**
   * The Apideck ID of the service provider from which the contact data is retrieved. This string identifier is essential for distinguishing between different service providers integrated into the CRM system, ensuring the correct source of data is referenced.
   */
  service: string;
  /**
   * The name of the Unified API resource being accessed, in this case, 'contacts'. This string value helps identify the specific resource type involved in the API operation, facilitating resource-specific processing and handling in applications.
   */
  resource: string;
  /**
   * The specific operation performed by the API request, represented as a string. For this endpoint, it typically indicates a 'GET' operation, reflecting the retrieval of contact data from the CRM system. This helps in logging and tracking the type of API interactions performed.
   */
  operation: string;
  /**
   * An array containing the list of contact objects retrieved from the CRM. Each object within the array represents a single contact and includes detailed information such as the contact's ID, name, owner, and type. This array is the primary data structure returned by the 'contactsAll' operation, facilitating easy access and manipulation of contact data.
   */
  data: Array<ListContactsResponseData>;
  /**
   * An object containing metadata about the response, such as pagination details or request processing information. This metadata helps in understanding the context of the response and managing subsequent data retrieval operations efficiently.
   */
  meta?: ListContactsResponseMeta | undefined;
  /**
   * This object contains hypermedia links that facilitate navigation to previous or next pages in the API response. It provides URLs that can be used directly to access other pages, supporting RESTful navigation patterns in client applications.
   */
  links?: ListContactsResponseLinks | undefined;
};

/** @internal */
export const ListContactsResponseType$inboundSchema: z.ZodNativeEnum<
  typeof ListContactsResponseType
> = z.nativeEnum(ListContactsResponseType);

/** @internal */
export const ListContactsResponseType$outboundSchema: z.ZodNativeEnum<
  typeof ListContactsResponseType
> = ListContactsResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseType$ {
  /** @deprecated use `ListContactsResponseType$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseType$inboundSchema;
  /** @deprecated use `ListContactsResponseType$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseType$outboundSchema;
}

/** @internal */
export const ListContactsResponseGender$inboundSchema: z.ZodNativeEnum<
  typeof ListContactsResponseGender
> = z.nativeEnum(ListContactsResponseGender);

/** @internal */
export const ListContactsResponseGender$outboundSchema: z.ZodNativeEnum<
  typeof ListContactsResponseGender
> = ListContactsResponseGender$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseGender$ {
  /** @deprecated use `ListContactsResponseGender$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseGender$inboundSchema;
  /** @deprecated use `ListContactsResponseGender$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseGender$outboundSchema;
}

/** @internal */
export const ListContactsResponseDataType$inboundSchema: z.ZodNativeEnum<
  typeof ListContactsResponseDataType
> = z.nativeEnum(ListContactsResponseDataType);

/** @internal */
export const ListContactsResponseDataType$outboundSchema: z.ZodNativeEnum<
  typeof ListContactsResponseDataType
> = ListContactsResponseDataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseDataType$ {
  /** @deprecated use `ListContactsResponseDataType$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseDataType$inboundSchema;
  /** @deprecated use `ListContactsResponseDataType$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseDataType$outboundSchema;
}

/** @internal */
export const ListContactsResponseWebsites$inboundSchema: z.ZodType<
  ListContactsResponseWebsites,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(ListContactsResponseDataType$inboundSchema).optional(),
});

/** @internal */
export type ListContactsResponseWebsites$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const ListContactsResponseWebsites$outboundSchema: z.ZodType<
  ListContactsResponseWebsites$Outbound,
  z.ZodTypeDef,
  ListContactsResponseWebsites
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(ListContactsResponseDataType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseWebsites$ {
  /** @deprecated use `ListContactsResponseWebsites$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseWebsites$inboundSchema;
  /** @deprecated use `ListContactsResponseWebsites$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseWebsites$outboundSchema;
  /** @deprecated use `ListContactsResponseWebsites$Outbound` instead. */
  export type Outbound = ListContactsResponseWebsites$Outbound;
}

export function listContactsResponseWebsitesToJSON(
  listContactsResponseWebsites: ListContactsResponseWebsites,
): string {
  return JSON.stringify(
    ListContactsResponseWebsites$outboundSchema.parse(
      listContactsResponseWebsites,
    ),
  );
}

export function listContactsResponseWebsitesFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseWebsites, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseWebsites$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseWebsites' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseDataAddressesType$inboundSchema:
  z.ZodNativeEnum<typeof ListContactsResponseDataAddressesType> = z.nativeEnum(
    ListContactsResponseDataAddressesType,
  );

/** @internal */
export const ListContactsResponseDataAddressesType$outboundSchema:
  z.ZodNativeEnum<typeof ListContactsResponseDataAddressesType> =
    ListContactsResponseDataAddressesType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseDataAddressesType$ {
  /** @deprecated use `ListContactsResponseDataAddressesType$inboundSchema` instead. */
  export const inboundSchema =
    ListContactsResponseDataAddressesType$inboundSchema;
  /** @deprecated use `ListContactsResponseDataAddressesType$outboundSchema` instead. */
  export const outboundSchema =
    ListContactsResponseDataAddressesType$outboundSchema;
}

/** @internal */
export const ListContactsResponseAddresses$inboundSchema: z.ZodType<
  ListContactsResponseAddresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(ListContactsResponseDataAddressesType$inboundSchema)
    .optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  street_number: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postal_code: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contact_name: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phone_number: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  row_version: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "street_number": "streetNumber",
    "postal_code": "postalCode",
    "contact_name": "contactName",
    "phone_number": "phoneNumber",
    "row_version": "rowVersion",
  });
});

/** @internal */
export type ListContactsResponseAddresses$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
  string?: string | null | undefined;
  name?: string | null | undefined;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  line3?: string | null | undefined;
  line4?: string | null | undefined;
  street_number?: string | null | undefined;
  city?: string | null | undefined;
  state?: string | null | undefined;
  postal_code?: string | null | undefined;
  country?: string | null | undefined;
  latitude?: string | null | undefined;
  longitude?: string | null | undefined;
  county?: string | null | undefined;
  contact_name?: string | null | undefined;
  salutation?: string | null | undefined;
  phone_number?: string | null | undefined;
  fax?: string | null | undefined;
  email?: string | null | undefined;
  website?: string | null | undefined;
  notes?: string | null | undefined;
  row_version?: string | null | undefined;
};

/** @internal */
export const ListContactsResponseAddresses$outboundSchema: z.ZodType<
  ListContactsResponseAddresses$Outbound,
  z.ZodTypeDef,
  ListContactsResponseAddresses
> = z.object({
  id: z.nullable(z.string()).optional(),
  type: z.nullable(ListContactsResponseDataAddressesType$outboundSchema)
    .optional(),
  string: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  line3: z.nullable(z.string()).optional(),
  line4: z.nullable(z.string()).optional(),
  streetNumber: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  state: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  latitude: z.nullable(z.string()).optional(),
  longitude: z.nullable(z.string()).optional(),
  county: z.nullable(z.string()).optional(),
  contactName: z.nullable(z.string()).optional(),
  salutation: z.nullable(z.string()).optional(),
  phoneNumber: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  website: z.nullable(z.string()).optional(),
  notes: z.nullable(z.string()).optional(),
  rowVersion: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    streetNumber: "street_number",
    postalCode: "postal_code",
    contactName: "contact_name",
    phoneNumber: "phone_number",
    rowVersion: "row_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseAddresses$ {
  /** @deprecated use `ListContactsResponseAddresses$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseAddresses$inboundSchema;
  /** @deprecated use `ListContactsResponseAddresses$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseAddresses$outboundSchema;
  /** @deprecated use `ListContactsResponseAddresses$Outbound` instead. */
  export type Outbound = ListContactsResponseAddresses$Outbound;
}

export function listContactsResponseAddressesToJSON(
  listContactsResponseAddresses: ListContactsResponseAddresses,
): string {
  return JSON.stringify(
    ListContactsResponseAddresses$outboundSchema.parse(
      listContactsResponseAddresses,
    ),
  );
}

export function listContactsResponseAddressesFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseAddresses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseAddresses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseAddresses' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseSocialLinks$inboundSchema: z.ZodType<
  ListContactsResponseSocialLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/** @internal */
export type ListContactsResponseSocialLinks$Outbound = {
  id?: string | null | undefined;
  url: string;
  type?: string | null | undefined;
};

/** @internal */
export const ListContactsResponseSocialLinks$outboundSchema: z.ZodType<
  ListContactsResponseSocialLinks$Outbound,
  z.ZodTypeDef,
  ListContactsResponseSocialLinks
> = z.object({
  id: z.nullable(z.string()).optional(),
  url: z.string(),
  type: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseSocialLinks$ {
  /** @deprecated use `ListContactsResponseSocialLinks$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseSocialLinks$inboundSchema;
  /** @deprecated use `ListContactsResponseSocialLinks$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseSocialLinks$outboundSchema;
  /** @deprecated use `ListContactsResponseSocialLinks$Outbound` instead. */
  export type Outbound = ListContactsResponseSocialLinks$Outbound;
}

export function listContactsResponseSocialLinksToJSON(
  listContactsResponseSocialLinks: ListContactsResponseSocialLinks,
): string {
  return JSON.stringify(
    ListContactsResponseSocialLinks$outboundSchema.parse(
      listContactsResponseSocialLinks,
    ),
  );
}

export function listContactsResponseSocialLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseSocialLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseSocialLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseSocialLinks' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseDataPhoneNumbersType$inboundSchema:
  z.ZodNativeEnum<typeof ListContactsResponseDataPhoneNumbersType> = z
    .nativeEnum(ListContactsResponseDataPhoneNumbersType);

/** @internal */
export const ListContactsResponseDataPhoneNumbersType$outboundSchema:
  z.ZodNativeEnum<typeof ListContactsResponseDataPhoneNumbersType> =
    ListContactsResponseDataPhoneNumbersType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseDataPhoneNumbersType$ {
  /** @deprecated use `ListContactsResponseDataPhoneNumbersType$inboundSchema` instead. */
  export const inboundSchema =
    ListContactsResponseDataPhoneNumbersType$inboundSchema;
  /** @deprecated use `ListContactsResponseDataPhoneNumbersType$outboundSchema` instead. */
  export const outboundSchema =
    ListContactsResponseDataPhoneNumbersType$outboundSchema;
}

/** @internal */
export const ListContactsResponsePhoneNumbers$inboundSchema: z.ZodType<
  ListContactsResponsePhoneNumbers,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  country_code: z.nullable(z.string()).optional(),
  area_code: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(ListContactsResponseDataPhoneNumbersType$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "country_code": "countryCode",
    "area_code": "areaCode",
  });
});

/** @internal */
export type ListContactsResponsePhoneNumbers$Outbound = {
  id?: string | null | undefined;
  country_code?: string | null | undefined;
  area_code?: string | null | undefined;
  number: string;
  extension?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const ListContactsResponsePhoneNumbers$outboundSchema: z.ZodType<
  ListContactsResponsePhoneNumbers$Outbound,
  z.ZodTypeDef,
  ListContactsResponsePhoneNumbers
> = z.object({
  id: z.nullable(z.string()).optional(),
  countryCode: z.nullable(z.string()).optional(),
  areaCode: z.nullable(z.string()).optional(),
  number: z.string(),
  extension: z.nullable(z.string()).optional(),
  type: z.nullable(ListContactsResponseDataPhoneNumbersType$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    countryCode: "country_code",
    areaCode: "area_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponsePhoneNumbers$ {
  /** @deprecated use `ListContactsResponsePhoneNumbers$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponsePhoneNumbers$inboundSchema;
  /** @deprecated use `ListContactsResponsePhoneNumbers$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponsePhoneNumbers$outboundSchema;
  /** @deprecated use `ListContactsResponsePhoneNumbers$Outbound` instead. */
  export type Outbound = ListContactsResponsePhoneNumbers$Outbound;
}

export function listContactsResponsePhoneNumbersToJSON(
  listContactsResponsePhoneNumbers: ListContactsResponsePhoneNumbers,
): string {
  return JSON.stringify(
    ListContactsResponsePhoneNumbers$outboundSchema.parse(
      listContactsResponsePhoneNumbers,
    ),
  );
}

export function listContactsResponsePhoneNumbersFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponsePhoneNumbers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponsePhoneNumbers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponsePhoneNumbers' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseDataEmailsType$inboundSchema: z.ZodNativeEnum<
  typeof ListContactsResponseDataEmailsType
> = z.nativeEnum(ListContactsResponseDataEmailsType);

/** @internal */
export const ListContactsResponseDataEmailsType$outboundSchema: z.ZodNativeEnum<
  typeof ListContactsResponseDataEmailsType
> = ListContactsResponseDataEmailsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseDataEmailsType$ {
  /** @deprecated use `ListContactsResponseDataEmailsType$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseDataEmailsType$inboundSchema;
  /** @deprecated use `ListContactsResponseDataEmailsType$outboundSchema` instead. */
  export const outboundSchema =
    ListContactsResponseDataEmailsType$outboundSchema;
}

/** @internal */
export const ListContactsResponseEmails$inboundSchema: z.ZodType<
  ListContactsResponseEmails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(ListContactsResponseDataEmailsType$inboundSchema).optional(),
});

/** @internal */
export type ListContactsResponseEmails$Outbound = {
  id?: string | null | undefined;
  email: string | null;
  type?: string | null | undefined;
};

/** @internal */
export const ListContactsResponseEmails$outboundSchema: z.ZodType<
  ListContactsResponseEmails$Outbound,
  z.ZodTypeDef,
  ListContactsResponseEmails
> = z.object({
  id: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()),
  type: z.nullable(ListContactsResponseDataEmailsType$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseEmails$ {
  /** @deprecated use `ListContactsResponseEmails$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseEmails$inboundSchema;
  /** @deprecated use `ListContactsResponseEmails$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseEmails$outboundSchema;
  /** @deprecated use `ListContactsResponseEmails$Outbound` instead. */
  export type Outbound = ListContactsResponseEmails$Outbound;
}

export function listContactsResponseEmailsToJSON(
  listContactsResponseEmails: ListContactsResponseEmails,
): string {
  return JSON.stringify(
    ListContactsResponseEmails$outboundSchema.parse(listContactsResponseEmails),
  );
}

export function listContactsResponseEmailsFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseEmails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseEmails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseEmails' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseValue6$inboundSchema: z.ZodType<
  ListContactsResponseValue6,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ListContactsResponseValue6$Outbound = {};

/** @internal */
export const ListContactsResponseValue6$outboundSchema: z.ZodType<
  ListContactsResponseValue6$Outbound,
  z.ZodTypeDef,
  ListContactsResponseValue6
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseValue6$ {
  /** @deprecated use `ListContactsResponseValue6$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseValue6$inboundSchema;
  /** @deprecated use `ListContactsResponseValue6$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseValue6$outboundSchema;
  /** @deprecated use `ListContactsResponseValue6$Outbound` instead. */
  export type Outbound = ListContactsResponseValue6$Outbound;
}

export function listContactsResponseValue6ToJSON(
  listContactsResponseValue6: ListContactsResponseValue6,
): string {
  return JSON.stringify(
    ListContactsResponseValue6$outboundSchema.parse(listContactsResponseValue6),
  );
}

export function listContactsResponseValue6FromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseValue6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseValue6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseValue6' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseValue4$inboundSchema: z.ZodType<
  ListContactsResponseValue4,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ListContactsResponseValue4$Outbound = {};

/** @internal */
export const ListContactsResponseValue4$outboundSchema: z.ZodType<
  ListContactsResponseValue4$Outbound,
  z.ZodTypeDef,
  ListContactsResponseValue4
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseValue4$ {
  /** @deprecated use `ListContactsResponseValue4$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseValue4$inboundSchema;
  /** @deprecated use `ListContactsResponseValue4$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseValue4$outboundSchema;
  /** @deprecated use `ListContactsResponseValue4$Outbound` instead. */
  export type Outbound = ListContactsResponseValue4$Outbound;
}

export function listContactsResponseValue4ToJSON(
  listContactsResponseValue4: ListContactsResponseValue4,
): string {
  return JSON.stringify(
    ListContactsResponseValue4$outboundSchema.parse(listContactsResponseValue4),
  );
}

export function listContactsResponseValue4FromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseValue4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseValue4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseValue4' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseValue$inboundSchema: z.ZodType<
  ListContactsResponseValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListContactsResponseValue4$inboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
  z.array(z.string()),
  z.array(z.lazy(() => ListContactsResponseValue6$inboundSchema)),
]);

/** @internal */
export type ListContactsResponseValue$Outbound =
  | ListContactsResponseValue4$Outbound
  | string
  | number
  | boolean
  | Array<string>
  | Array<ListContactsResponseValue6$Outbound>;

/** @internal */
export const ListContactsResponseValue$outboundSchema: z.ZodType<
  ListContactsResponseValue$Outbound,
  z.ZodTypeDef,
  ListContactsResponseValue
> = z.union([
  z.lazy(() => ListContactsResponseValue4$outboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
  z.array(z.string()),
  z.array(z.lazy(() => ListContactsResponseValue6$outboundSchema)),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseValue$ {
  /** @deprecated use `ListContactsResponseValue$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseValue$inboundSchema;
  /** @deprecated use `ListContactsResponseValue$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseValue$outboundSchema;
  /** @deprecated use `ListContactsResponseValue$Outbound` instead. */
  export type Outbound = ListContactsResponseValue$Outbound;
}

export function listContactsResponseValueToJSON(
  listContactsResponseValue: ListContactsResponseValue,
): string {
  return JSON.stringify(
    ListContactsResponseValue$outboundSchema.parse(listContactsResponseValue),
  );
}

export function listContactsResponseValueFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseValue' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseCustomFields$inboundSchema: z.ZodType<
  ListContactsResponseCustomFields,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => ListContactsResponseValue4$inboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => ListContactsResponseValue6$inboundSchema)),
    ]),
  ).optional(),
});

/** @internal */
export type ListContactsResponseCustomFields$Outbound = {
  id: string | null;
  name?: string | null | undefined;
  description?: string | null | undefined;
  value?:
    | ListContactsResponseValue4$Outbound
    | string
    | number
    | boolean
    | Array<string>
    | Array<ListContactsResponseValue6$Outbound>
    | null
    | undefined;
};

/** @internal */
export const ListContactsResponseCustomFields$outboundSchema: z.ZodType<
  ListContactsResponseCustomFields$Outbound,
  z.ZodTypeDef,
  ListContactsResponseCustomFields
> = z.object({
  id: z.nullable(z.string()),
  name: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  value: z.nullable(
    z.union([
      z.lazy(() => ListContactsResponseValue4$outboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
      z.array(z.string()),
      z.array(z.lazy(() => ListContactsResponseValue6$outboundSchema)),
    ]),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseCustomFields$ {
  /** @deprecated use `ListContactsResponseCustomFields$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseCustomFields$inboundSchema;
  /** @deprecated use `ListContactsResponseCustomFields$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseCustomFields$outboundSchema;
  /** @deprecated use `ListContactsResponseCustomFields$Outbound` instead. */
  export type Outbound = ListContactsResponseCustomFields$Outbound;
}

export function listContactsResponseCustomFieldsToJSON(
  listContactsResponseCustomFields: ListContactsResponseCustomFields,
): string {
  return JSON.stringify(
    ListContactsResponseCustomFields$outboundSchema.parse(
      listContactsResponseCustomFields,
    ),
  );
}

export function listContactsResponseCustomFieldsFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseCustomFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseCustomFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseCustomFields' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseCustomMappings$inboundSchema: z.ZodType<
  ListContactsResponseCustomMappings,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ListContactsResponseCustomMappings$Outbound = {};

/** @internal */
export const ListContactsResponseCustomMappings$outboundSchema: z.ZodType<
  ListContactsResponseCustomMappings$Outbound,
  z.ZodTypeDef,
  ListContactsResponseCustomMappings
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseCustomMappings$ {
  /** @deprecated use `ListContactsResponseCustomMappings$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseCustomMappings$inboundSchema;
  /** @deprecated use `ListContactsResponseCustomMappings$outboundSchema` instead. */
  export const outboundSchema =
    ListContactsResponseCustomMappings$outboundSchema;
  /** @deprecated use `ListContactsResponseCustomMappings$Outbound` instead. */
  export type Outbound = ListContactsResponseCustomMappings$Outbound;
}

export function listContactsResponseCustomMappingsToJSON(
  listContactsResponseCustomMappings: ListContactsResponseCustomMappings,
): string {
  return JSON.stringify(
    ListContactsResponseCustomMappings$outboundSchema.parse(
      listContactsResponseCustomMappings,
    ),
  );
}

export function listContactsResponseCustomMappingsFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseCustomMappings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListContactsResponseCustomMappings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseCustomMappings' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseExtendPaths$inboundSchema: z.ZodType<
  ListContactsResponseExtendPaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/** @internal */
export type ListContactsResponseExtendPaths$Outbound = {
  path: string;
  value?: any | undefined;
};

/** @internal */
export const ListContactsResponseExtendPaths$outboundSchema: z.ZodType<
  ListContactsResponseExtendPaths$Outbound,
  z.ZodTypeDef,
  ListContactsResponseExtendPaths
> = z.object({
  path: z.string(),
  value: z.any().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseExtendPaths$ {
  /** @deprecated use `ListContactsResponseExtendPaths$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseExtendPaths$inboundSchema;
  /** @deprecated use `ListContactsResponseExtendPaths$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseExtendPaths$outboundSchema;
  /** @deprecated use `ListContactsResponseExtendPaths$Outbound` instead. */
  export type Outbound = ListContactsResponseExtendPaths$Outbound;
}

export function listContactsResponseExtendPathsToJSON(
  listContactsResponseExtendPaths: ListContactsResponseExtendPaths,
): string {
  return JSON.stringify(
    ListContactsResponseExtendPaths$outboundSchema.parse(
      listContactsResponseExtendPaths,
    ),
  );
}

export function listContactsResponseExtendPathsFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseExtendPaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseExtendPaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseExtendPaths' from JSON`,
  );
}

/** @internal */
export const ListContactsResponsePassThrough$inboundSchema: z.ZodType<
  ListContactsResponsePassThrough,
  z.ZodTypeDef,
  unknown
> = z.object({
  service_id: z.string(),
  operation_id: z.string().optional(),
  extend_object: z.record(z.any()).optional(),
  extend_paths: z.array(
    z.lazy(() => ListContactsResponseExtendPaths$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "operation_id": "operationId",
    "extend_object": "extendObject",
    "extend_paths": "extendPaths",
  });
});

/** @internal */
export type ListContactsResponsePassThrough$Outbound = {
  service_id: string;
  operation_id?: string | undefined;
  extend_object?: { [k: string]: any } | undefined;
  extend_paths?: Array<ListContactsResponseExtendPaths$Outbound> | undefined;
};

/** @internal */
export const ListContactsResponsePassThrough$outboundSchema: z.ZodType<
  ListContactsResponsePassThrough$Outbound,
  z.ZodTypeDef,
  ListContactsResponsePassThrough
> = z.object({
  serviceId: z.string(),
  operationId: z.string().optional(),
  extendObject: z.record(z.any()).optional(),
  extendPaths: z.array(
    z.lazy(() => ListContactsResponseExtendPaths$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    serviceId: "service_id",
    operationId: "operation_id",
    extendObject: "extend_object",
    extendPaths: "extend_paths",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponsePassThrough$ {
  /** @deprecated use `ListContactsResponsePassThrough$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponsePassThrough$inboundSchema;
  /** @deprecated use `ListContactsResponsePassThrough$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponsePassThrough$outboundSchema;
  /** @deprecated use `ListContactsResponsePassThrough$Outbound` instead. */
  export type Outbound = ListContactsResponsePassThrough$Outbound;
}

export function listContactsResponsePassThroughToJSON(
  listContactsResponsePassThrough: ListContactsResponsePassThrough,
): string {
  return JSON.stringify(
    ListContactsResponsePassThrough$outboundSchema.parse(
      listContactsResponsePassThrough,
    ),
  );
}

export function listContactsResponsePassThroughFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponsePassThrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponsePassThrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponsePassThrough' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseData$inboundSchema: z.ZodType<
  ListContactsResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  name: z.nullable(z.string()),
  owner_id: z.nullable(z.string()).optional(),
  type: z.nullable(ListContactsResponseType$inboundSchema).optional(),
  company_id: z.nullable(z.string()).optional(),
  company_name: z.nullable(z.string()).optional(),
  lead_id: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  middle_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  prefix: z.nullable(z.string()).optional(),
  suffix: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  gender: z.nullable(ListContactsResponseGender$inboundSchema).optional(),
  birthday: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  photo_url: z.nullable(z.string()).optional(),
  lead_source: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  current_balance: z.nullable(z.number()).optional(),
  status: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  websites: z.array(z.lazy(() => ListContactsResponseWebsites$inboundSchema))
    .optional(),
  addresses: z.array(z.lazy(() => ListContactsResponseAddresses$inboundSchema))
    .optional(),
  social_links: z.array(
    z.lazy(() => ListContactsResponseSocialLinks$inboundSchema),
  ).optional(),
  phone_numbers: z.array(
    z.lazy(() => ListContactsResponsePhoneNumbers$inboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => ListContactsResponseEmails$inboundSchema))
    .optional(),
  email_domain: z.nullable(z.string()).optional(),
  custom_fields: z.array(
    z.lazy(() => ListContactsResponseCustomFields$inboundSchema),
  ).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  first_call_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  first_email_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  last_activity_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  custom_mappings: z.nullable(
    z.lazy(() => ListContactsResponseCustomMappings$inboundSchema),
  ).optional(),
  updated_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  created_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  opportunity_ids: z.array(z.string()).optional(),
  pass_through: z.array(
    z.lazy(() => ListContactsResponsePassThrough$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "company_id": "companyId",
    "company_name": "companyName",
    "lead_id": "leadId",
    "first_name": "firstName",
    "middle_name": "middleName",
    "last_name": "lastName",
    "photo_url": "photoUrl",
    "lead_source": "leadSource",
    "current_balance": "currentBalance",
    "social_links": "socialLinks",
    "phone_numbers": "phoneNumbers",
    "email_domain": "emailDomain",
    "custom_fields": "customFields",
    "first_call_at": "firstCallAt",
    "first_email_at": "firstEmailAt",
    "last_activity_at": "lastActivityAt",
    "custom_mappings": "customMappings",
    "updated_at": "updatedAt",
    "created_at": "createdAt",
    "opportunity_ids": "opportunityIds",
    "pass_through": "passThrough",
  });
});

/** @internal */
export type ListContactsResponseData$Outbound = {
  id?: string | undefined;
  name: string | null;
  owner_id?: string | null | undefined;
  type?: string | null | undefined;
  company_id?: string | null | undefined;
  company_name?: string | null | undefined;
  lead_id?: string | null | undefined;
  first_name?: string | null | undefined;
  middle_name?: string | null | undefined;
  last_name?: string | null | undefined;
  prefix?: string | null | undefined;
  suffix?: string | null | undefined;
  title?: string | null | undefined;
  department?: string | null | undefined;
  language?: string | null | undefined;
  gender?: string | null | undefined;
  birthday?: string | null | undefined;
  image?: string | null | undefined;
  photo_url?: string | null | undefined;
  lead_source?: string | null | undefined;
  fax?: string | null | undefined;
  description?: string | null | undefined;
  current_balance?: number | null | undefined;
  status?: string | null | undefined;
  active?: boolean | null | undefined;
  websites?: Array<ListContactsResponseWebsites$Outbound> | undefined;
  addresses?: Array<ListContactsResponseAddresses$Outbound> | undefined;
  social_links?: Array<ListContactsResponseSocialLinks$Outbound> | undefined;
  phone_numbers?: Array<ListContactsResponsePhoneNumbers$Outbound> | undefined;
  emails?: Array<ListContactsResponseEmails$Outbound> | undefined;
  email_domain?: string | null | undefined;
  custom_fields?: Array<ListContactsResponseCustomFields$Outbound> | undefined;
  tags?: Array<string> | null | undefined;
  first_call_at?: string | null | undefined;
  first_email_at?: string | null | undefined;
  last_activity_at?: string | null | undefined;
  custom_mappings?:
    | ListContactsResponseCustomMappings$Outbound
    | null
    | undefined;
  updated_at?: string | null | undefined;
  created_at?: string | null | undefined;
  opportunity_ids?: Array<string> | undefined;
  pass_through?: Array<ListContactsResponsePassThrough$Outbound> | undefined;
};

/** @internal */
export const ListContactsResponseData$outboundSchema: z.ZodType<
  ListContactsResponseData$Outbound,
  z.ZodTypeDef,
  ListContactsResponseData
> = z.object({
  id: z.string().optional(),
  name: z.nullable(z.string()),
  ownerId: z.nullable(z.string()).optional(),
  type: z.nullable(ListContactsResponseType$outboundSchema).optional(),
  companyId: z.nullable(z.string()).optional(),
  companyName: z.nullable(z.string()).optional(),
  leadId: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  middleName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  prefix: z.nullable(z.string()).optional(),
  suffix: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  department: z.nullable(z.string()).optional(),
  language: z.nullable(z.string()).optional(),
  gender: z.nullable(ListContactsResponseGender$outboundSchema).optional(),
  birthday: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  photoUrl: z.nullable(z.string()).optional(),
  leadSource: z.nullable(z.string()).optional(),
  fax: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  currentBalance: z.nullable(z.number()).optional(),
  status: z.nullable(z.string()).optional(),
  active: z.nullable(z.boolean()).optional(),
  websites: z.array(z.lazy(() => ListContactsResponseWebsites$outboundSchema))
    .optional(),
  addresses: z.array(z.lazy(() => ListContactsResponseAddresses$outboundSchema))
    .optional(),
  socialLinks: z.array(
    z.lazy(() => ListContactsResponseSocialLinks$outboundSchema),
  ).optional(),
  phoneNumbers: z.array(
    z.lazy(() => ListContactsResponsePhoneNumbers$outboundSchema),
  ).optional(),
  emails: z.array(z.lazy(() => ListContactsResponseEmails$outboundSchema))
    .optional(),
  emailDomain: z.nullable(z.string()).optional(),
  customFields: z.array(
    z.lazy(() => ListContactsResponseCustomFields$outboundSchema),
  ).optional(),
  tags: z.nullable(z.array(z.string())).optional(),
  firstCallAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  firstEmailAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  lastActivityAt: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  customMappings: z.nullable(
    z.lazy(() => ListContactsResponseCustomMappings$outboundSchema),
  ).optional(),
  updatedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  createdAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  opportunityIds: z.array(z.string()).optional(),
  passThrough: z.array(
    z.lazy(() => ListContactsResponsePassThrough$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    companyId: "company_id",
    companyName: "company_name",
    leadId: "lead_id",
    firstName: "first_name",
    middleName: "middle_name",
    lastName: "last_name",
    photoUrl: "photo_url",
    leadSource: "lead_source",
    currentBalance: "current_balance",
    socialLinks: "social_links",
    phoneNumbers: "phone_numbers",
    emailDomain: "email_domain",
    customFields: "custom_fields",
    firstCallAt: "first_call_at",
    firstEmailAt: "first_email_at",
    lastActivityAt: "last_activity_at",
    customMappings: "custom_mappings",
    updatedAt: "updated_at",
    createdAt: "created_at",
    opportunityIds: "opportunity_ids",
    passThrough: "pass_through",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseData$ {
  /** @deprecated use `ListContactsResponseData$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseData$inboundSchema;
  /** @deprecated use `ListContactsResponseData$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseData$outboundSchema;
  /** @deprecated use `ListContactsResponseData$Outbound` instead. */
  export type Outbound = ListContactsResponseData$Outbound;
}

export function listContactsResponseDataToJSON(
  listContactsResponseData: ListContactsResponseData,
): string {
  return JSON.stringify(
    ListContactsResponseData$outboundSchema.parse(listContactsResponseData),
  );
}

export function listContactsResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseData' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseCursors$inboundSchema: z.ZodType<
  ListContactsResponseCursors,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type ListContactsResponseCursors$Outbound = {
  previous?: string | null | undefined;
  current?: string | null | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const ListContactsResponseCursors$outboundSchema: z.ZodType<
  ListContactsResponseCursors$Outbound,
  z.ZodTypeDef,
  ListContactsResponseCursors
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.nullable(z.string()).optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseCursors$ {
  /** @deprecated use `ListContactsResponseCursors$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseCursors$inboundSchema;
  /** @deprecated use `ListContactsResponseCursors$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseCursors$outboundSchema;
  /** @deprecated use `ListContactsResponseCursors$Outbound` instead. */
  export type Outbound = ListContactsResponseCursors$Outbound;
}

export function listContactsResponseCursorsToJSON(
  listContactsResponseCursors: ListContactsResponseCursors,
): string {
  return JSON.stringify(
    ListContactsResponseCursors$outboundSchema.parse(
      listContactsResponseCursors,
    ),
  );
}

export function listContactsResponseCursorsFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseCursors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseCursors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseCursors' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseMeta$inboundSchema: z.ZodType<
  ListContactsResponseMeta,
  z.ZodTypeDef,
  unknown
> = z.object({
  items_on_page: z.number().int().optional(),
  cursors: z.lazy(() => ListContactsResponseCursors$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "items_on_page": "itemsOnPage",
  });
});

/** @internal */
export type ListContactsResponseMeta$Outbound = {
  items_on_page?: number | undefined;
  cursors?: ListContactsResponseCursors$Outbound | undefined;
};

/** @internal */
export const ListContactsResponseMeta$outboundSchema: z.ZodType<
  ListContactsResponseMeta$Outbound,
  z.ZodTypeDef,
  ListContactsResponseMeta
> = z.object({
  itemsOnPage: z.number().int().optional(),
  cursors: z.lazy(() => ListContactsResponseCursors$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    itemsOnPage: "items_on_page",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseMeta$ {
  /** @deprecated use `ListContactsResponseMeta$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseMeta$inboundSchema;
  /** @deprecated use `ListContactsResponseMeta$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseMeta$outboundSchema;
  /** @deprecated use `ListContactsResponseMeta$Outbound` instead. */
  export type Outbound = ListContactsResponseMeta$Outbound;
}

export function listContactsResponseMetaToJSON(
  listContactsResponseMeta: ListContactsResponseMeta,
): string {
  return JSON.stringify(
    ListContactsResponseMeta$outboundSchema.parse(listContactsResponseMeta),
  );
}

export function listContactsResponseMetaFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseMeta, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseMeta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseMeta' from JSON`,
  );
}

/** @internal */
export const ListContactsResponseLinks$inboundSchema: z.ZodType<
  ListContactsResponseLinks,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/** @internal */
export type ListContactsResponseLinks$Outbound = {
  previous?: string | null | undefined;
  current?: string | undefined;
  next?: string | null | undefined;
};

/** @internal */
export const ListContactsResponseLinks$outboundSchema: z.ZodType<
  ListContactsResponseLinks$Outbound,
  z.ZodTypeDef,
  ListContactsResponseLinks
> = z.object({
  previous: z.nullable(z.string()).optional(),
  current: z.string().optional(),
  next: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponseLinks$ {
  /** @deprecated use `ListContactsResponseLinks$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponseLinks$inboundSchema;
  /** @deprecated use `ListContactsResponseLinks$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponseLinks$outboundSchema;
  /** @deprecated use `ListContactsResponseLinks$Outbound` instead. */
  export type Outbound = ListContactsResponseLinks$Outbound;
}

export function listContactsResponseLinksToJSON(
  listContactsResponseLinks: ListContactsResponseLinks,
): string {
  return JSON.stringify(
    ListContactsResponseLinks$outboundSchema.parse(listContactsResponseLinks),
  );
}

export function listContactsResponseLinksFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponseLinks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponseLinks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponseLinks' from JSON`,
  );
}

/** @internal */
export const ListContactsResponse$inboundSchema: z.ZodType<
  ListContactsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status_code: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => ListContactsResponseData$inboundSchema)),
  meta: z.lazy(() => ListContactsResponseMeta$inboundSchema).optional(),
  links: z.lazy(() => ListContactsResponseLinks$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
  });
});

/** @internal */
export type ListContactsResponse$Outbound = {
  status_code: number;
  status: string;
  service: string;
  resource: string;
  operation: string;
  data: Array<ListContactsResponseData$Outbound>;
  meta?: ListContactsResponseMeta$Outbound | undefined;
  links?: ListContactsResponseLinks$Outbound | undefined;
};

/** @internal */
export const ListContactsResponse$outboundSchema: z.ZodType<
  ListContactsResponse$Outbound,
  z.ZodTypeDef,
  ListContactsResponse
> = z.object({
  statusCode: z.number().int(),
  status: z.string(),
  service: z.string(),
  resource: z.string(),
  operation: z.string(),
  data: z.array(z.lazy(() => ListContactsResponseData$outboundSchema)),
  meta: z.lazy(() => ListContactsResponseMeta$outboundSchema).optional(),
  links: z.lazy(() => ListContactsResponseLinks$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContactsResponse$ {
  /** @deprecated use `ListContactsResponse$inboundSchema` instead. */
  export const inboundSchema = ListContactsResponse$inboundSchema;
  /** @deprecated use `ListContactsResponse$outboundSchema` instead. */
  export const outboundSchema = ListContactsResponse$outboundSchema;
  /** @deprecated use `ListContactsResponse$Outbound` instead. */
  export type Outbound = ListContactsResponse$Outbound;
}

export function listContactsResponseToJSON(
  listContactsResponse: ListContactsResponse,
): string {
  return JSON.stringify(
    ListContactsResponse$outboundSchema.parse(listContactsResponse),
  );
}

export function listContactsResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListContactsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactsResponse' from JSON`,
  );
}
